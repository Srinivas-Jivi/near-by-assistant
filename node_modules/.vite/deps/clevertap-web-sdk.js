import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/clevertap-web-sdk/clevertap.js
var require_clevertap = __commonJS({
  "node_modules/clevertap-web-sdk/clevertap.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.clevertap = factory());
    })(exports, function() {
      "use strict";
      var id = 0;
      function _classPrivateFieldLooseKey(name) {
        return "__private_" + id++ + "_" + name;
      }
      function _classPrivateFieldLooseBase(receiver, privateKey) {
        if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
          throw new TypeError("attempted to use private field on non-instance");
        }
        return receiver;
      }
      const TARGET_DOMAIN = "clevertap-prod.com";
      const TARGET_PROTOCOL = "https:";
      const DEFAULT_REGION = "eu1";
      var _accountId = _classPrivateFieldLooseKey("accountId");
      var _region = _classPrivateFieldLooseKey("region");
      var _targetDomain = _classPrivateFieldLooseKey("targetDomain");
      var _dcSdkversion = _classPrivateFieldLooseKey("dcSdkversion");
      var _token = _classPrivateFieldLooseKey("token");
      class Account {
        constructor() {
          let {
            id: id2
          } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          let region = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          let targetDomain = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : TARGET_DOMAIN;
          let token = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
          Object.defineProperty(this, _accountId, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _region, {
            writable: true,
            value: ""
          });
          Object.defineProperty(this, _targetDomain, {
            writable: true,
            value: TARGET_DOMAIN
          });
          Object.defineProperty(this, _dcSdkversion, {
            writable: true,
            value: ""
          });
          Object.defineProperty(this, _token, {
            writable: true,
            value: ""
          });
          this.id = id2;
          if (region) {
            this.region = region;
          }
          if (targetDomain) {
            this.targetDomain = targetDomain;
          }
          if (token) {
            this.token = token;
          }
        }
        get id() {
          return _classPrivateFieldLooseBase(this, _accountId)[_accountId];
        }
        set id(accountId) {
          _classPrivateFieldLooseBase(this, _accountId)[_accountId] = accountId;
        }
        get region() {
          return _classPrivateFieldLooseBase(this, _region)[_region];
        }
        set region(region) {
          _classPrivateFieldLooseBase(this, _region)[_region] = region;
        }
        get dcSDKVersion() {
          return _classPrivateFieldLooseBase(this, _dcSdkversion)[_dcSdkversion];
        }
        set dcSDKVersion(dcSDKVersion) {
          _classPrivateFieldLooseBase(this, _dcSdkversion)[_dcSdkversion] = dcSDKVersion;
        }
        get targetDomain() {
          return _classPrivateFieldLooseBase(this, _targetDomain)[_targetDomain];
        }
        set targetDomain(targetDomain) {
          _classPrivateFieldLooseBase(this, _targetDomain)[_targetDomain] = targetDomain;
        }
        get token() {
          return _classPrivateFieldLooseBase(this, _token)[_token];
        }
        set token(token) {
          _classPrivateFieldLooseBase(this, _token)[_token] = token;
        }
        get finalTargetDomain() {
          if (this.region) {
            return "".concat(this.region, ".").concat(this.targetDomain);
          } else {
            if (this.targetDomain === TARGET_DOMAIN) {
              return "".concat(DEFAULT_REGION, ".").concat(this.targetDomain);
            }
            return this.targetDomain;
          }
        }
        get dataPostPEURL() {
          return "".concat(TARGET_PROTOCOL, "//").concat(this.finalTargetDomain, "/defineVars");
        }
        get dataPostURL() {
          return "".concat(TARGET_PROTOCOL, "//").concat(this.finalTargetDomain, "/a?t=96");
        }
        get recorderURL() {
          return "".concat(TARGET_PROTOCOL, "//").concat(this.finalTargetDomain, "/r?r=1");
        }
        get emailURL() {
          return "".concat(TARGET_PROTOCOL, "//").concat(this.finalTargetDomain, "/e?r=1");
        }
      }
      const unsupportedKeyCharRegex = new RegExp(`^\\s+|\\.|:|\\$|'|"|\\\\|\\s+$`, "g");
      const unsupportedValueCharRegex = new RegExp(`^\\s+|'|"|\\\\|\\s+$`, "g");
      const singleQuoteRegex = new RegExp("'", "g");
      const CLEAR = "clear";
      const CHARGED_ID = "Charged ID";
      const CHARGEDID_COOKIE_NAME = "WZRK_CHARGED_ID";
      const GCOOKIE_NAME = "WZRK_G";
      const QUALIFIED_CAMPAIGNS = "WZRK_QC";
      const KCOOKIE_NAME = "WZRK_K";
      const CAMP_COOKIE_NAME = "WZRK_CAMP";
      const CAMP_COOKIE_G = "WZRK_CAMP_G";
      const SCOOKIE_PREFIX = "WZRK_S";
      const SCOOKIE_EXP_TIME_IN_SECS = 60 * 20;
      const EV_COOKIE = "WZRK_EV";
      const META_COOKIE = "WZRK_META";
      const PR_COOKIE = "WZRK_PR";
      const ACCOUNT_ID = "WZRK_ACCOUNT_ID";
      const ARP_COOKIE = "WZRK_ARP";
      const LCOOKIE_NAME = "WZRK_L";
      const GLOBAL = "global";
      const DISPLAY = "display";
      const WEBPUSH_LS_KEY = "WZRK_WPR";
      const OPTOUT_KEY = "optOut";
      const CT_OPTOUT_KEY = "ct_optout";
      const OPTOUT_COOKIE_ENDSWITH = ":OO";
      const USEIP_KEY = "useIP";
      const LRU_CACHE = "WZRK_X";
      const LRU_CACHE_SIZE = 100;
      const IS_OUL = "isOUL";
      const EVT_PUSH = "push";
      const EVT_PING = "ping";
      const COOKIE_EXPIRY = 86400 * 365;
      const MAX_TRIES = 200;
      const FIRST_PING_FREQ_IN_MILLIS = 2 * 60 * 1e3;
      const CONTINUOUS_PING_FREQ_IN_MILLIS = 5 * 60 * 1e3;
      const GROUP_SUBSCRIPTION_REQUEST_ID = "2";
      const categoryLongKey = "cUsY";
      const WZRK_PREFIX = "wzrk_";
      const WZRK_ID = "wzrk_id";
      const NOTIFICATION_VIEWED = "Notification Viewed";
      const NOTIFICATION_CLICKED = "Notification Clicked";
      const FIRE_PUSH_UNREGISTERED = "WZRK_FPU";
      const PUSH_SUBSCRIPTION_DATA = "WZRK_PSD";
      const COMMAND_INCREMENT = "$incr";
      const COMMAND_DECREMENT = "$decr";
      const COMMAND_SET = "$set";
      const COMMAND_ADD = "$add";
      const COMMAND_REMOVE = "$remove";
      const COMMAND_DELETE = "$delete";
      const WEBINBOX_CONFIG = "WZRK_INBOX_CONFIG";
      const WEBINBOX = "WZRK_INBOX";
      const MAX_INBOX_MSG = 15;
      const VARIABLES = "WZRK_PE";
      const PUSH_DELAY_MS = 1e3;
      const MAX_DELAY_FREQUENCY = 1e3 * 60 * 10;
      const WZRK_FETCH = "wzrk_fetch";
      const WEBPUSH_CONFIG = "WZRK_PUSH_CONFIG";
      const APPLICATION_SERVER_KEY_RECEIVED = "WZRK_APPLICATION_SERVER_KEY_RECIEVED";
      const WEBPUSH_CONFIG_RECEIVED = "WZRK_WEB_PUSH_CONFIG_RECEIVED";
      const NOTIFICATION_PUSH_METHOD_DEFERRED = "WZRK_NOTIFICATION_PUSH_DEFERRED";
      const VAPID_MIGRATION_PROMPT_SHOWN = "vapid_migration_prompt_shown";
      const NOTIF_LAST_TIME = "notif_last_time";
      const TIMER_FOR_NOTIF_BADGE_UPDATE = 300;
      const OLD_SOFT_PROMPT_SELCTOR_ID = "wzrk_wrapper";
      const NEW_SOFT_PROMPT_SELCTOR_ID = "pnWrapper";
      const POPUP_LOADING = "WZRK_POPUP_LOADING";
      const CUSTOM_HTML_PREVIEW = "ctCustomHtmlPreview";
      const CUSTOM_CT_ID_PREFIX = "_w_";
      const WEB_NATIVE_TEMPLATES = {
        KV_PAIR: 1,
        BANNER: 2,
        CAROUSEL: 3,
        VISUAL_BUILDER: 4,
        CUSTOM_HTML: 5,
        JSON: 6
      };
      const WEB_NATIVE_DISPLAY_VISUAL_EDITOR_TYPES = {
        HTML: "html",
        FORM: "form",
        JSON: "json"
      };
      const CAMPAIGN_TYPES = {
        EXIT_INTENT: 1,
        WEB_NATIVE_DISPLAY: 2,
        FOOTER_NOTIFICATION: 0,
        FOOTER_NOTIFICATION_2: null
      };
      const SYSTEM_EVENTS = ["Stayed", "UTM Visited", "App Launched", "Notification Sent", NOTIFICATION_VIEWED, NOTIFICATION_CLICKED];
      const KEYS_TO_ENCRYPT = [KCOOKIE_NAME, LRU_CACHE, PR_COOKIE];
      const ACTION_TYPES = {
        OPEN_LINK: "url",
        OPEN_LINK_AND_CLOSE: "urlCloseNotification"
      };
      const isString = (input) => {
        return typeof input === "string" || input instanceof String;
      };
      const isObject = (input) => {
        return Object.prototype.toString.call(input) === "[object Object]";
      };
      const isDateObject = (input) => {
        return typeof input === "object" && input instanceof Date;
      };
      const isObjectEmpty = (obj) => {
        for (const prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            return false;
          }
        }
        return true;
      };
      const isConvertibleToNumber = (n) => {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };
      const isNumber = (n) => {
        return /^-?[\d.]+(?:e-?\d+)?$/.test(n) && typeof n === "number";
      };
      const isValueValid = (value) => {
        if (value === null || value === void 0 || value === "undefined") {
          return false;
        }
        return true;
      };
      const removeUnsupportedChars = (o, logger2) => {
        if (typeof o === "object") {
          for (const key in o) {
            if (o.hasOwnProperty(key)) {
              const sanitizedVal = removeUnsupportedChars(o[key], logger2);
              let sanitizedKey;
              sanitizedKey = sanitize(key, unsupportedKeyCharRegex);
              if (sanitizedKey.length > 1024) {
                sanitizedKey = sanitizedKey.substring(0, 1024);
                logger2.reportError(520, sanitizedKey + "... length exceeded 1024 chars. Trimmed.");
              }
              delete o[key];
              o[sanitizedKey] = sanitizedVal;
            }
          }
        } else {
          let val;
          if (isString(o)) {
            val = sanitize(o, unsupportedValueCharRegex);
            if (val.length > 1024) {
              val = val.substring(0, 1024);
              logger2.reportError(521, val + "... length exceeded 1024 chars. Trimmed.");
            }
          } else {
            val = o;
          }
          return val;
        }
        return o;
      };
      const sanitize = (input, regex) => {
        return input.replace(regex, "");
      };
      const getToday = () => {
        const today = /* @__PURE__ */ new Date();
        return today.getFullYear() + "" + today.getMonth() + today.getDay();
      };
      const getNow = () => {
        return Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
      };
      const convertToWZRKDate = (dateObj) => {
        return "$D_" + Math.round(dateObj.getTime() / 1e3);
      };
      const setDate = (dt) => {
        if (isDateValid(dt)) {
          return "$D_" + dt;
        }
      };
      const isDateValid = (date) => {
        const matches = /^(\d{4})(\d{2})(\d{2})$/.exec(date);
        if (matches == null) return false;
        const d = matches[3];
        const m = matches[2] - 1;
        const y = matches[1];
        const composedDate = new Date(y, m, d);
        return composedDate.getDate() == d && composedDate.getMonth() == m && composedDate.getFullYear() == y;
      };
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var cryptoJs$1 = { exports: {} };
      function commonjsRequire(path) {
        throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
      }
      var core$1 = { exports: {} };
      var core = core$1.exports;
      var hasRequiredCore;
      function requireCore() {
        if (hasRequiredCore) return core$1.exports;
        hasRequiredCore = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory();
            }
          })(core, function() {
            var CryptoJS = CryptoJS || function(Math2, undefined$1) {
              var crypto;
              if (typeof window !== "undefined" && window.crypto) {
                crypto = window.crypto;
              }
              if (typeof self !== "undefined" && self.crypto) {
                crypto = self.crypto;
              }
              if (typeof globalThis !== "undefined" && globalThis.crypto) {
                crypto = globalThis.crypto;
              }
              if (!crypto && typeof window !== "undefined" && window.msCrypto) {
                crypto = window.msCrypto;
              }
              if (!crypto && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
                crypto = commonjsGlobal.crypto;
              }
              if (!crypto && typeof commonjsRequire === "function") {
                try {
                  crypto = require_crypto();
                } catch (err) {
                }
              }
              var cryptoSecureRandomInt = function() {
                if (crypto) {
                  if (typeof crypto.getRandomValues === "function") {
                    try {
                      return crypto.getRandomValues(new Uint32Array(1))[0];
                    } catch (err) {
                    }
                  }
                  if (typeof crypto.randomBytes === "function") {
                    try {
                      return crypto.randomBytes(4).readInt32LE();
                    } catch (err) {
                    }
                  }
                }
                throw new Error("Native crypto module could not be used to get secure random number.");
              };
              var create = Object.create || /* @__PURE__ */ function() {
                function F() {
                }
                return function(obj) {
                  var subtype;
                  F.prototype = obj;
                  subtype = new F();
                  F.prototype = null;
                  return subtype;
                };
              }();
              var C = {};
              var C_lib = C.lib = {};
              var Base = C_lib.Base = /* @__PURE__ */ function() {
                return {
                  /**
                   * Creates a new object that inherits from this object.
                   *
                   * @param {Object} overrides Properties to copy into the new object.
                   *
                   * @return {Object} The new object.
                   *
                   * @static
                   *
                   * @example
                   *
                   *     var MyType = CryptoJS.lib.Base.extend({
                   *         field: 'value',
                   *
                   *         method: function () {
                   *         }
                   *     });
                   */
                  extend: function(overrides) {
                    var subtype = create(this);
                    if (overrides) {
                      subtype.mixIn(overrides);
                    }
                    if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                      subtype.init = function() {
                        subtype.$super.init.apply(this, arguments);
                      };
                    }
                    subtype.init.prototype = subtype;
                    subtype.$super = this;
                    return subtype;
                  },
                  /**
                   * Extends this object and runs the init method.
                   * Arguments to create() will be passed to init().
                   *
                   * @return {Object} The new object.
                   *
                   * @static
                   *
                   * @example
                   *
                   *     var instance = MyType.create();
                   */
                  create: function() {
                    var instance = this.extend();
                    instance.init.apply(instance, arguments);
                    return instance;
                  },
                  /**
                   * Initializes a newly created object.
                   * Override this method to add some logic when your objects are created.
                   *
                   * @example
                   *
                   *     var MyType = CryptoJS.lib.Base.extend({
                   *         init: function () {
                   *             // ...
                   *         }
                   *     });
                   */
                  init: function() {
                  },
                  /**
                   * Copies properties into this object.
                   *
                   * @param {Object} properties The properties to mix in.
                   *
                   * @example
                   *
                   *     MyType.mixIn({
                   *         field: 'value'
                   *     });
                   */
                  mixIn: function(properties) {
                    for (var propertyName in properties) {
                      if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                      }
                    }
                    if (properties.hasOwnProperty("toString")) {
                      this.toString = properties.toString;
                    }
                  },
                  /**
                   * Creates a copy of this object.
                   *
                   * @return {Object} The clone.
                   *
                   * @example
                   *
                   *     var clone = instance.clone();
                   */
                  clone: function() {
                    return this.init.prototype.extend(this);
                  }
                };
              }();
              var WordArray = C_lib.WordArray = Base.extend({
                /**
                 * Initializes a newly created word array.
                 *
                 * @param {Array} words (Optional) An array of 32-bit words.
                 * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.create();
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
                 */
                init: function(words, sigBytes) {
                  words = this.words = words || [];
                  if (sigBytes != undefined$1) {
                    this.sigBytes = sigBytes;
                  } else {
                    this.sigBytes = words.length * 4;
                  }
                },
                /**
                 * Converts this word array to a string.
                 *
                 * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
                 *
                 * @return {string} The stringified word array.
                 *
                 * @example
                 *
                 *     var string = wordArray + '';
                 *     var string = wordArray.toString();
                 *     var string = wordArray.toString(CryptoJS.enc.Utf8);
                 */
                toString: function(encoder) {
                  return (encoder || Hex).stringify(this);
                },
                /**
                 * Concatenates a word array to this word array.
                 *
                 * @param {WordArray} wordArray The word array to append.
                 *
                 * @return {WordArray} This word array.
                 *
                 * @example
                 *
                 *     wordArray1.concat(wordArray2);
                 */
                concat: function(wordArray) {
                  var thisWords = this.words;
                  var thatWords = wordArray.words;
                  var thisSigBytes = this.sigBytes;
                  var thatSigBytes = wordArray.sigBytes;
                  this.clamp();
                  if (thisSigBytes % 4) {
                    for (var i = 0; i < thatSigBytes; i++) {
                      var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                      thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                    }
                  } else {
                    for (var j = 0; j < thatSigBytes; j += 4) {
                      thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
                    }
                  }
                  this.sigBytes += thatSigBytes;
                  return this;
                },
                /**
                 * Removes insignificant bits.
                 *
                 * @example
                 *
                 *     wordArray.clamp();
                 */
                clamp: function() {
                  var words = this.words;
                  var sigBytes = this.sigBytes;
                  words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
                  words.length = Math2.ceil(sigBytes / 4);
                },
                /**
                 * Creates a copy of this word array.
                 *
                 * @return {WordArray} The clone.
                 *
                 * @example
                 *
                 *     var clone = wordArray.clone();
                 */
                clone: function() {
                  var clone = Base.clone.call(this);
                  clone.words = this.words.slice(0);
                  return clone;
                },
                /**
                 * Creates a word array filled with random bytes.
                 *
                 * @param {number} nBytes The number of random bytes to generate.
                 *
                 * @return {WordArray} The random word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.random(16);
                 */
                random: function(nBytes) {
                  var words = [];
                  for (var i = 0; i < nBytes; i += 4) {
                    words.push(cryptoSecureRandomInt());
                  }
                  return new WordArray.init(words, nBytes);
                }
              });
              var C_enc = C.enc = {};
              var Hex = C_enc.Hex = {
                /**
                 * Converts a word array to a hex string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The hex string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
                 */
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var hexChars = [];
                  for (var i = 0; i < sigBytes; i++) {
                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    hexChars.push((bite >>> 4).toString(16));
                    hexChars.push((bite & 15).toString(16));
                  }
                  return hexChars.join("");
                },
                /**
                 * Converts a hex string to a word array.
                 *
                 * @param {string} hexStr The hex string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
                 */
                parse: function(hexStr) {
                  var hexStrLength = hexStr.length;
                  var words = [];
                  for (var i = 0; i < hexStrLength; i += 2) {
                    words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                  }
                  return new WordArray.init(words, hexStrLength / 2);
                }
              };
              var Latin1 = C_enc.Latin1 = {
                /**
                 * Converts a word array to a Latin1 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The Latin1 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
                 */
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var latin1Chars = [];
                  for (var i = 0; i < sigBytes; i++) {
                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    latin1Chars.push(String.fromCharCode(bite));
                  }
                  return latin1Chars.join("");
                },
                /**
                 * Converts a Latin1 string to a word array.
                 *
                 * @param {string} latin1Str The Latin1 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
                 */
                parse: function(latin1Str) {
                  var latin1StrLength = latin1Str.length;
                  var words = [];
                  for (var i = 0; i < latin1StrLength; i++) {
                    words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
                  }
                  return new WordArray.init(words, latin1StrLength);
                }
              };
              var Utf8 = C_enc.Utf8 = {
                /**
                 * Converts a word array to a UTF-8 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The UTF-8 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
                 */
                stringify: function(wordArray) {
                  try {
                    return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                  } catch (e) {
                    throw new Error("Malformed UTF-8 data");
                  }
                },
                /**
                 * Converts a UTF-8 string to a word array.
                 *
                 * @param {string} utf8Str The UTF-8 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
                 */
                parse: function(utf8Str) {
                  return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                }
              };
              var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                /**
                 * Resets this block algorithm's data buffer to its initial state.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm.reset();
                 */
                reset: function() {
                  this._data = new WordArray.init();
                  this._nDataBytes = 0;
                },
                /**
                 * Adds new data to this block algorithm's buffer.
                 *
                 * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm._append('data');
                 *     bufferedBlockAlgorithm._append(wordArray);
                 */
                _append: function(data) {
                  if (typeof data == "string") {
                    data = Utf8.parse(data);
                  }
                  this._data.concat(data);
                  this._nDataBytes += data.sigBytes;
                },
                /**
                 * Processes available data blocks.
                 *
                 * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
                 *
                 * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
                 *
                 * @return {WordArray} The processed data.
                 *
                 * @example
                 *
                 *     var processedData = bufferedBlockAlgorithm._process();
                 *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
                 */
                _process: function(doFlush) {
                  var processedWords;
                  var data = this._data;
                  var dataWords = data.words;
                  var dataSigBytes = data.sigBytes;
                  var blockSize = this.blockSize;
                  var blockSizeBytes = blockSize * 4;
                  var nBlocksReady = dataSigBytes / blockSizeBytes;
                  if (doFlush) {
                    nBlocksReady = Math2.ceil(nBlocksReady);
                  } else {
                    nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
                  }
                  var nWordsReady = nBlocksReady * blockSize;
                  var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
                  if (nWordsReady) {
                    for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                      this._doProcessBlock(dataWords, offset);
                    }
                    processedWords = dataWords.splice(0, nWordsReady);
                    data.sigBytes -= nBytesReady;
                  }
                  return new WordArray.init(processedWords, nBytesReady);
                },
                /**
                 * Creates a copy of this object.
                 *
                 * @return {Object} The clone.
                 *
                 * @example
                 *
                 *     var clone = bufferedBlockAlgorithm.clone();
                 */
                clone: function() {
                  var clone = Base.clone.call(this);
                  clone._data = this._data.clone();
                  return clone;
                },
                _minBufferSize: 0
              });
              C_lib.Hasher = BufferedBlockAlgorithm.extend({
                /**
                 * Configuration options.
                 */
                cfg: Base.extend(),
                /**
                 * Initializes a newly created hasher.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
                 *
                 * @example
                 *
                 *     var hasher = CryptoJS.algo.SHA256.create();
                 */
                init: function(cfg) {
                  this.cfg = this.cfg.extend(cfg);
                  this.reset();
                },
                /**
                 * Resets this hasher to its initial state.
                 *
                 * @example
                 *
                 *     hasher.reset();
                 */
                reset: function() {
                  BufferedBlockAlgorithm.reset.call(this);
                  this._doReset();
                },
                /**
                 * Updates this hasher with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {Hasher} This hasher.
                 *
                 * @example
                 *
                 *     hasher.update('message');
                 *     hasher.update(wordArray);
                 */
                update: function(messageUpdate) {
                  this._append(messageUpdate);
                  this._process();
                  return this;
                },
                /**
                 * Finalizes the hash computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The hash.
                 *
                 * @example
                 *
                 *     var hash = hasher.finalize();
                 *     var hash = hasher.finalize('message');
                 *     var hash = hasher.finalize(wordArray);
                 */
                finalize: function(messageUpdate) {
                  if (messageUpdate) {
                    this._append(messageUpdate);
                  }
                  var hash = this._doFinalize();
                  return hash;
                },
                blockSize: 512 / 32,
                /**
                 * Creates a shortcut function to a hasher's object interface.
                 *
                 * @param {Hasher} hasher The hasher to create a helper for.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
                 */
                _createHelper: function(hasher) {
                  return function(message, cfg) {
                    return new hasher.init(cfg).finalize(message);
                  };
                },
                /**
                 * Creates a shortcut function to the HMAC's object interface.
                 *
                 * @param {Hasher} hasher The hasher to use in this HMAC helper.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
                 */
                _createHmacHelper: function(hasher) {
                  return function(message, key) {
                    return new C_algo.HMAC.init(hasher, key).finalize(message);
                  };
                }
              });
              var C_algo = C.algo = {};
              return C;
            }(Math);
            return CryptoJS;
          });
        })(core$1, core$1.exports);
        return core$1.exports;
      }
      var x64Core$1 = { exports: {} };
      var x64Core = x64Core$1.exports;
      var hasRequiredX64Core;
      function requireX64Core() {
        if (hasRequiredX64Core) return x64Core$1.exports;
        hasRequiredX64Core = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(x64Core, function(CryptoJS) {
            (function(undefined$1) {
              var C = CryptoJS;
              var C_lib = C.lib;
              var Base = C_lib.Base;
              var X32WordArray = C_lib.WordArray;
              var C_x64 = C.x64 = {};
              C_x64.Word = Base.extend({
                /**
                 * Initializes a newly created 64-bit word.
                 *
                 * @param {number} high The high 32 bits.
                 * @param {number} low The low 32 bits.
                 *
                 * @example
                 *
                 *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
                 */
                init: function(high, low) {
                  this.high = high;
                  this.low = low;
                }
                /**
                 * Bitwise NOTs this word.
                 *
                 * @return {X64Word} A new x64-Word object after negating.
                 *
                 * @example
                 *
                 *     var negated = x64Word.not();
                 */
                // not: function () {
                // var high = ~this.high;
                // var low = ~this.low;
                // return X64Word.create(high, low);
                // },
                /**
                 * Bitwise ANDs this word with the passed word.
                 *
                 * @param {X64Word} word The x64-Word to AND with this word.
                 *
                 * @return {X64Word} A new x64-Word object after ANDing.
                 *
                 * @example
                 *
                 *     var anded = x64Word.and(anotherX64Word);
                 */
                // and: function (word) {
                // var high = this.high & word.high;
                // var low = this.low & word.low;
                // return X64Word.create(high, low);
                // },
                /**
                 * Bitwise ORs this word with the passed word.
                 *
                 * @param {X64Word} word The x64-Word to OR with this word.
                 *
                 * @return {X64Word} A new x64-Word object after ORing.
                 *
                 * @example
                 *
                 *     var ored = x64Word.or(anotherX64Word);
                 */
                // or: function (word) {
                // var high = this.high | word.high;
                // var low = this.low | word.low;
                // return X64Word.create(high, low);
                // },
                /**
                 * Bitwise XORs this word with the passed word.
                 *
                 * @param {X64Word} word The x64-Word to XOR with this word.
                 *
                 * @return {X64Word} A new x64-Word object after XORing.
                 *
                 * @example
                 *
                 *     var xored = x64Word.xor(anotherX64Word);
                 */
                // xor: function (word) {
                // var high = this.high ^ word.high;
                // var low = this.low ^ word.low;
                // return X64Word.create(high, low);
                // },
                /**
                 * Shifts this word n bits to the left.
                 *
                 * @param {number} n The number of bits to shift.
                 *
                 * @return {X64Word} A new x64-Word object after shifting.
                 *
                 * @example
                 *
                 *     var shifted = x64Word.shiftL(25);
                 */
                // shiftL: function (n) {
                // if (n < 32) {
                // var high = (this.high << n) | (this.low >>> (32 - n));
                // var low = this.low << n;
                // } else {
                // var high = this.low << (n - 32);
                // var low = 0;
                // }
                // return X64Word.create(high, low);
                // },
                /**
                 * Shifts this word n bits to the right.
                 *
                 * @param {number} n The number of bits to shift.
                 *
                 * @return {X64Word} A new x64-Word object after shifting.
                 *
                 * @example
                 *
                 *     var shifted = x64Word.shiftR(7);
                 */
                // shiftR: function (n) {
                // if (n < 32) {
                // var low = (this.low >>> n) | (this.high << (32 - n));
                // var high = this.high >>> n;
                // } else {
                // var low = this.high >>> (n - 32);
                // var high = 0;
                // }
                // return X64Word.create(high, low);
                // },
                /**
                 * Rotates this word n bits to the left.
                 *
                 * @param {number} n The number of bits to rotate.
                 *
                 * @return {X64Word} A new x64-Word object after rotating.
                 *
                 * @example
                 *
                 *     var rotated = x64Word.rotL(25);
                 */
                // rotL: function (n) {
                // return this.shiftL(n).or(this.shiftR(64 - n));
                // },
                /**
                 * Rotates this word n bits to the right.
                 *
                 * @param {number} n The number of bits to rotate.
                 *
                 * @return {X64Word} A new x64-Word object after rotating.
                 *
                 * @example
                 *
                 *     var rotated = x64Word.rotR(7);
                 */
                // rotR: function (n) {
                // return this.shiftR(n).or(this.shiftL(64 - n));
                // },
                /**
                 * Adds this word with the passed word.
                 *
                 * @param {X64Word} word The x64-Word to add with this word.
                 *
                 * @return {X64Word} A new x64-Word object after adding.
                 *
                 * @example
                 *
                 *     var added = x64Word.add(anotherX64Word);
                 */
                // add: function (word) {
                // var low = (this.low + word.low) | 0;
                // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
                // var high = (this.high + word.high + carry) | 0;
                // return X64Word.create(high, low);
                // }
              });
              C_x64.WordArray = Base.extend({
                /**
                 * Initializes a newly created word array.
                 *
                 * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
                 * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.x64.WordArray.create();
                 *
                 *     var wordArray = CryptoJS.x64.WordArray.create([
                 *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
                 *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
                 *     ]);
                 *
                 *     var wordArray = CryptoJS.x64.WordArray.create([
                 *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
                 *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
                 *     ], 10);
                 */
                init: function(words, sigBytes) {
                  words = this.words = words || [];
                  if (sigBytes != undefined$1) {
                    this.sigBytes = sigBytes;
                  } else {
                    this.sigBytes = words.length * 8;
                  }
                },
                /**
                 * Converts this 64-bit word array to a 32-bit word array.
                 *
                 * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
                 *
                 * @example
                 *
                 *     var x32WordArray = x64WordArray.toX32();
                 */
                toX32: function() {
                  var x64Words = this.words;
                  var x64WordsLength = x64Words.length;
                  var x32Words = [];
                  for (var i = 0; i < x64WordsLength; i++) {
                    var x64Word = x64Words[i];
                    x32Words.push(x64Word.high);
                    x32Words.push(x64Word.low);
                  }
                  return X32WordArray.create(x32Words, this.sigBytes);
                },
                /**
                 * Creates a copy of this word array.
                 *
                 * @return {X64WordArray} The clone.
                 *
                 * @example
                 *
                 *     var clone = x64WordArray.clone();
                 */
                clone: function() {
                  var clone = Base.clone.call(this);
                  var words = clone.words = this.words.slice(0);
                  var wordsLength = words.length;
                  for (var i = 0; i < wordsLength; i++) {
                    words[i] = words[i].clone();
                  }
                  return clone;
                }
              });
            })();
            return CryptoJS;
          });
        })(x64Core$1, x64Core$1.exports);
        return x64Core$1.exports;
      }
      var libTypedarrays$1 = { exports: {} };
      var libTypedarrays = libTypedarrays$1.exports;
      var hasRequiredLibTypedarrays;
      function requireLibTypedarrays() {
        if (hasRequiredLibTypedarrays) return libTypedarrays$1.exports;
        hasRequiredLibTypedarrays = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(libTypedarrays, function(CryptoJS) {
            (function() {
              if (typeof ArrayBuffer != "function") {
                return;
              }
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var superInit = WordArray.init;
              var subInit = WordArray.init = function(typedArray) {
                if (typedArray instanceof ArrayBuffer) {
                  typedArray = new Uint8Array(typedArray);
                }
                if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
                  typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
                }
                if (typedArray instanceof Uint8Array) {
                  var typedArrayByteLength = typedArray.byteLength;
                  var words = [];
                  for (var i = 0; i < typedArrayByteLength; i++) {
                    words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
                  }
                  superInit.call(this, words, typedArrayByteLength);
                } else {
                  superInit.apply(this, arguments);
                }
              };
              subInit.prototype = WordArray;
            })();
            return CryptoJS.lib.WordArray;
          });
        })(libTypedarrays$1, libTypedarrays$1.exports);
        return libTypedarrays$1.exports;
      }
      var encUtf16$1 = { exports: {} };
      var encUtf16 = encUtf16$1.exports;
      var hasRequiredEncUtf16;
      function requireEncUtf16() {
        if (hasRequiredEncUtf16) return encUtf16$1.exports;
        hasRequiredEncUtf16 = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(encUtf16, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var C_enc = C.enc;
              C_enc.Utf16 = C_enc.Utf16BE = {
                /**
                 * Converts a word array to a UTF-16 BE string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The UTF-16 BE string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
                 */
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var utf16Chars = [];
                  for (var i = 0; i < sigBytes; i += 2) {
                    var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
                    utf16Chars.push(String.fromCharCode(codePoint));
                  }
                  return utf16Chars.join("");
                },
                /**
                 * Converts a UTF-16 BE string to a word array.
                 *
                 * @param {string} utf16Str The UTF-16 BE string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
                 */
                parse: function(utf16Str) {
                  var utf16StrLength = utf16Str.length;
                  var words = [];
                  for (var i = 0; i < utf16StrLength; i++) {
                    words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
                  }
                  return WordArray.create(words, utf16StrLength * 2);
                }
              };
              C_enc.Utf16LE = {
                /**
                 * Converts a word array to a UTF-16 LE string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The UTF-16 LE string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
                 */
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var utf16Chars = [];
                  for (var i = 0; i < sigBytes; i += 2) {
                    var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
                    utf16Chars.push(String.fromCharCode(codePoint));
                  }
                  return utf16Chars.join("");
                },
                /**
                 * Converts a UTF-16 LE string to a word array.
                 *
                 * @param {string} utf16Str The UTF-16 LE string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
                 */
                parse: function(utf16Str) {
                  var utf16StrLength = utf16Str.length;
                  var words = [];
                  for (var i = 0; i < utf16StrLength; i++) {
                    words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
                  }
                  return WordArray.create(words, utf16StrLength * 2);
                }
              };
              function swapEndian(word) {
                return word << 8 & 4278255360 | word >>> 8 & 16711935;
              }
            })();
            return CryptoJS.enc.Utf16;
          });
        })(encUtf16$1, encUtf16$1.exports);
        return encUtf16$1.exports;
      }
      var encBase64$1 = { exports: {} };
      var encBase64 = encBase64$1.exports;
      var hasRequiredEncBase64;
      function requireEncBase64() {
        if (hasRequiredEncBase64) return encBase64$1.exports;
        hasRequiredEncBase64 = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(encBase64, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var C_enc = C.enc;
              C_enc.Base64 = {
                /**
                 * Converts a word array to a Base64 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The Base64 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
                 */
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var map = this._map;
                  wordArray.clamp();
                  var base64Chars = [];
                  for (var i = 0; i < sigBytes; i += 3) {
                    var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                    var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                    var triplet = byte1 << 16 | byte2 << 8 | byte3;
                    for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                      base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                    }
                  }
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                    while (base64Chars.length % 4) {
                      base64Chars.push(paddingChar);
                    }
                  }
                  return base64Chars.join("");
                },
                /**
                 * Converts a Base64 string to a word array.
                 *
                 * @param {string} base64Str The Base64 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
                 */
                parse: function(base64Str) {
                  var base64StrLength = base64Str.length;
                  var map = this._map;
                  var reverseMap = this._reverseMap;
                  if (!reverseMap) {
                    reverseMap = this._reverseMap = [];
                    for (var j = 0; j < map.length; j++) {
                      reverseMap[map.charCodeAt(j)] = j;
                    }
                  }
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                    var paddingIndex = base64Str.indexOf(paddingChar);
                    if (paddingIndex !== -1) {
                      base64StrLength = paddingIndex;
                    }
                  }
                  return parseLoop(base64Str, base64StrLength, reverseMap);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
              };
              function parseLoop(base64Str, base64StrLength, reverseMap) {
                var words = [];
                var nBytes = 0;
                for (var i = 0; i < base64StrLength; i++) {
                  if (i % 4) {
                    var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                    var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                    var bitsCombined = bits1 | bits2;
                    words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                    nBytes++;
                  }
                }
                return WordArray.create(words, nBytes);
              }
            })();
            return CryptoJS.enc.Base64;
          });
        })(encBase64$1, encBase64$1.exports);
        return encBase64$1.exports;
      }
      var encBase64url$1 = { exports: {} };
      var encBase64url = encBase64url$1.exports;
      var hasRequiredEncBase64url;
      function requireEncBase64url() {
        if (hasRequiredEncBase64url) return encBase64url$1.exports;
        hasRequiredEncBase64url = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(encBase64url, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var C_enc = C.enc;
              C_enc.Base64url = {
                /**
                 * Converts a word array to a Base64url string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @param {boolean} urlSafe Whether to use url safe
                 *
                 * @return {string} The Base64url string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
                 */
                stringify: function(wordArray, urlSafe) {
                  if (urlSafe === void 0) {
                    urlSafe = true;
                  }
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var map = urlSafe ? this._safe_map : this._map;
                  wordArray.clamp();
                  var base64Chars = [];
                  for (var i = 0; i < sigBytes; i += 3) {
                    var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                    var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                    var triplet = byte1 << 16 | byte2 << 8 | byte3;
                    for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                      base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                    }
                  }
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                    while (base64Chars.length % 4) {
                      base64Chars.push(paddingChar);
                    }
                  }
                  return base64Chars.join("");
                },
                /**
                 * Converts a Base64url string to a word array.
                 *
                 * @param {string} base64Str The Base64url string.
                 *
                 * @param {boolean} urlSafe Whether to use url safe
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
                 */
                parse: function(base64Str, urlSafe) {
                  if (urlSafe === void 0) {
                    urlSafe = true;
                  }
                  var base64StrLength = base64Str.length;
                  var map = urlSafe ? this._safe_map : this._map;
                  var reverseMap = this._reverseMap;
                  if (!reverseMap) {
                    reverseMap = this._reverseMap = [];
                    for (var j = 0; j < map.length; j++) {
                      reverseMap[map.charCodeAt(j)] = j;
                    }
                  }
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                    var paddingIndex = base64Str.indexOf(paddingChar);
                    if (paddingIndex !== -1) {
                      base64StrLength = paddingIndex;
                    }
                  }
                  return parseLoop(base64Str, base64StrLength, reverseMap);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
              };
              function parseLoop(base64Str, base64StrLength, reverseMap) {
                var words = [];
                var nBytes = 0;
                for (var i = 0; i < base64StrLength; i++) {
                  if (i % 4) {
                    var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                    var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                    var bitsCombined = bits1 | bits2;
                    words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                    nBytes++;
                  }
                }
                return WordArray.create(words, nBytes);
              }
            })();
            return CryptoJS.enc.Base64url;
          });
        })(encBase64url$1, encBase64url$1.exports);
        return encBase64url$1.exports;
      }
      var md5$1 = { exports: {} };
      var md5 = md5$1.exports;
      var hasRequiredMd5;
      function requireMd5() {
        if (hasRequiredMd5) return md5$1.exports;
        hasRequiredMd5 = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(md5, function(CryptoJS) {
            (function(Math2) {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var Hasher = C_lib.Hasher;
              var C_algo = C.algo;
              var T = [];
              (function() {
                for (var i = 0; i < 64; i++) {
                  T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
                }
              })();
              var MD5 = C_algo.MD5 = Hasher.extend({
                _doReset: function() {
                  this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878]);
                },
                _doProcessBlock: function(M, offset) {
                  for (var i = 0; i < 16; i++) {
                    var offset_i = offset + i;
                    var M_offset_i = M[offset_i];
                    M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                  }
                  var H = this._hash.words;
                  var M_offset_0 = M[offset + 0];
                  var M_offset_1 = M[offset + 1];
                  var M_offset_2 = M[offset + 2];
                  var M_offset_3 = M[offset + 3];
                  var M_offset_4 = M[offset + 4];
                  var M_offset_5 = M[offset + 5];
                  var M_offset_6 = M[offset + 6];
                  var M_offset_7 = M[offset + 7];
                  var M_offset_8 = M[offset + 8];
                  var M_offset_9 = M[offset + 9];
                  var M_offset_10 = M[offset + 10];
                  var M_offset_11 = M[offset + 11];
                  var M_offset_12 = M[offset + 12];
                  var M_offset_13 = M[offset + 13];
                  var M_offset_14 = M[offset + 14];
                  var M_offset_15 = M[offset + 15];
                  var a = H[0];
                  var b = H[1];
                  var c = H[2];
                  var d = H[3];
                  a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                  d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                  c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                  b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                  a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                  d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                  c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                  b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                  a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                  d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                  c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                  b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                  a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                  d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                  c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                  b = FF(b, c, d, a, M_offset_15, 22, T[15]);
                  a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                  d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                  c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                  b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                  a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                  d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                  c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                  b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                  a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                  d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                  c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                  b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                  a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                  d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                  c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                  b = GG(b, c, d, a, M_offset_12, 20, T[31]);
                  a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                  d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                  c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                  b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                  a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                  d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                  c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                  b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                  a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                  d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                  c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                  b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                  a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                  d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                  c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                  b = HH(b, c, d, a, M_offset_2, 23, T[47]);
                  a = II(a, b, c, d, M_offset_0, 6, T[48]);
                  d = II(d, a, b, c, M_offset_7, 10, T[49]);
                  c = II(c, d, a, b, M_offset_14, 15, T[50]);
                  b = II(b, c, d, a, M_offset_5, 21, T[51]);
                  a = II(a, b, c, d, M_offset_12, 6, T[52]);
                  d = II(d, a, b, c, M_offset_3, 10, T[53]);
                  c = II(c, d, a, b, M_offset_10, 15, T[54]);
                  b = II(b, c, d, a, M_offset_1, 21, T[55]);
                  a = II(a, b, c, d, M_offset_8, 6, T[56]);
                  d = II(d, a, b, c, M_offset_15, 10, T[57]);
                  c = II(c, d, a, b, M_offset_6, 15, T[58]);
                  b = II(b, c, d, a, M_offset_13, 21, T[59]);
                  a = II(a, b, c, d, M_offset_4, 6, T[60]);
                  d = II(d, a, b, c, M_offset_11, 10, T[61]);
                  c = II(c, d, a, b, M_offset_2, 15, T[62]);
                  b = II(b, c, d, a, M_offset_9, 21, T[63]);
                  H[0] = H[0] + a | 0;
                  H[1] = H[1] + b | 0;
                  H[2] = H[2] + c | 0;
                  H[3] = H[3] + d | 0;
                },
                _doFinalize: function() {
                  var data = this._data;
                  var dataWords = data.words;
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
                  dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                  var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
                  var nBitsTotalL = nBitsTotal;
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
                  data.sigBytes = (dataWords.length + 1) * 4;
                  this._process();
                  var hash = this._hash;
                  var H = hash.words;
                  for (var i = 0; i < 4; i++) {
                    var H_i = H[i];
                    H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                  }
                  return hash;
                },
                clone: function() {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
                  return clone;
                }
              });
              function FF(a, b, c, d, x, s, t) {
                var n = a + (b & c | ~b & d) + x + t;
                return (n << s | n >>> 32 - s) + b;
              }
              function GG(a, b, c, d, x, s, t) {
                var n = a + (b & d | c & ~d) + x + t;
                return (n << s | n >>> 32 - s) + b;
              }
              function HH(a, b, c, d, x, s, t) {
                var n = a + (b ^ c ^ d) + x + t;
                return (n << s | n >>> 32 - s) + b;
              }
              function II(a, b, c, d, x, s, t) {
                var n = a + (c ^ (b | ~d)) + x + t;
                return (n << s | n >>> 32 - s) + b;
              }
              C.MD5 = Hasher._createHelper(MD5);
              C.HmacMD5 = Hasher._createHmacHelper(MD5);
            })(Math);
            return CryptoJS.MD5;
          });
        })(md5$1, md5$1.exports);
        return md5$1.exports;
      }
      var sha1$1 = { exports: {} };
      var sha1 = sha1$1.exports;
      var hasRequiredSha1;
      function requireSha1() {
        if (hasRequiredSha1) return sha1$1.exports;
        hasRequiredSha1 = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(sha1, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var Hasher = C_lib.Hasher;
              var C_algo = C.algo;
              var W = [];
              var SHA1 = C_algo.SHA1 = Hasher.extend({
                _doReset: function() {
                  this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                },
                _doProcessBlock: function(M, offset) {
                  var H = this._hash.words;
                  var a = H[0];
                  var b = H[1];
                  var c = H[2];
                  var d = H[3];
                  var e = H[4];
                  for (var i = 0; i < 80; i++) {
                    if (i < 16) {
                      W[i] = M[offset + i] | 0;
                    } else {
                      var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                      W[i] = n << 1 | n >>> 31;
                    }
                    var t = (a << 5 | a >>> 27) + e + W[i];
                    if (i < 20) {
                      t += (b & c | ~b & d) + 1518500249;
                    } else if (i < 40) {
                      t += (b ^ c ^ d) + 1859775393;
                    } else if (i < 60) {
                      t += (b & c | b & d | c & d) - 1894007588;
                    } else {
                      t += (b ^ c ^ d) - 899497514;
                    }
                    e = d;
                    d = c;
                    c = b << 30 | b >>> 2;
                    b = a;
                    a = t;
                  }
                  H[0] = H[0] + a | 0;
                  H[1] = H[1] + b | 0;
                  H[2] = H[2] + c | 0;
                  H[3] = H[3] + d | 0;
                  H[4] = H[4] + e | 0;
                },
                _doFinalize: function() {
                  var data = this._data;
                  var dataWords = data.words;
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
                  dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                  data.sigBytes = dataWords.length * 4;
                  this._process();
                  return this._hash;
                },
                clone: function() {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
                  return clone;
                }
              });
              C.SHA1 = Hasher._createHelper(SHA1);
              C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
            })();
            return CryptoJS.SHA1;
          });
        })(sha1$1, sha1$1.exports);
        return sha1$1.exports;
      }
      var sha256$1 = { exports: {} };
      var sha256 = sha256$1.exports;
      var hasRequiredSha256;
      function requireSha256() {
        if (hasRequiredSha256) return sha256$1.exports;
        hasRequiredSha256 = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(sha256, function(CryptoJS) {
            (function(Math2) {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var Hasher = C_lib.Hasher;
              var C_algo = C.algo;
              var H = [];
              var K = [];
              (function() {
                function isPrime(n2) {
                  var sqrtN = Math2.sqrt(n2);
                  for (var factor = 2; factor <= sqrtN; factor++) {
                    if (!(n2 % factor)) {
                      return false;
                    }
                  }
                  return true;
                }
                function getFractionalBits(n2) {
                  return (n2 - (n2 | 0)) * 4294967296 | 0;
                }
                var n = 2;
                var nPrime = 0;
                while (nPrime < 64) {
                  if (isPrime(n)) {
                    if (nPrime < 8) {
                      H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
                    }
                    K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
                    nPrime++;
                  }
                  n++;
                }
              })();
              var W = [];
              var SHA256 = C_algo.SHA256 = Hasher.extend({
                _doReset: function() {
                  this._hash = new WordArray.init(H.slice(0));
                },
                _doProcessBlock: function(M, offset) {
                  var H2 = this._hash.words;
                  var a = H2[0];
                  var b = H2[1];
                  var c = H2[2];
                  var d = H2[3];
                  var e = H2[4];
                  var f = H2[5];
                  var g = H2[6];
                  var h = H2[7];
                  for (var i = 0; i < 64; i++) {
                    if (i < 16) {
                      W[i] = M[offset + i] | 0;
                    } else {
                      var gamma0x = W[i - 15];
                      var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                      var gamma1x = W[i - 2];
                      var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                      W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                    }
                    var ch = e & f ^ ~e & g;
                    var maj = a & b ^ a & c ^ b & c;
                    var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
                    var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
                    var t1 = h + sigma1 + ch + K[i] + W[i];
                    var t2 = sigma0 + maj;
                    h = g;
                    g = f;
                    f = e;
                    e = d + t1 | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = t1 + t2 | 0;
                  }
                  H2[0] = H2[0] + a | 0;
                  H2[1] = H2[1] + b | 0;
                  H2[2] = H2[2] + c | 0;
                  H2[3] = H2[3] + d | 0;
                  H2[4] = H2[4] + e | 0;
                  H2[5] = H2[5] + f | 0;
                  H2[6] = H2[6] + g | 0;
                  H2[7] = H2[7] + h | 0;
                },
                _doFinalize: function() {
                  var data = this._data;
                  var dataWords = data.words;
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
                  dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                  data.sigBytes = dataWords.length * 4;
                  this._process();
                  return this._hash;
                },
                clone: function() {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
                  return clone;
                }
              });
              C.SHA256 = Hasher._createHelper(SHA256);
              C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
            })(Math);
            return CryptoJS.SHA256;
          });
        })(sha256$1, sha256$1.exports);
        return sha256$1.exports;
      }
      var sha224$1 = { exports: {} };
      var sha224 = sha224$1.exports;
      var hasRequiredSha224;
      function requireSha224() {
        if (hasRequiredSha224) return sha224$1.exports;
        hasRequiredSha224 = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireSha256());
            }
          })(sha224, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var C_algo = C.algo;
              var SHA256 = C_algo.SHA256;
              var SHA224 = C_algo.SHA224 = SHA256.extend({
                _doReset: function() {
                  this._hash = new WordArray.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
                },
                _doFinalize: function() {
                  var hash = SHA256._doFinalize.call(this);
                  hash.sigBytes -= 4;
                  return hash;
                }
              });
              C.SHA224 = SHA256._createHelper(SHA224);
              C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
            })();
            return CryptoJS.SHA224;
          });
        })(sha224$1, sha224$1.exports);
        return sha224$1.exports;
      }
      var sha512$1 = { exports: {} };
      var sha512 = sha512$1.exports;
      var hasRequiredSha512;
      function requireSha512() {
        if (hasRequiredSha512) return sha512$1.exports;
        hasRequiredSha512 = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireX64Core());
            }
          })(sha512, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var Hasher = C_lib.Hasher;
              var C_x64 = C.x64;
              var X64Word = C_x64.Word;
              var X64WordArray = C_x64.WordArray;
              var C_algo = C.algo;
              function X64Word_create() {
                return X64Word.create.apply(X64Word, arguments);
              }
              var K = [X64Word_create(1116352408, 3609767458), X64Word_create(1899447441, 602891725), X64Word_create(3049323471, 3964484399), X64Word_create(3921009573, 2173295548), X64Word_create(961987163, 4081628472), X64Word_create(1508970993, 3053834265), X64Word_create(2453635748, 2937671579), X64Word_create(2870763221, 3664609560), X64Word_create(3624381080, 2734883394), X64Word_create(310598401, 1164996542), X64Word_create(607225278, 1323610764), X64Word_create(1426881987, 3590304994), X64Word_create(1925078388, 4068182383), X64Word_create(2162078206, 991336113), X64Word_create(2614888103, 633803317), X64Word_create(3248222580, 3479774868), X64Word_create(3835390401, 2666613458), X64Word_create(4022224774, 944711139), X64Word_create(264347078, 2341262773), X64Word_create(604807628, 2007800933), X64Word_create(770255983, 1495990901), X64Word_create(1249150122, 1856431235), X64Word_create(1555081692, 3175218132), X64Word_create(1996064986, 2198950837), X64Word_create(2554220882, 3999719339), X64Word_create(2821834349, 766784016), X64Word_create(2952996808, 2566594879), X64Word_create(3210313671, 3203337956), X64Word_create(3336571891, 1034457026), X64Word_create(3584528711, 2466948901), X64Word_create(113926993, 3758326383), X64Word_create(338241895, 168717936), X64Word_create(666307205, 1188179964), X64Word_create(773529912, 1546045734), X64Word_create(1294757372, 1522805485), X64Word_create(1396182291, 2643833823), X64Word_create(1695183700, 2343527390), X64Word_create(1986661051, 1014477480), X64Word_create(2177026350, 1206759142), X64Word_create(2456956037, 344077627), X64Word_create(2730485921, 1290863460), X64Word_create(2820302411, 3158454273), X64Word_create(3259730800, 3505952657), X64Word_create(3345764771, 106217008), X64Word_create(3516065817, 3606008344), X64Word_create(3600352804, 1432725776), X64Word_create(4094571909, 1467031594), X64Word_create(275423344, 851169720), X64Word_create(430227734, 3100823752), X64Word_create(506948616, 1363258195), X64Word_create(659060556, 3750685593), X64Word_create(883997877, 3785050280), X64Word_create(958139571, 3318307427), X64Word_create(1322822218, 3812723403), X64Word_create(1537002063, 2003034995), X64Word_create(1747873779, 3602036899), X64Word_create(1955562222, 1575990012), X64Word_create(2024104815, 1125592928), X64Word_create(2227730452, 2716904306), X64Word_create(2361852424, 442776044), X64Word_create(2428436474, 593698344), X64Word_create(2756734187, 3733110249), X64Word_create(3204031479, 2999351573), X64Word_create(3329325298, 3815920427), X64Word_create(3391569614, 3928383900), X64Word_create(3515267271, 566280711), X64Word_create(3940187606, 3454069534), X64Word_create(4118630271, 4000239992), X64Word_create(116418474, 1914138554), X64Word_create(174292421, 2731055270), X64Word_create(289380356, 3203993006), X64Word_create(460393269, 320620315), X64Word_create(685471733, 587496836), X64Word_create(852142971, 1086792851), X64Word_create(1017036298, 365543100), X64Word_create(1126000580, 2618297676), X64Word_create(1288033470, 3409855158), X64Word_create(1501505948, 4234509866), X64Word_create(1607167915, 987167468), X64Word_create(1816402316, 1246189591)];
              var W = [];
              (function() {
                for (var i = 0; i < 80; i++) {
                  W[i] = X64Word_create();
                }
              })();
              var SHA512 = C_algo.SHA512 = Hasher.extend({
                _doReset: function() {
                  this._hash = new X64WordArray.init([new X64Word.init(1779033703, 4089235720), new X64Word.init(3144134277, 2227873595), new X64Word.init(1013904242, 4271175723), new X64Word.init(2773480762, 1595750129), new X64Word.init(1359893119, 2917565137), new X64Word.init(2600822924, 725511199), new X64Word.init(528734635, 4215389547), new X64Word.init(1541459225, 327033209)]);
                },
                _doProcessBlock: function(M, offset) {
                  var H = this._hash.words;
                  var H0 = H[0];
                  var H1 = H[1];
                  var H2 = H[2];
                  var H3 = H[3];
                  var H4 = H[4];
                  var H5 = H[5];
                  var H6 = H[6];
                  var H7 = H[7];
                  var H0h = H0.high;
                  var H0l = H0.low;
                  var H1h = H1.high;
                  var H1l = H1.low;
                  var H2h = H2.high;
                  var H2l = H2.low;
                  var H3h = H3.high;
                  var H3l = H3.low;
                  var H4h = H4.high;
                  var H4l = H4.low;
                  var H5h = H5.high;
                  var H5l = H5.low;
                  var H6h = H6.high;
                  var H6l = H6.low;
                  var H7h = H7.high;
                  var H7l = H7.low;
                  var ah = H0h;
                  var al = H0l;
                  var bh = H1h;
                  var bl = H1l;
                  var ch = H2h;
                  var cl = H2l;
                  var dh = H3h;
                  var dl = H3l;
                  var eh = H4h;
                  var el = H4l;
                  var fh = H5h;
                  var fl = H5l;
                  var gh = H6h;
                  var gl = H6l;
                  var hh = H7h;
                  var hl = H7l;
                  for (var i = 0; i < 80; i++) {
                    var Wil;
                    var Wih;
                    var Wi = W[i];
                    if (i < 16) {
                      Wih = Wi.high = M[offset + i * 2] | 0;
                      Wil = Wi.low = M[offset + i * 2 + 1] | 0;
                    } else {
                      var gamma0x = W[i - 15];
                      var gamma0xh = gamma0x.high;
                      var gamma0xl = gamma0x.low;
                      var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                      var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                      var gamma1x = W[i - 2];
                      var gamma1xh = gamma1x.high;
                      var gamma1xl = gamma1x.low;
                      var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                      var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                      var Wi7 = W[i - 7];
                      var Wi7h = Wi7.high;
                      var Wi7l = Wi7.low;
                      var Wi16 = W[i - 16];
                      var Wi16h = Wi16.high;
                      var Wi16l = Wi16.low;
                      Wil = gamma0l + Wi7l;
                      Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                      Wil = Wil + gamma1l;
                      Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                      Wil = Wil + Wi16l;
                      Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                      Wi.high = Wih;
                      Wi.low = Wil;
                    }
                    var chh = eh & fh ^ ~eh & gh;
                    var chl = el & fl ^ ~el & gl;
                    var majh = ah & bh ^ ah & ch ^ bh & ch;
                    var majl = al & bl ^ al & cl ^ bl & cl;
                    var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                    var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                    var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                    var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                    var Ki = K[i];
                    var Kih = Ki.high;
                    var Kil = Ki.low;
                    var t1l = hl + sigma1l;
                    var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                    var t1l = t1l + chl;
                    var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                    var t1l = t1l + Kil;
                    var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                    var t1l = t1l + Wil;
                    var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                    var t2l = sigma0l + majl;
                    var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                    hh = gh;
                    hl = gl;
                    gh = fh;
                    gl = fl;
                    fh = eh;
                    fl = el;
                    el = dl + t1l | 0;
                    eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                    dh = ch;
                    dl = cl;
                    ch = bh;
                    cl = bl;
                    bh = ah;
                    bl = al;
                    al = t1l + t2l | 0;
                    ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
                  }
                  H0l = H0.low = H0l + al;
                  H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
                  H1l = H1.low = H1l + bl;
                  H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
                  H2l = H2.low = H2l + cl;
                  H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
                  H3l = H3.low = H3l + dl;
                  H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
                  H4l = H4.low = H4l + el;
                  H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
                  H5l = H5.low = H5l + fl;
                  H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
                  H6l = H6.low = H6l + gl;
                  H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
                  H7l = H7.low = H7l + hl;
                  H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
                },
                _doFinalize: function() {
                  var data = this._data;
                  var dataWords = data.words;
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
                  dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                  dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
                  dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
                  data.sigBytes = dataWords.length * 4;
                  this._process();
                  var hash = this._hash.toX32();
                  return hash;
                },
                clone: function() {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
                  return clone;
                },
                blockSize: 1024 / 32
              });
              C.SHA512 = Hasher._createHelper(SHA512);
              C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
            })();
            return CryptoJS.SHA512;
          });
        })(sha512$1, sha512$1.exports);
        return sha512$1.exports;
      }
      var sha384$1 = { exports: {} };
      var sha384 = sha384$1.exports;
      var hasRequiredSha384;
      function requireSha384() {
        if (hasRequiredSha384) return sha384$1.exports;
        hasRequiredSha384 = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireX64Core(), requireSha512());
            }
          })(sha384, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_x64 = C.x64;
              var X64Word = C_x64.Word;
              var X64WordArray = C_x64.WordArray;
              var C_algo = C.algo;
              var SHA512 = C_algo.SHA512;
              var SHA384 = C_algo.SHA384 = SHA512.extend({
                _doReset: function() {
                  this._hash = new X64WordArray.init([new X64Word.init(3418070365, 3238371032), new X64Word.init(1654270250, 914150663), new X64Word.init(2438529370, 812702999), new X64Word.init(355462360, 4144912697), new X64Word.init(1731405415, 4290775857), new X64Word.init(2394180231, 1750603025), new X64Word.init(3675008525, 1694076839), new X64Word.init(1203062813, 3204075428)]);
                },
                _doFinalize: function() {
                  var hash = SHA512._doFinalize.call(this);
                  hash.sigBytes -= 16;
                  return hash;
                }
              });
              C.SHA384 = SHA512._createHelper(SHA384);
              C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
            })();
            return CryptoJS.SHA384;
          });
        })(sha384$1, sha384$1.exports);
        return sha384$1.exports;
      }
      var sha3$1 = { exports: {} };
      var sha3 = sha3$1.exports;
      var hasRequiredSha3;
      function requireSha3() {
        if (hasRequiredSha3) return sha3$1.exports;
        hasRequiredSha3 = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireX64Core());
            }
          })(sha3, function(CryptoJS) {
            (function(Math2) {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var Hasher = C_lib.Hasher;
              var C_x64 = C.x64;
              var X64Word = C_x64.Word;
              var C_algo = C.algo;
              var RHO_OFFSETS = [];
              var PI_INDEXES = [];
              var ROUND_CONSTANTS = [];
              (function() {
                var x = 1, y = 0;
                for (var t = 0; t < 24; t++) {
                  RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
                  var newX = y % 5;
                  var newY = (2 * x + 3 * y) % 5;
                  x = newX;
                  y = newY;
                }
                for (var x = 0; x < 5; x++) {
                  for (var y = 0; y < 5; y++) {
                    PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
                  }
                }
                var LFSR = 1;
                for (var i = 0; i < 24; i++) {
                  var roundConstantMsw = 0;
                  var roundConstantLsw = 0;
                  for (var j = 0; j < 7; j++) {
                    if (LFSR & 1) {
                      var bitPosition = (1 << j) - 1;
                      if (bitPosition < 32) {
                        roundConstantLsw ^= 1 << bitPosition;
                      } else {
                        roundConstantMsw ^= 1 << bitPosition - 32;
                      }
                    }
                    if (LFSR & 128) {
                      LFSR = LFSR << 1 ^ 113;
                    } else {
                      LFSR <<= 1;
                    }
                  }
                  ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
                }
              })();
              var T = [];
              (function() {
                for (var i = 0; i < 25; i++) {
                  T[i] = X64Word.create();
                }
              })();
              var SHA3 = C_algo.SHA3 = Hasher.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} outputLength
                 *   The desired number of bits in the output hash.
                 *   Only values permitted are: 224, 256, 384, 512.
                 *   Default: 512
                 */
                cfg: Hasher.cfg.extend({
                  outputLength: 512
                }),
                _doReset: function() {
                  var state = this._state = [];
                  for (var i = 0; i < 25; i++) {
                    state[i] = new X64Word.init();
                  }
                  this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                },
                _doProcessBlock: function(M, offset) {
                  var state = this._state;
                  var nBlockSizeLanes = this.blockSize / 2;
                  for (var i = 0; i < nBlockSizeLanes; i++) {
                    var M2i = M[offset + 2 * i];
                    var M2i1 = M[offset + 2 * i + 1];
                    M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                    M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                    var lane = state[i];
                    lane.high ^= M2i1;
                    lane.low ^= M2i;
                  }
                  for (var round = 0; round < 24; round++) {
                    for (var x = 0; x < 5; x++) {
                      var tMsw = 0, tLsw = 0;
                      for (var y = 0; y < 5; y++) {
                        var lane = state[x + 5 * y];
                        tMsw ^= lane.high;
                        tLsw ^= lane.low;
                      }
                      var Tx = T[x];
                      Tx.high = tMsw;
                      Tx.low = tLsw;
                    }
                    for (var x = 0; x < 5; x++) {
                      var Tx4 = T[(x + 4) % 5];
                      var Tx1 = T[(x + 1) % 5];
                      var Tx1Msw = Tx1.high;
                      var Tx1Lsw = Tx1.low;
                      var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                      var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                      for (var y = 0; y < 5; y++) {
                        var lane = state[x + 5 * y];
                        lane.high ^= tMsw;
                        lane.low ^= tLsw;
                      }
                    }
                    for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                      var tMsw;
                      var tLsw;
                      var lane = state[laneIndex];
                      var laneMsw = lane.high;
                      var laneLsw = lane.low;
                      var rhoOffset = RHO_OFFSETS[laneIndex];
                      if (rhoOffset < 32) {
                        tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                        tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                      } else {
                        tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                        tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                      }
                      var TPiLane = T[PI_INDEXES[laneIndex]];
                      TPiLane.high = tMsw;
                      TPiLane.low = tLsw;
                    }
                    var T0 = T[0];
                    var state0 = state[0];
                    T0.high = state0.high;
                    T0.low = state0.low;
                    for (var x = 0; x < 5; x++) {
                      for (var y = 0; y < 5; y++) {
                        var laneIndex = x + 5 * y;
                        var lane = state[laneIndex];
                        var TLane = T[laneIndex];
                        var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                        var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                        lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                        lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                      }
                    }
                    var lane = state[0];
                    var roundConstant = ROUND_CONSTANTS[round];
                    lane.high ^= roundConstant.high;
                    lane.low ^= roundConstant.low;
                  }
                },
                _doFinalize: function() {
                  var data = this._data;
                  var dataWords = data.words;
                  this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
                  var blockSizeBits = this.blockSize * 32;
                  dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
                  dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
                  data.sigBytes = dataWords.length * 4;
                  this._process();
                  var state = this._state;
                  var outputLengthBytes = this.cfg.outputLength / 8;
                  var outputLengthLanes = outputLengthBytes / 8;
                  var hashWords = [];
                  for (var i = 0; i < outputLengthLanes; i++) {
                    var lane = state[i];
                    var laneMsw = lane.high;
                    var laneLsw = lane.low;
                    laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                    laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                    hashWords.push(laneLsw);
                    hashWords.push(laneMsw);
                  }
                  return new WordArray.init(hashWords, outputLengthBytes);
                },
                clone: function() {
                  var clone = Hasher.clone.call(this);
                  var state = clone._state = this._state.slice(0);
                  for (var i = 0; i < 25; i++) {
                    state[i] = state[i].clone();
                  }
                  return clone;
                }
              });
              C.SHA3 = Hasher._createHelper(SHA3);
              C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
            })(Math);
            return CryptoJS.SHA3;
          });
        })(sha3$1, sha3$1.exports);
        return sha3$1.exports;
      }
      var ripemd160$1 = { exports: {} };
      var ripemd160 = ripemd160$1.exports;
      var hasRequiredRipemd160;
      function requireRipemd160() {
        if (hasRequiredRipemd160) return ripemd160$1.exports;
        hasRequiredRipemd160 = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(ripemd160, function(CryptoJS) {
            (function(Math2) {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var Hasher = C_lib.Hasher;
              var C_algo = C.algo;
              var _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);
              var _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);
              var _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);
              var _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);
              var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
              var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
              var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
                _doReset: function() {
                  this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                },
                _doProcessBlock: function(M, offset) {
                  for (var i = 0; i < 16; i++) {
                    var offset_i = offset + i;
                    var M_offset_i = M[offset_i];
                    M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                  }
                  var H = this._hash.words;
                  var hl = _hl.words;
                  var hr = _hr.words;
                  var zl = _zl.words;
                  var zr = _zr.words;
                  var sl = _sl.words;
                  var sr = _sr.words;
                  var al, bl, cl, dl, el;
                  var ar, br, cr, dr, er;
                  ar = al = H[0];
                  br = bl = H[1];
                  cr = cl = H[2];
                  dr = dl = H[3];
                  er = el = H[4];
                  var t;
                  for (var i = 0; i < 80; i += 1) {
                    t = al + M[offset + zl[i]] | 0;
                    if (i < 16) {
                      t += f1(bl, cl, dl) + hl[0];
                    } else if (i < 32) {
                      t += f2(bl, cl, dl) + hl[1];
                    } else if (i < 48) {
                      t += f3(bl, cl, dl) + hl[2];
                    } else if (i < 64) {
                      t += f4(bl, cl, dl) + hl[3];
                    } else {
                      t += f5(bl, cl, dl) + hl[4];
                    }
                    t = t | 0;
                    t = rotl(t, sl[i]);
                    t = t + el | 0;
                    al = el;
                    el = dl;
                    dl = rotl(cl, 10);
                    cl = bl;
                    bl = t;
                    t = ar + M[offset + zr[i]] | 0;
                    if (i < 16) {
                      t += f5(br, cr, dr) + hr[0];
                    } else if (i < 32) {
                      t += f4(br, cr, dr) + hr[1];
                    } else if (i < 48) {
                      t += f3(br, cr, dr) + hr[2];
                    } else if (i < 64) {
                      t += f2(br, cr, dr) + hr[3];
                    } else {
                      t += f1(br, cr, dr) + hr[4];
                    }
                    t = t | 0;
                    t = rotl(t, sr[i]);
                    t = t + er | 0;
                    ar = er;
                    er = dr;
                    dr = rotl(cr, 10);
                    cr = br;
                    br = t;
                  }
                  t = H[1] + cl + dr | 0;
                  H[1] = H[2] + dl + er | 0;
                  H[2] = H[3] + el + ar | 0;
                  H[3] = H[4] + al + br | 0;
                  H[4] = H[0] + bl + cr | 0;
                  H[0] = t;
                },
                _doFinalize: function() {
                  var data = this._data;
                  var dataWords = data.words;
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
                  dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
                  data.sigBytes = (dataWords.length + 1) * 4;
                  this._process();
                  var hash = this._hash;
                  var H = hash.words;
                  for (var i = 0; i < 5; i++) {
                    var H_i = H[i];
                    H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                  }
                  return hash;
                },
                clone: function() {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
                  return clone;
                }
              });
              function f1(x, y, z) {
                return x ^ y ^ z;
              }
              function f2(x, y, z) {
                return x & y | ~x & z;
              }
              function f3(x, y, z) {
                return (x | ~y) ^ z;
              }
              function f4(x, y, z) {
                return x & z | y & ~z;
              }
              function f5(x, y, z) {
                return x ^ (y | ~z);
              }
              function rotl(x, n) {
                return x << n | x >>> 32 - n;
              }
              C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
              C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
            })();
            return CryptoJS.RIPEMD160;
          });
        })(ripemd160$1, ripemd160$1.exports);
        return ripemd160$1.exports;
      }
      var hmac$1 = { exports: {} };
      var hmac = hmac$1.exports;
      var hasRequiredHmac;
      function requireHmac() {
        if (hasRequiredHmac) return hmac$1.exports;
        hasRequiredHmac = 1;
        (function(module2, exports2) {
          (function(root, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(hmac, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var Base = C_lib.Base;
              var C_enc = C.enc;
              var Utf8 = C_enc.Utf8;
              var C_algo = C.algo;
              C_algo.HMAC = Base.extend({
                /**
                 * Initializes a newly created HMAC.
                 *
                 * @param {Hasher} hasher The hash algorithm to use.
                 * @param {WordArray|string} key The secret key.
                 *
                 * @example
                 *
                 *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
                 */
                init: function(hasher, key) {
                  hasher = this._hasher = new hasher.init();
                  if (typeof key == "string") {
                    key = Utf8.parse(key);
                  }
                  var hasherBlockSize = hasher.blockSize;
                  var hasherBlockSizeBytes = hasherBlockSize * 4;
                  if (key.sigBytes > hasherBlockSizeBytes) {
                    key = hasher.finalize(key);
                  }
                  key.clamp();
                  var oKey = this._oKey = key.clone();
                  var iKey = this._iKey = key.clone();
                  var oKeyWords = oKey.words;
                  var iKeyWords = iKey.words;
                  for (var i = 0; i < hasherBlockSize; i++) {
                    oKeyWords[i] ^= 1549556828;
                    iKeyWords[i] ^= 909522486;
                  }
                  oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
                  this.reset();
                },
                /**
                 * Resets this HMAC to its initial state.
                 *
                 * @example
                 *
                 *     hmacHasher.reset();
                 */
                reset: function() {
                  var hasher = this._hasher;
                  hasher.reset();
                  hasher.update(this._iKey);
                },
                /**
                 * Updates this HMAC with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {HMAC} This HMAC instance.
                 *
                 * @example
                 *
                 *     hmacHasher.update('message');
                 *     hmacHasher.update(wordArray);
                 */
                update: function(messageUpdate) {
                  this._hasher.update(messageUpdate);
                  return this;
                },
                /**
                 * Finalizes the HMAC computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The HMAC.
                 *
                 * @example
                 *
                 *     var hmac = hmacHasher.finalize();
                 *     var hmac = hmacHasher.finalize('message');
                 *     var hmac = hmacHasher.finalize(wordArray);
                 */
                finalize: function(messageUpdate) {
                  var hasher = this._hasher;
                  var innerHash = hasher.finalize(messageUpdate);
                  hasher.reset();
                  var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
                  return hmac2;
                }
              });
            })();
          });
        })(hmac$1, hmac$1.exports);
        return hmac$1.exports;
      }
      var pbkdf2$1 = { exports: {} };
      var pbkdf2 = pbkdf2$1.exports;
      var hasRequiredPbkdf2;
      function requirePbkdf2() {
        if (hasRequiredPbkdf2) return pbkdf2$1.exports;
        hasRequiredPbkdf2 = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireSha256(), requireHmac());
            }
          })(pbkdf2, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var Base = C_lib.Base;
              var WordArray = C_lib.WordArray;
              var C_algo = C.algo;
              var SHA256 = C_algo.SHA256;
              var HMAC = C_algo.HMAC;
              var PBKDF2 = C_algo.PBKDF2 = Base.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                 * @property {Hasher} hasher The hasher to use. Default: SHA256
                 * @property {number} iterations The number of iterations to perform. Default: 250000
                 */
                cfg: Base.extend({
                  keySize: 128 / 32,
                  hasher: SHA256,
                  iterations: 25e4
                }),
                /**
                 * Initializes a newly created key derivation function.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                 *
                 * @example
                 *
                 *     var kdf = CryptoJS.algo.PBKDF2.create();
                 *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
                 *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
                 */
                init: function(cfg) {
                  this.cfg = this.cfg.extend(cfg);
                },
                /**
                 * Computes the Password-Based Key Derivation Function 2.
                 *
                 * @param {WordArray|string} password The password.
                 * @param {WordArray|string} salt A salt.
                 *
                 * @return {WordArray} The derived key.
                 *
                 * @example
                 *
                 *     var key = kdf.compute(password, salt);
                 */
                compute: function(password, salt) {
                  var cfg = this.cfg;
                  var hmac2 = HMAC.create(cfg.hasher, password);
                  var derivedKey = WordArray.create();
                  var blockIndex = WordArray.create([1]);
                  var derivedKeyWords = derivedKey.words;
                  var blockIndexWords = blockIndex.words;
                  var keySize = cfg.keySize;
                  var iterations = cfg.iterations;
                  while (derivedKeyWords.length < keySize) {
                    var block = hmac2.update(salt).finalize(blockIndex);
                    hmac2.reset();
                    var blockWords = block.words;
                    var blockWordsLength = blockWords.length;
                    var intermediate = block;
                    for (var i = 1; i < iterations; i++) {
                      intermediate = hmac2.finalize(intermediate);
                      hmac2.reset();
                      var intermediateWords = intermediate.words;
                      for (var j = 0; j < blockWordsLength; j++) {
                        blockWords[j] ^= intermediateWords[j];
                      }
                    }
                    derivedKey.concat(block);
                    blockIndexWords[0]++;
                  }
                  derivedKey.sigBytes = keySize * 4;
                  return derivedKey;
                }
              });
              C.PBKDF2 = function(password, salt, cfg) {
                return PBKDF2.create(cfg).compute(password, salt);
              };
            })();
            return CryptoJS.PBKDF2;
          });
        })(pbkdf2$1, pbkdf2$1.exports);
        return pbkdf2$1.exports;
      }
      var evpkdf$1 = { exports: {} };
      var evpkdf = evpkdf$1.exports;
      var hasRequiredEvpkdf;
      function requireEvpkdf() {
        if (hasRequiredEvpkdf) return evpkdf$1.exports;
        hasRequiredEvpkdf = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireSha1(), requireHmac());
            }
          })(evpkdf, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var Base = C_lib.Base;
              var WordArray = C_lib.WordArray;
              var C_algo = C.algo;
              var MD5 = C_algo.MD5;
              var EvpKDF = C_algo.EvpKDF = Base.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                 * @property {Hasher} hasher The hash algorithm to use. Default: MD5
                 * @property {number} iterations The number of iterations to perform. Default: 1
                 */
                cfg: Base.extend({
                  keySize: 128 / 32,
                  hasher: MD5,
                  iterations: 1
                }),
                /**
                 * Initializes a newly created key derivation function.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                 *
                 * @example
                 *
                 *     var kdf = CryptoJS.algo.EvpKDF.create();
                 *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
                 *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
                 */
                init: function(cfg) {
                  this.cfg = this.cfg.extend(cfg);
                },
                /**
                 * Derives a key from a password.
                 *
                 * @param {WordArray|string} password The password.
                 * @param {WordArray|string} salt A salt.
                 *
                 * @return {WordArray} The derived key.
                 *
                 * @example
                 *
                 *     var key = kdf.compute(password, salt);
                 */
                compute: function(password, salt) {
                  var block;
                  var cfg = this.cfg;
                  var hasher = cfg.hasher.create();
                  var derivedKey = WordArray.create();
                  var derivedKeyWords = derivedKey.words;
                  var keySize = cfg.keySize;
                  var iterations = cfg.iterations;
                  while (derivedKeyWords.length < keySize) {
                    if (block) {
                      hasher.update(block);
                    }
                    block = hasher.update(password).finalize(salt);
                    hasher.reset();
                    for (var i = 1; i < iterations; i++) {
                      block = hasher.finalize(block);
                      hasher.reset();
                    }
                    derivedKey.concat(block);
                  }
                  derivedKey.sigBytes = keySize * 4;
                  return derivedKey;
                }
              });
              C.EvpKDF = function(password, salt, cfg) {
                return EvpKDF.create(cfg).compute(password, salt);
              };
            })();
            return CryptoJS.EvpKDF;
          });
        })(evpkdf$1, evpkdf$1.exports);
        return evpkdf$1.exports;
      }
      var cipherCore$1 = { exports: {} };
      var cipherCore = cipherCore$1.exports;
      var hasRequiredCipherCore;
      function requireCipherCore() {
        if (hasRequiredCipherCore) return cipherCore$1.exports;
        hasRequiredCipherCore = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireEvpkdf());
            }
          })(cipherCore, function(CryptoJS) {
            CryptoJS.lib.Cipher || function(undefined$1) {
              var C = CryptoJS;
              var C_lib = C.lib;
              var Base = C_lib.Base;
              var WordArray = C_lib.WordArray;
              var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
              var C_enc = C.enc;
              C_enc.Utf8;
              var Base64 = C_enc.Base64;
              var C_algo = C.algo;
              var EvpKDF = C_algo.EvpKDF;
              var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
                /**
                 * Configuration options.
                 *
                 * @property {WordArray} iv The IV to use for this operation.
                 */
                cfg: Base.extend(),
                /**
                 * Creates this cipher in encryption mode.
                 *
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {Cipher} A cipher instance.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
                 */
                createEncryptor: function(key, cfg) {
                  return this.create(this._ENC_XFORM_MODE, key, cfg);
                },
                /**
                 * Creates this cipher in decryption mode.
                 *
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {Cipher} A cipher instance.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
                 */
                createDecryptor: function(key, cfg) {
                  return this.create(this._DEC_XFORM_MODE, key, cfg);
                },
                /**
                 * Initializes a newly created cipher.
                 *
                 * @param {number} xformMode Either the encryption or decryption transormation mode constant.
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @example
                 *
                 *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
                 */
                init: function(xformMode, key, cfg) {
                  this.cfg = this.cfg.extend(cfg);
                  this._xformMode = xformMode;
                  this._key = key;
                  this.reset();
                },
                /**
                 * Resets this cipher to its initial state.
                 *
                 * @example
                 *
                 *     cipher.reset();
                 */
                reset: function() {
                  BufferedBlockAlgorithm.reset.call(this);
                  this._doReset();
                },
                /**
                 * Adds data to be encrypted or decrypted.
                 *
                 * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
                 *
                 * @return {WordArray} The data after processing.
                 *
                 * @example
                 *
                 *     var encrypted = cipher.process('data');
                 *     var encrypted = cipher.process(wordArray);
                 */
                process: function(dataUpdate) {
                  this._append(dataUpdate);
                  return this._process();
                },
                /**
                 * Finalizes the encryption or decryption process.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
                 *
                 * @return {WordArray} The data after final processing.
                 *
                 * @example
                 *
                 *     var encrypted = cipher.finalize();
                 *     var encrypted = cipher.finalize('data');
                 *     var encrypted = cipher.finalize(wordArray);
                 */
                finalize: function(dataUpdate) {
                  if (dataUpdate) {
                    this._append(dataUpdate);
                  }
                  var finalProcessedData = this._doFinalize();
                  return finalProcessedData;
                },
                keySize: 128 / 32,
                ivSize: 128 / 32,
                _ENC_XFORM_MODE: 1,
                _DEC_XFORM_MODE: 2,
                /**
                 * Creates shortcut functions to a cipher's object interface.
                 *
                 * @param {Cipher} cipher The cipher to create a helper for.
                 *
                 * @return {Object} An object with encrypt and decrypt shortcut functions.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
                 */
                _createHelper: /* @__PURE__ */ function() {
                  function selectCipherStrategy(key) {
                    if (typeof key == "string") {
                      return PasswordBasedCipher;
                    } else {
                      return SerializableCipher;
                    }
                  }
                  return function(cipher) {
                    return {
                      encrypt: function(message, key, cfg) {
                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                      },
                      decrypt: function(ciphertext, key, cfg) {
                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                      }
                    };
                  };
                }()
              });
              C_lib.StreamCipher = Cipher.extend({
                _doFinalize: function() {
                  var finalProcessedBlocks = this._process(true);
                  return finalProcessedBlocks;
                },
                blockSize: 1
              });
              var C_mode = C.mode = {};
              var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
                /**
                 * Creates this mode for encryption.
                 *
                 * @param {Cipher} cipher A block cipher instance.
                 * @param {Array} iv The IV words.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
                 */
                createEncryptor: function(cipher, iv) {
                  return this.Encryptor.create(cipher, iv);
                },
                /**
                 * Creates this mode for decryption.
                 *
                 * @param {Cipher} cipher A block cipher instance.
                 * @param {Array} iv The IV words.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
                 */
                createDecryptor: function(cipher, iv) {
                  return this.Decryptor.create(cipher, iv);
                },
                /**
                 * Initializes a newly created mode.
                 *
                 * @param {Cipher} cipher A block cipher instance.
                 * @param {Array} iv The IV words.
                 *
                 * @example
                 *
                 *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
                 */
                init: function(cipher, iv) {
                  this._cipher = cipher;
                  this._iv = iv;
                }
              });
              var CBC = C_mode.CBC = function() {
                var CBC2 = BlockCipherMode.extend();
                CBC2.Encryptor = CBC2.extend({
                  /**
                   * Processes the data block at offset.
                   *
                   * @param {Array} words The data words to operate on.
                   * @param {number} offset The offset where the block starts.
                   *
                   * @example
                   *
                   *     mode.processBlock(data.words, offset);
                   */
                  processBlock: function(words, offset) {
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
                    xorBlock.call(this, words, offset, blockSize);
                    cipher.encryptBlock(words, offset);
                    this._prevBlock = words.slice(offset, offset + blockSize);
                  }
                });
                CBC2.Decryptor = CBC2.extend({
                  /**
                   * Processes the data block at offset.
                   *
                   * @param {Array} words The data words to operate on.
                   * @param {number} offset The offset where the block starts.
                   *
                   * @example
                   *
                   *     mode.processBlock(data.words, offset);
                   */
                  processBlock: function(words, offset) {
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
                    var thisBlock = words.slice(offset, offset + blockSize);
                    cipher.decryptBlock(words, offset);
                    xorBlock.call(this, words, offset, blockSize);
                    this._prevBlock = thisBlock;
                  }
                });
                function xorBlock(words, offset, blockSize) {
                  var block;
                  var iv = this._iv;
                  if (iv) {
                    block = iv;
                    this._iv = undefined$1;
                  } else {
                    block = this._prevBlock;
                  }
                  for (var i = 0; i < blockSize; i++) {
                    words[offset + i] ^= block[i];
                  }
                }
                return CBC2;
              }();
              var C_pad = C.pad = {};
              var Pkcs7 = C_pad.Pkcs7 = {
                /**
                 * Pads data using the algorithm defined in PKCS #5/7.
                 *
                 * @param {WordArray} data The data to pad.
                 * @param {number} blockSize The multiple that the data should be padded to.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
                 */
                pad: function(data, blockSize) {
                  var blockSizeBytes = blockSize * 4;
                  var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                  var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
                  var paddingWords = [];
                  for (var i = 0; i < nPaddingBytes; i += 4) {
                    paddingWords.push(paddingWord);
                  }
                  var padding = WordArray.create(paddingWords, nPaddingBytes);
                  data.concat(padding);
                },
                /**
                 * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
                 *
                 * @param {WordArray} data The data to unpad.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     CryptoJS.pad.Pkcs7.unpad(wordArray);
                 */
                unpad: function(data) {
                  var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                  data.sigBytes -= nPaddingBytes;
                }
              };
              C_lib.BlockCipher = Cipher.extend({
                /**
                 * Configuration options.
                 *
                 * @property {Mode} mode The block mode to use. Default: CBC
                 * @property {Padding} padding The padding strategy to use. Default: Pkcs7
                 */
                cfg: Cipher.cfg.extend({
                  mode: CBC,
                  padding: Pkcs7
                }),
                reset: function() {
                  var modeCreator;
                  Cipher.reset.call(this);
                  var cfg = this.cfg;
                  var iv = cfg.iv;
                  var mode = cfg.mode;
                  if (this._xformMode == this._ENC_XFORM_MODE) {
                    modeCreator = mode.createEncryptor;
                  } else {
                    modeCreator = mode.createDecryptor;
                    this._minBufferSize = 1;
                  }
                  if (this._mode && this._mode.__creator == modeCreator) {
                    this._mode.init(this, iv && iv.words);
                  } else {
                    this._mode = modeCreator.call(mode, this, iv && iv.words);
                    this._mode.__creator = modeCreator;
                  }
                },
                _doProcessBlock: function(words, offset) {
                  this._mode.processBlock(words, offset);
                },
                _doFinalize: function() {
                  var finalProcessedBlocks;
                  var padding = this.cfg.padding;
                  if (this._xformMode == this._ENC_XFORM_MODE) {
                    padding.pad(this._data, this.blockSize);
                    finalProcessedBlocks = this._process(true);
                  } else {
                    finalProcessedBlocks = this._process(true);
                    padding.unpad(finalProcessedBlocks);
                  }
                  return finalProcessedBlocks;
                },
                blockSize: 128 / 32
              });
              var CipherParams = C_lib.CipherParams = Base.extend({
                /**
                 * Initializes a newly created cipher params object.
                 *
                 * @param {Object} cipherParams An object with any of the possible cipher parameters.
                 *
                 * @example
                 *
                 *     var cipherParams = CryptoJS.lib.CipherParams.create({
                 *         ciphertext: ciphertextWordArray,
                 *         key: keyWordArray,
                 *         iv: ivWordArray,
                 *         salt: saltWordArray,
                 *         algorithm: CryptoJS.algo.AES,
                 *         mode: CryptoJS.mode.CBC,
                 *         padding: CryptoJS.pad.PKCS7,
                 *         blockSize: 4,
                 *         formatter: CryptoJS.format.OpenSSL
                 *     });
                 */
                init: function(cipherParams) {
                  this.mixIn(cipherParams);
                },
                /**
                 * Converts this cipher params object to a string.
                 *
                 * @param {Format} formatter (Optional) The formatting strategy to use.
                 *
                 * @return {string} The stringified cipher params.
                 *
                 * @throws Error If neither the formatter nor the default formatter is set.
                 *
                 * @example
                 *
                 *     var string = cipherParams + '';
                 *     var string = cipherParams.toString();
                 *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
                 */
                toString: function(formatter) {
                  return (formatter || this.formatter).stringify(this);
                }
              });
              var C_format = C.format = {};
              var OpenSSLFormatter = C_format.OpenSSL = {
                /**
                 * Converts a cipher params object to an OpenSSL-compatible string.
                 *
                 * @param {CipherParams} cipherParams The cipher params object.
                 *
                 * @return {string} The OpenSSL-compatible string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
                 */
                stringify: function(cipherParams) {
                  var wordArray;
                  var ciphertext = cipherParams.ciphertext;
                  var salt = cipherParams.salt;
                  if (salt) {
                    wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
                  } else {
                    wordArray = ciphertext;
                  }
                  return wordArray.toString(Base64);
                },
                /**
                 * Converts an OpenSSL-compatible string to a cipher params object.
                 *
                 * @param {string} openSSLStr The OpenSSL-compatible string.
                 *
                 * @return {CipherParams} The cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
                 */
                parse: function(openSSLStr) {
                  var salt;
                  var ciphertext = Base64.parse(openSSLStr);
                  var ciphertextWords = ciphertext.words;
                  if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                    salt = WordArray.create(ciphertextWords.slice(2, 4));
                    ciphertextWords.splice(0, 4);
                    ciphertext.sigBytes -= 16;
                  }
                  return CipherParams.create({
                    ciphertext,
                    salt
                  });
                }
              };
              var SerializableCipher = C_lib.SerializableCipher = Base.extend({
                /**
                 * Configuration options.
                 *
                 * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
                 */
                cfg: Base.extend({
                  format: OpenSSLFormatter
                }),
                /**
                 * Encrypts a message.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {WordArray|string} message The message to encrypt.
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {CipherParams} A cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                 */
                encrypt: function(cipher, message, key, cfg) {
                  cfg = this.cfg.extend(cfg);
                  var encryptor = cipher.createEncryptor(key, cfg);
                  var ciphertext = encryptor.finalize(message);
                  var cipherCfg = encryptor.cfg;
                  return CipherParams.create({
                    ciphertext,
                    key,
                    iv: cipherCfg.iv,
                    algorithm: cipher,
                    mode: cipherCfg.mode,
                    padding: cipherCfg.padding,
                    blockSize: cipher.blockSize,
                    formatter: cfg.format
                  });
                },
                /**
                 * Decrypts serialized ciphertext.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {WordArray} The plaintext.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                 *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                 */
                decrypt: function(cipher, ciphertext, key, cfg) {
                  cfg = this.cfg.extend(cfg);
                  ciphertext = this._parse(ciphertext, cfg.format);
                  var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
                  return plaintext;
                },
                /**
                 * Converts serialized ciphertext to CipherParams,
                 * else assumed CipherParams already and returns ciphertext unchanged.
                 *
                 * @param {CipherParams|string} ciphertext The ciphertext.
                 * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
                 *
                 * @return {CipherParams} The unserialized ciphertext.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
                 */
                _parse: function(ciphertext, format) {
                  if (typeof ciphertext == "string") {
                    return format.parse(ciphertext, this);
                  } else {
                    return ciphertext;
                  }
                }
              });
              var C_kdf = C.kdf = {};
              var OpenSSLKdf = C_kdf.OpenSSL = {
                /**
                 * Derives a key and IV from a password.
                 *
                 * @param {string} password The password to derive from.
                 * @param {number} keySize The size in words of the key to generate.
                 * @param {number} ivSize The size in words of the IV to generate.
                 * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
                 *
                 * @return {CipherParams} A cipher params object with the key, IV, and salt.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
                 *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
                 */
                execute: function(password, keySize, ivSize, salt, hasher) {
                  if (!salt) {
                    salt = WordArray.random(64 / 8);
                  }
                  if (!hasher) {
                    var key = EvpKDF.create({
                      keySize: keySize + ivSize
                    }).compute(password, salt);
                  } else {
                    var key = EvpKDF.create({
                      keySize: keySize + ivSize,
                      hasher
                    }).compute(password, salt);
                  }
                  var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                  key.sigBytes = keySize * 4;
                  return CipherParams.create({
                    key,
                    iv,
                    salt
                  });
                }
              };
              var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
                /**
                 * Configuration options.
                 *
                 * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
                 */
                cfg: SerializableCipher.cfg.extend({
                  kdf: OpenSSLKdf
                }),
                /**
                 * Encrypts a message using a password.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {WordArray|string} message The message to encrypt.
                 * @param {string} password The password.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {CipherParams} A cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
                 *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
                 */
                encrypt: function(cipher, message, password, cfg) {
                  cfg = this.cfg.extend(cfg);
                  var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
                  cfg.iv = derivedParams.iv;
                  var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
                  ciphertext.mixIn(derivedParams);
                  return ciphertext;
                },
                /**
                 * Decrypts serialized ciphertext using a password.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                 * @param {string} password The password.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {WordArray} The plaintext.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
                 *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
                 */
                decrypt: function(cipher, ciphertext, password, cfg) {
                  cfg = this.cfg.extend(cfg);
                  ciphertext = this._parse(ciphertext, cfg.format);
                  var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
                  cfg.iv = derivedParams.iv;
                  var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
                  return plaintext;
                }
              });
            }();
          });
        })(cipherCore$1, cipherCore$1.exports);
        return cipherCore$1.exports;
      }
      var modeCfb$1 = { exports: {} };
      var modeCfb = modeCfb$1.exports;
      var hasRequiredModeCfb;
      function requireModeCfb() {
        if (hasRequiredModeCfb) return modeCfb$1.exports;
        hasRequiredModeCfb = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(modeCfb, function(CryptoJS) {
            CryptoJS.mode.CFB = function() {
              var CFB = CryptoJS.lib.BlockCipherMode.extend();
              CFB.Encryptor = CFB.extend({
                processBlock: function(words, offset) {
                  var cipher = this._cipher;
                  var blockSize = cipher.blockSize;
                  generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                  this._prevBlock = words.slice(offset, offset + blockSize);
                }
              });
              CFB.Decryptor = CFB.extend({
                processBlock: function(words, offset) {
                  var cipher = this._cipher;
                  var blockSize = cipher.blockSize;
                  var thisBlock = words.slice(offset, offset + blockSize);
                  generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                  this._prevBlock = thisBlock;
                }
              });
              function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
                var keystream;
                var iv = this._iv;
                if (iv) {
                  keystream = iv.slice(0);
                  this._iv = void 0;
                } else {
                  keystream = this._prevBlock;
                }
                cipher.encryptBlock(keystream, 0);
                for (var i = 0; i < blockSize; i++) {
                  words[offset + i] ^= keystream[i];
                }
              }
              return CFB;
            }();
            return CryptoJS.mode.CFB;
          });
        })(modeCfb$1, modeCfb$1.exports);
        return modeCfb$1.exports;
      }
      var modeCtr$1 = { exports: {} };
      var modeCtr = modeCtr$1.exports;
      var hasRequiredModeCtr;
      function requireModeCtr() {
        if (hasRequiredModeCtr) return modeCtr$1.exports;
        hasRequiredModeCtr = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(modeCtr, function(CryptoJS) {
            CryptoJS.mode.CTR = function() {
              var CTR = CryptoJS.lib.BlockCipherMode.extend();
              var Encryptor = CTR.Encryptor = CTR.extend({
                processBlock: function(words, offset) {
                  var cipher = this._cipher;
                  var blockSize = cipher.blockSize;
                  var iv = this._iv;
                  var counter = this._counter;
                  if (iv) {
                    counter = this._counter = iv.slice(0);
                    this._iv = void 0;
                  }
                  var keystream = counter.slice(0);
                  cipher.encryptBlock(keystream, 0);
                  counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
                  for (var i = 0; i < blockSize; i++) {
                    words[offset + i] ^= keystream[i];
                  }
                }
              });
              CTR.Decryptor = Encryptor;
              return CTR;
            }();
            return CryptoJS.mode.CTR;
          });
        })(modeCtr$1, modeCtr$1.exports);
        return modeCtr$1.exports;
      }
      var modeCtrGladman$1 = { exports: {} };
      var modeCtrGladman = modeCtrGladman$1.exports;
      var hasRequiredModeCtrGladman;
      function requireModeCtrGladman() {
        if (hasRequiredModeCtrGladman) return modeCtrGladman$1.exports;
        hasRequiredModeCtrGladman = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(modeCtrGladman, function(CryptoJS) {
            CryptoJS.mode.CTRGladman = function() {
              var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
              function incWord(word) {
                if ((word >> 24 & 255) === 255) {
                  var b1 = word >> 16 & 255;
                  var b2 = word >> 8 & 255;
                  var b3 = word & 255;
                  if (b1 === 255) {
                    b1 = 0;
                    if (b2 === 255) {
                      b2 = 0;
                      if (b3 === 255) {
                        b3 = 0;
                      } else {
                        ++b3;
                      }
                    } else {
                      ++b2;
                    }
                  } else {
                    ++b1;
                  }
                  word = 0;
                  word += b1 << 16;
                  word += b2 << 8;
                  word += b3;
                } else {
                  word += 1 << 24;
                }
                return word;
              }
              function incCounter(counter) {
                if ((counter[0] = incWord(counter[0])) === 0) {
                  counter[1] = incWord(counter[1]);
                }
                return counter;
              }
              var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
                processBlock: function(words, offset) {
                  var cipher = this._cipher;
                  var blockSize = cipher.blockSize;
                  var iv = this._iv;
                  var counter = this._counter;
                  if (iv) {
                    counter = this._counter = iv.slice(0);
                    this._iv = void 0;
                  }
                  incCounter(counter);
                  var keystream = counter.slice(0);
                  cipher.encryptBlock(keystream, 0);
                  for (var i = 0; i < blockSize; i++) {
                    words[offset + i] ^= keystream[i];
                  }
                }
              });
              CTRGladman.Decryptor = Encryptor;
              return CTRGladman;
            }();
            return CryptoJS.mode.CTRGladman;
          });
        })(modeCtrGladman$1, modeCtrGladman$1.exports);
        return modeCtrGladman$1.exports;
      }
      var modeOfb$1 = { exports: {} };
      var modeOfb = modeOfb$1.exports;
      var hasRequiredModeOfb;
      function requireModeOfb() {
        if (hasRequiredModeOfb) return modeOfb$1.exports;
        hasRequiredModeOfb = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(modeOfb, function(CryptoJS) {
            CryptoJS.mode.OFB = function() {
              var OFB = CryptoJS.lib.BlockCipherMode.extend();
              var Encryptor = OFB.Encryptor = OFB.extend({
                processBlock: function(words, offset) {
                  var cipher = this._cipher;
                  var blockSize = cipher.blockSize;
                  var iv = this._iv;
                  var keystream = this._keystream;
                  if (iv) {
                    keystream = this._keystream = iv.slice(0);
                    this._iv = void 0;
                  }
                  cipher.encryptBlock(keystream, 0);
                  for (var i = 0; i < blockSize; i++) {
                    words[offset + i] ^= keystream[i];
                  }
                }
              });
              OFB.Decryptor = Encryptor;
              return OFB;
            }();
            return CryptoJS.mode.OFB;
          });
        })(modeOfb$1, modeOfb$1.exports);
        return modeOfb$1.exports;
      }
      var modeEcb$1 = { exports: {} };
      var modeEcb = modeEcb$1.exports;
      var hasRequiredModeEcb;
      function requireModeEcb() {
        if (hasRequiredModeEcb) return modeEcb$1.exports;
        hasRequiredModeEcb = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(modeEcb, function(CryptoJS) {
            CryptoJS.mode.ECB = function() {
              var ECB = CryptoJS.lib.BlockCipherMode.extend();
              ECB.Encryptor = ECB.extend({
                processBlock: function(words, offset) {
                  this._cipher.encryptBlock(words, offset);
                }
              });
              ECB.Decryptor = ECB.extend({
                processBlock: function(words, offset) {
                  this._cipher.decryptBlock(words, offset);
                }
              });
              return ECB;
            }();
            return CryptoJS.mode.ECB;
          });
        })(modeEcb$1, modeEcb$1.exports);
        return modeEcb$1.exports;
      }
      var padAnsix923$1 = { exports: {} };
      var padAnsix923 = padAnsix923$1.exports;
      var hasRequiredPadAnsix923;
      function requirePadAnsix923() {
        if (hasRequiredPadAnsix923) return padAnsix923$1.exports;
        hasRequiredPadAnsix923 = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(padAnsix923, function(CryptoJS) {
            CryptoJS.pad.AnsiX923 = {
              pad: function(data, blockSize) {
                var dataSigBytes = data.sigBytes;
                var blockSizeBytes = blockSize * 4;
                var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
                var lastBytePos = dataSigBytes + nPaddingBytes - 1;
                data.clamp();
                data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
                data.sigBytes += nPaddingBytes;
              },
              unpad: function(data) {
                var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                data.sigBytes -= nPaddingBytes;
              }
            };
            return CryptoJS.pad.Ansix923;
          });
        })(padAnsix923$1, padAnsix923$1.exports);
        return padAnsix923$1.exports;
      }
      var padIso10126$1 = { exports: {} };
      var padIso10126 = padIso10126$1.exports;
      var hasRequiredPadIso10126;
      function requirePadIso10126() {
        if (hasRequiredPadIso10126) return padIso10126$1.exports;
        hasRequiredPadIso10126 = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(padIso10126, function(CryptoJS) {
            CryptoJS.pad.Iso10126 = {
              pad: function(data, blockSize) {
                var blockSizeBytes = blockSize * 4;
                var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
              },
              unpad: function(data) {
                var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                data.sigBytes -= nPaddingBytes;
              }
            };
            return CryptoJS.pad.Iso10126;
          });
        })(padIso10126$1, padIso10126$1.exports);
        return padIso10126$1.exports;
      }
      var padIso97971$1 = { exports: {} };
      var padIso97971 = padIso97971$1.exports;
      var hasRequiredPadIso97971;
      function requirePadIso97971() {
        if (hasRequiredPadIso97971) return padIso97971$1.exports;
        hasRequiredPadIso97971 = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(padIso97971, function(CryptoJS) {
            CryptoJS.pad.Iso97971 = {
              pad: function(data, blockSize) {
                data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
                CryptoJS.pad.ZeroPadding.pad(data, blockSize);
              },
              unpad: function(data) {
                CryptoJS.pad.ZeroPadding.unpad(data);
                data.sigBytes--;
              }
            };
            return CryptoJS.pad.Iso97971;
          });
        })(padIso97971$1, padIso97971$1.exports);
        return padIso97971$1.exports;
      }
      var padZeropadding$1 = { exports: {} };
      var padZeropadding = padZeropadding$1.exports;
      var hasRequiredPadZeropadding;
      function requirePadZeropadding() {
        if (hasRequiredPadZeropadding) return padZeropadding$1.exports;
        hasRequiredPadZeropadding = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(padZeropadding, function(CryptoJS) {
            CryptoJS.pad.ZeroPadding = {
              pad: function(data, blockSize) {
                var blockSizeBytes = blockSize * 4;
                data.clamp();
                data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
              },
              unpad: function(data) {
                var dataWords = data.words;
                var i = data.sigBytes - 1;
                for (var i = data.sigBytes - 1; i >= 0; i--) {
                  if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
                    data.sigBytes = i + 1;
                    break;
                  }
                }
              }
            };
            return CryptoJS.pad.ZeroPadding;
          });
        })(padZeropadding$1, padZeropadding$1.exports);
        return padZeropadding$1.exports;
      }
      var padNopadding$1 = { exports: {} };
      var padNopadding = padNopadding$1.exports;
      var hasRequiredPadNopadding;
      function requirePadNopadding() {
        if (hasRequiredPadNopadding) return padNopadding$1.exports;
        hasRequiredPadNopadding = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(padNopadding, function(CryptoJS) {
            CryptoJS.pad.NoPadding = {
              pad: function() {
              },
              unpad: function() {
              }
            };
            return CryptoJS.pad.NoPadding;
          });
        })(padNopadding$1, padNopadding$1.exports);
        return padNopadding$1.exports;
      }
      var formatHex$1 = { exports: {} };
      var formatHex = formatHex$1.exports;
      var hasRequiredFormatHex;
      function requireFormatHex() {
        if (hasRequiredFormatHex) return formatHex$1.exports;
        hasRequiredFormatHex = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireCipherCore());
            }
          })(formatHex, function(CryptoJS) {
            (function(undefined$1) {
              var C = CryptoJS;
              var C_lib = C.lib;
              var CipherParams = C_lib.CipherParams;
              var C_enc = C.enc;
              var Hex = C_enc.Hex;
              var C_format = C.format;
              C_format.Hex = {
                /**
                 * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
                 *
                 * @param {CipherParams} cipherParams The cipher params object.
                 *
                 * @return {string} The hexadecimally encoded string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
                 */
                stringify: function(cipherParams) {
                  return cipherParams.ciphertext.toString(Hex);
                },
                /**
                 * Converts a hexadecimally encoded ciphertext string to a cipher params object.
                 *
                 * @param {string} input The hexadecimally encoded string.
                 *
                 * @return {CipherParams} The cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
                 */
                parse: function(input) {
                  var ciphertext = Hex.parse(input);
                  return CipherParams.create({
                    ciphertext
                  });
                }
              };
            })();
            return CryptoJS.format.Hex;
          });
        })(formatHex$1, formatHex$1.exports);
        return formatHex$1.exports;
      }
      var aes$1 = { exports: {} };
      var aes = aes$1.exports;
      var hasRequiredAes;
      function requireAes() {
        if (hasRequiredAes) return aes$1.exports;
        hasRequiredAes = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
            }
          })(aes, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var BlockCipher = C_lib.BlockCipher;
              var C_algo = C.algo;
              var SBOX = [];
              var INV_SBOX = [];
              var SUB_MIX_0 = [];
              var SUB_MIX_1 = [];
              var SUB_MIX_2 = [];
              var SUB_MIX_3 = [];
              var INV_SUB_MIX_0 = [];
              var INV_SUB_MIX_1 = [];
              var INV_SUB_MIX_2 = [];
              var INV_SUB_MIX_3 = [];
              (function() {
                var d = [];
                for (var i = 0; i < 256; i++) {
                  if (i < 128) {
                    d[i] = i << 1;
                  } else {
                    d[i] = i << 1 ^ 283;
                  }
                }
                var x = 0;
                var xi = 0;
                for (var i = 0; i < 256; i++) {
                  var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                  sx = sx >>> 8 ^ sx & 255 ^ 99;
                  SBOX[x] = sx;
                  INV_SBOX[sx] = x;
                  var x2 = d[x];
                  var x4 = d[x2];
                  var x8 = d[x4];
                  var t = d[sx] * 257 ^ sx * 16843008;
                  SUB_MIX_0[x] = t << 24 | t >>> 8;
                  SUB_MIX_1[x] = t << 16 | t >>> 16;
                  SUB_MIX_2[x] = t << 8 | t >>> 24;
                  SUB_MIX_3[x] = t;
                  var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
                  INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
                  INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
                  INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
                  INV_SUB_MIX_3[sx] = t;
                  if (!x) {
                    x = xi = 1;
                  } else {
                    x = x2 ^ d[d[d[x8 ^ x2]]];
                    xi ^= d[d[xi]];
                  }
                }
              })();
              var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
              var AES = C_algo.AES = BlockCipher.extend({
                _doReset: function() {
                  var t;
                  if (this._nRounds && this._keyPriorReset === this._key) {
                    return;
                  }
                  var key = this._keyPriorReset = this._key;
                  var keyWords = key.words;
                  var keySize = key.sigBytes / 4;
                  var nRounds = this._nRounds = keySize + 6;
                  var ksRows = (nRounds + 1) * 4;
                  var keySchedule = this._keySchedule = [];
                  for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                    if (ksRow < keySize) {
                      keySchedule[ksRow] = keyWords[ksRow];
                    } else {
                      t = keySchedule[ksRow - 1];
                      if (!(ksRow % keySize)) {
                        t = t << 8 | t >>> 24;
                        t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                        t ^= RCON[ksRow / keySize | 0] << 24;
                      } else if (keySize > 6 && ksRow % keySize == 4) {
                        t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                      }
                      keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                    }
                  }
                  var invKeySchedule = this._invKeySchedule = [];
                  for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                    var ksRow = ksRows - invKsRow;
                    if (invKsRow % 4) {
                      var t = keySchedule[ksRow];
                    } else {
                      var t = keySchedule[ksRow - 4];
                    }
                    if (invKsRow < 4 || ksRow <= 4) {
                      invKeySchedule[invKsRow] = t;
                    } else {
                      invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
                    }
                  }
                },
                encryptBlock: function(M, offset) {
                  this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
                },
                decryptBlock: function(M, offset) {
                  var t = M[offset + 1];
                  M[offset + 1] = M[offset + 3];
                  M[offset + 3] = t;
                  this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
                  var t = M[offset + 1];
                  M[offset + 1] = M[offset + 3];
                  M[offset + 3] = t;
                },
                _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
                  var nRounds = this._nRounds;
                  var s0 = M[offset] ^ keySchedule[0];
                  var s1 = M[offset + 1] ^ keySchedule[1];
                  var s2 = M[offset + 2] ^ keySchedule[2];
                  var s3 = M[offset + 3] ^ keySchedule[3];
                  var ksRow = 4;
                  for (var round = 1; round < nRounds; round++) {
                    var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
                    var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                    var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                    var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
                    s0 = t0;
                    s1 = t1;
                    s2 = t2;
                    s3 = t3;
                  }
                  var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
                  var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
                  var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
                  var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
                  M[offset] = t0;
                  M[offset + 1] = t1;
                  M[offset + 2] = t2;
                  M[offset + 3] = t3;
                },
                keySize: 256 / 32
              });
              C.AES = BlockCipher._createHelper(AES);
            })();
            return CryptoJS.AES;
          });
        })(aes$1, aes$1.exports);
        return aes$1.exports;
      }
      var tripledes$1 = { exports: {} };
      var tripledes = tripledes$1.exports;
      var hasRequiredTripledes;
      function requireTripledes() {
        if (hasRequiredTripledes) return tripledes$1.exports;
        hasRequiredTripledes = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
            }
          })(tripledes, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var BlockCipher = C_lib.BlockCipher;
              var C_algo = C.algo;
              var PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4];
              var PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32];
              var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
              var SBOX_P = [{
                0: 8421888,
                268435456: 32768,
                536870912: 8421378,
                805306368: 2,
                1073741824: 512,
                1342177280: 8421890,
                1610612736: 8389122,
                1879048192: 8388608,
                2147483648: 514,
                2415919104: 8389120,
                2684354560: 33280,
                2952790016: 8421376,
                3221225472: 32770,
                3489660928: 8388610,
                3758096384: 0,
                4026531840: 33282,
                134217728: 0,
                402653184: 8421890,
                671088640: 33282,
                939524096: 32768,
                1207959552: 8421888,
                1476395008: 512,
                1744830464: 8421378,
                2013265920: 2,
                2281701376: 8389120,
                2550136832: 33280,
                2818572288: 8421376,
                3087007744: 8389122,
                3355443200: 8388610,
                3623878656: 32770,
                3892314112: 514,
                4160749568: 8388608,
                1: 32768,
                268435457: 2,
                536870913: 8421888,
                805306369: 8388608,
                1073741825: 8421378,
                1342177281: 33280,
                1610612737: 512,
                1879048193: 8389122,
                2147483649: 8421890,
                2415919105: 8421376,
                2684354561: 8388610,
                2952790017: 33282,
                3221225473: 514,
                3489660929: 8389120,
                3758096385: 32770,
                4026531841: 0,
                134217729: 8421890,
                402653185: 8421376,
                671088641: 8388608,
                939524097: 512,
                1207959553: 32768,
                1476395009: 8388610,
                1744830465: 2,
                2013265921: 33282,
                2281701377: 32770,
                2550136833: 8389122,
                2818572289: 514,
                3087007745: 8421888,
                3355443201: 8389120,
                3623878657: 0,
                3892314113: 33280,
                4160749569: 8421378
              }, {
                0: 1074282512,
                16777216: 16384,
                33554432: 524288,
                50331648: 1074266128,
                67108864: 1073741840,
                83886080: 1074282496,
                100663296: 1073758208,
                117440512: 16,
                134217728: 540672,
                150994944: 1073758224,
                167772160: 1073741824,
                184549376: 540688,
                201326592: 524304,
                218103808: 0,
                234881024: 16400,
                251658240: 1074266112,
                8388608: 1073758208,
                25165824: 540688,
                41943040: 16,
                58720256: 1073758224,
                75497472: 1074282512,
                92274688: 1073741824,
                109051904: 524288,
                125829120: 1074266128,
                142606336: 524304,
                159383552: 0,
                176160768: 16384,
                192937984: 1074266112,
                209715200: 1073741840,
                226492416: 540672,
                243269632: 1074282496,
                260046848: 16400,
                268435456: 0,
                285212672: 1074266128,
                301989888: 1073758224,
                318767104: 1074282496,
                335544320: 1074266112,
                352321536: 16,
                369098752: 540688,
                385875968: 16384,
                402653184: 16400,
                419430400: 524288,
                436207616: 524304,
                452984832: 1073741840,
                469762048: 540672,
                486539264: 1073758208,
                503316480: 1073741824,
                520093696: 1074282512,
                276824064: 540688,
                293601280: 524288,
                310378496: 1074266112,
                327155712: 16384,
                343932928: 1073758208,
                360710144: 1074282512,
                377487360: 16,
                394264576: 1073741824,
                411041792: 1074282496,
                427819008: 1073741840,
                444596224: 1073758224,
                461373440: 524304,
                478150656: 0,
                494927872: 16400,
                511705088: 1074266128,
                528482304: 540672
              }, {
                0: 260,
                1048576: 0,
                2097152: 67109120,
                3145728: 65796,
                4194304: 65540,
                5242880: 67108868,
                6291456: 67174660,
                7340032: 67174400,
                8388608: 67108864,
                9437184: 67174656,
                10485760: 65792,
                11534336: 67174404,
                12582912: 67109124,
                13631488: 65536,
                14680064: 4,
                15728640: 256,
                524288: 67174656,
                1572864: 67174404,
                2621440: 0,
                3670016: 67109120,
                4718592: 67108868,
                5767168: 65536,
                6815744: 65540,
                7864320: 260,
                8912896: 4,
                9961472: 256,
                11010048: 67174400,
                12058624: 65796,
                13107200: 65792,
                14155776: 67109124,
                15204352: 67174660,
                16252928: 67108864,
                16777216: 67174656,
                17825792: 65540,
                18874368: 65536,
                19922944: 67109120,
                20971520: 256,
                22020096: 67174660,
                23068672: 67108868,
                24117248: 0,
                25165824: 67109124,
                26214400: 67108864,
                27262976: 4,
                28311552: 65792,
                29360128: 67174400,
                30408704: 260,
                31457280: 65796,
                32505856: 67174404,
                17301504: 67108864,
                18350080: 260,
                19398656: 67174656,
                20447232: 0,
                21495808: 65540,
                22544384: 67109120,
                23592960: 256,
                24641536: 67174404,
                25690112: 65536,
                26738688: 67174660,
                27787264: 65796,
                28835840: 67108868,
                29884416: 67109124,
                30932992: 67174400,
                31981568: 4,
                33030144: 65792
              }, {
                0: 2151682048,
                65536: 2147487808,
                131072: 4198464,
                196608: 2151677952,
                262144: 0,
                327680: 4198400,
                393216: 2147483712,
                458752: 4194368,
                524288: 2147483648,
                589824: 4194304,
                655360: 64,
                720896: 2147487744,
                786432: 2151678016,
                851968: 4160,
                917504: 4096,
                983040: 2151682112,
                32768: 2147487808,
                98304: 64,
                163840: 2151678016,
                229376: 2147487744,
                294912: 4198400,
                360448: 2151682112,
                425984: 0,
                491520: 2151677952,
                557056: 4096,
                622592: 2151682048,
                688128: 4194304,
                753664: 4160,
                819200: 2147483648,
                884736: 4194368,
                950272: 4198464,
                1015808: 2147483712,
                1048576: 4194368,
                1114112: 4198400,
                1179648: 2147483712,
                1245184: 0,
                1310720: 4160,
                1376256: 2151678016,
                1441792: 2151682048,
                1507328: 2147487808,
                1572864: 2151682112,
                1638400: 2147483648,
                1703936: 2151677952,
                1769472: 4198464,
                1835008: 2147487744,
                1900544: 4194304,
                1966080: 64,
                2031616: 4096,
                1081344: 2151677952,
                1146880: 2151682112,
                1212416: 0,
                1277952: 4198400,
                1343488: 4194368,
                1409024: 2147483648,
                1474560: 2147487808,
                1540096: 64,
                1605632: 2147483712,
                1671168: 4096,
                1736704: 2147487744,
                1802240: 2151678016,
                1867776: 4160,
                1933312: 2151682048,
                1998848: 4194304,
                2064384: 4198464
              }, {
                0: 128,
                4096: 17039360,
                8192: 262144,
                12288: 536870912,
                16384: 537133184,
                20480: 16777344,
                24576: 553648256,
                28672: 262272,
                32768: 16777216,
                36864: 537133056,
                40960: 536871040,
                45056: 553910400,
                49152: 553910272,
                53248: 0,
                57344: 17039488,
                61440: 553648128,
                2048: 17039488,
                6144: 553648256,
                10240: 128,
                14336: 17039360,
                18432: 262144,
                22528: 537133184,
                26624: 553910272,
                30720: 536870912,
                34816: 537133056,
                38912: 0,
                43008: 553910400,
                47104: 16777344,
                51200: 536871040,
                55296: 553648128,
                59392: 16777216,
                63488: 262272,
                65536: 262144,
                69632: 128,
                73728: 536870912,
                77824: 553648256,
                81920: 16777344,
                86016: 553910272,
                90112: 537133184,
                94208: 16777216,
                98304: 553910400,
                102400: 553648128,
                106496: 17039360,
                110592: 537133056,
                114688: 262272,
                118784: 536871040,
                122880: 0,
                126976: 17039488,
                67584: 553648256,
                71680: 16777216,
                75776: 17039360,
                79872: 537133184,
                83968: 536870912,
                88064: 17039488,
                92160: 128,
                96256: 553910272,
                100352: 262272,
                104448: 553910400,
                108544: 0,
                112640: 553648128,
                116736: 16777344,
                120832: 262144,
                124928: 537133056,
                129024: 536871040
              }, {
                0: 268435464,
                256: 8192,
                512: 270532608,
                768: 270540808,
                1024: 268443648,
                1280: 2097152,
                1536: 2097160,
                1792: 268435456,
                2048: 0,
                2304: 268443656,
                2560: 2105344,
                2816: 8,
                3072: 270532616,
                3328: 2105352,
                3584: 8200,
                3840: 270540800,
                128: 270532608,
                384: 270540808,
                640: 8,
                896: 2097152,
                1152: 2105352,
                1408: 268435464,
                1664: 268443648,
                1920: 8200,
                2176: 2097160,
                2432: 8192,
                2688: 268443656,
                2944: 270532616,
                3200: 0,
                3456: 270540800,
                3712: 2105344,
                3968: 268435456,
                4096: 268443648,
                4352: 270532616,
                4608: 270540808,
                4864: 8200,
                5120: 2097152,
                5376: 268435456,
                5632: 268435464,
                5888: 2105344,
                6144: 2105352,
                6400: 0,
                6656: 8,
                6912: 270532608,
                7168: 8192,
                7424: 268443656,
                7680: 270540800,
                7936: 2097160,
                4224: 8,
                4480: 2105344,
                4736: 2097152,
                4992: 268435464,
                5248: 268443648,
                5504: 8200,
                5760: 270540808,
                6016: 270532608,
                6272: 270540800,
                6528: 270532616,
                6784: 8192,
                7040: 2105352,
                7296: 2097160,
                7552: 0,
                7808: 268435456,
                8064: 268443656
              }, {
                0: 1048576,
                16: 33555457,
                32: 1024,
                48: 1049601,
                64: 34604033,
                80: 0,
                96: 1,
                112: 34603009,
                128: 33555456,
                144: 1048577,
                160: 33554433,
                176: 34604032,
                192: 34603008,
                208: 1025,
                224: 1049600,
                240: 33554432,
                8: 34603009,
                24: 0,
                40: 33555457,
                56: 34604032,
                72: 1048576,
                88: 33554433,
                104: 33554432,
                120: 1025,
                136: 1049601,
                152: 33555456,
                168: 34603008,
                184: 1048577,
                200: 1024,
                216: 34604033,
                232: 1,
                248: 1049600,
                256: 33554432,
                272: 1048576,
                288: 33555457,
                304: 34603009,
                320: 1048577,
                336: 33555456,
                352: 34604032,
                368: 1049601,
                384: 1025,
                400: 34604033,
                416: 1049600,
                432: 1,
                448: 0,
                464: 34603008,
                480: 33554433,
                496: 1024,
                264: 1049600,
                280: 33555457,
                296: 34603009,
                312: 1,
                328: 33554432,
                344: 1048576,
                360: 1025,
                376: 34604032,
                392: 33554433,
                408: 34603008,
                424: 0,
                440: 34604033,
                456: 1049601,
                472: 1024,
                488: 33555456,
                504: 1048577
              }, {
                0: 134219808,
                1: 131072,
                2: 134217728,
                3: 32,
                4: 131104,
                5: 134350880,
                6: 134350848,
                7: 2048,
                8: 134348800,
                9: 134219776,
                10: 133120,
                11: 134348832,
                12: 2080,
                13: 0,
                14: 134217760,
                15: 133152,
                2147483648: 2048,
                2147483649: 134350880,
                2147483650: 134219808,
                2147483651: 134217728,
                2147483652: 134348800,
                2147483653: 133120,
                2147483654: 133152,
                2147483655: 32,
                2147483656: 134217760,
                2147483657: 2080,
                2147483658: 131104,
                2147483659: 134350848,
                2147483660: 0,
                2147483661: 134348832,
                2147483662: 134219776,
                2147483663: 131072,
                16: 133152,
                17: 134350848,
                18: 32,
                19: 2048,
                20: 134219776,
                21: 134217760,
                22: 134348832,
                23: 131072,
                24: 0,
                25: 131104,
                26: 134348800,
                27: 134219808,
                28: 134350880,
                29: 133120,
                30: 2080,
                31: 134217728,
                2147483664: 131072,
                2147483665: 2048,
                2147483666: 134348832,
                2147483667: 133152,
                2147483668: 32,
                2147483669: 134348800,
                2147483670: 134217728,
                2147483671: 134219808,
                2147483672: 134350880,
                2147483673: 134217760,
                2147483674: 134219776,
                2147483675: 0,
                2147483676: 133120,
                2147483677: 2080,
                2147483678: 131104,
                2147483679: 134350848
              }];
              var SBOX_MASK = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679];
              var DES = C_algo.DES = BlockCipher.extend({
                _doReset: function() {
                  var key = this._key;
                  var keyWords = key.words;
                  var keyBits = [];
                  for (var i = 0; i < 56; i++) {
                    var keyBitPos = PC1[i] - 1;
                    keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
                  }
                  var subKeys = this._subKeys = [];
                  for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                    var subKey = subKeys[nSubKey] = [];
                    var bitShift = BIT_SHIFTS[nSubKey];
                    for (var i = 0; i < 24; i++) {
                      subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                      subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
                    }
                    subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                    for (var i = 1; i < 7; i++) {
                      subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
                    }
                    subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
                  }
                  var invSubKeys = this._invSubKeys = [];
                  for (var i = 0; i < 16; i++) {
                    invSubKeys[i] = subKeys[15 - i];
                  }
                },
                encryptBlock: function(M, offset) {
                  this._doCryptBlock(M, offset, this._subKeys);
                },
                decryptBlock: function(M, offset) {
                  this._doCryptBlock(M, offset, this._invSubKeys);
                },
                _doCryptBlock: function(M, offset, subKeys) {
                  this._lBlock = M[offset];
                  this._rBlock = M[offset + 1];
                  exchangeLR.call(this, 4, 252645135);
                  exchangeLR.call(this, 16, 65535);
                  exchangeRL.call(this, 2, 858993459);
                  exchangeRL.call(this, 8, 16711935);
                  exchangeLR.call(this, 1, 1431655765);
                  for (var round = 0; round < 16; round++) {
                    var subKey = subKeys[round];
                    var lBlock = this._lBlock;
                    var rBlock = this._rBlock;
                    var f = 0;
                    for (var i = 0; i < 8; i++) {
                      f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                    }
                    this._lBlock = rBlock;
                    this._rBlock = lBlock ^ f;
                  }
                  var t = this._lBlock;
                  this._lBlock = this._rBlock;
                  this._rBlock = t;
                  exchangeLR.call(this, 1, 1431655765);
                  exchangeRL.call(this, 8, 16711935);
                  exchangeRL.call(this, 2, 858993459);
                  exchangeLR.call(this, 16, 65535);
                  exchangeLR.call(this, 4, 252645135);
                  M[offset] = this._lBlock;
                  M[offset + 1] = this._rBlock;
                },
                keySize: 64 / 32,
                ivSize: 64 / 32,
                blockSize: 64 / 32
              });
              function exchangeLR(offset, mask) {
                var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
                this._rBlock ^= t;
                this._lBlock ^= t << offset;
              }
              function exchangeRL(offset, mask) {
                var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
                this._lBlock ^= t;
                this._rBlock ^= t << offset;
              }
              C.DES = BlockCipher._createHelper(DES);
              var TripleDES = C_algo.TripleDES = BlockCipher.extend({
                _doReset: function() {
                  var key = this._key;
                  var keyWords = key.words;
                  if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                    throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                  }
                  var key1 = keyWords.slice(0, 2);
                  var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
                  var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
                  this._des1 = DES.createEncryptor(WordArray.create(key1));
                  this._des2 = DES.createEncryptor(WordArray.create(key2));
                  this._des3 = DES.createEncryptor(WordArray.create(key3));
                },
                encryptBlock: function(M, offset) {
                  this._des1.encryptBlock(M, offset);
                  this._des2.decryptBlock(M, offset);
                  this._des3.encryptBlock(M, offset);
                },
                decryptBlock: function(M, offset) {
                  this._des3.decryptBlock(M, offset);
                  this._des2.encryptBlock(M, offset);
                  this._des1.decryptBlock(M, offset);
                },
                keySize: 192 / 32,
                ivSize: 64 / 32,
                blockSize: 64 / 32
              });
              C.TripleDES = BlockCipher._createHelper(TripleDES);
            })();
            return CryptoJS.TripleDES;
          });
        })(tripledes$1, tripledes$1.exports);
        return tripledes$1.exports;
      }
      var rc4$1 = { exports: {} };
      var rc4 = rc4$1.exports;
      var hasRequiredRc4;
      function requireRc4() {
        if (hasRequiredRc4) return rc4$1.exports;
        hasRequiredRc4 = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
            }
          })(rc4, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var StreamCipher = C_lib.StreamCipher;
              var C_algo = C.algo;
              var RC4 = C_algo.RC4 = StreamCipher.extend({
                _doReset: function() {
                  var key = this._key;
                  var keyWords = key.words;
                  var keySigBytes = key.sigBytes;
                  var S = this._S = [];
                  for (var i = 0; i < 256; i++) {
                    S[i] = i;
                  }
                  for (var i = 0, j = 0; i < 256; i++) {
                    var keyByteIndex = i % keySigBytes;
                    var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                    j = (j + S[i] + keyByte) % 256;
                    var t = S[i];
                    S[i] = S[j];
                    S[j] = t;
                  }
                  this._i = this._j = 0;
                },
                _doProcessBlock: function(M, offset) {
                  M[offset] ^= generateKeystreamWord.call(this);
                },
                keySize: 256 / 32,
                ivSize: 0
              });
              function generateKeystreamWord() {
                var S = this._S;
                var i = this._i;
                var j = this._j;
                var keystreamWord = 0;
                for (var n = 0; n < 4; n++) {
                  i = (i + 1) % 256;
                  j = (j + S[i]) % 256;
                  var t = S[i];
                  S[i] = S[j];
                  S[j] = t;
                  keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
                }
                this._i = i;
                this._j = j;
                return keystreamWord;
              }
              C.RC4 = StreamCipher._createHelper(RC4);
              var RC4Drop = C_algo.RC4Drop = RC4.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} drop The number of keystream words to drop. Default 192
                 */
                cfg: RC4.cfg.extend({
                  drop: 192
                }),
                _doReset: function() {
                  RC4._doReset.call(this);
                  for (var i = this.cfg.drop; i > 0; i--) {
                    generateKeystreamWord.call(this);
                  }
                }
              });
              C.RC4Drop = StreamCipher._createHelper(RC4Drop);
            })();
            return CryptoJS.RC4;
          });
        })(rc4$1, rc4$1.exports);
        return rc4$1.exports;
      }
      var rabbit$1 = { exports: {} };
      var rabbit = rabbit$1.exports;
      var hasRequiredRabbit;
      function requireRabbit() {
        if (hasRequiredRabbit) return rabbit$1.exports;
        hasRequiredRabbit = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
            }
          })(rabbit, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var StreamCipher = C_lib.StreamCipher;
              var C_algo = C.algo;
              var S = [];
              var C_ = [];
              var G = [];
              var Rabbit = C_algo.Rabbit = StreamCipher.extend({
                _doReset: function() {
                  var K = this._key.words;
                  var iv = this.cfg.iv;
                  for (var i = 0; i < 4; i++) {
                    K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
                  }
                  var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];
                  var C2 = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 4294901760 | K[1] & 65535, K[3] << 16 | K[3] >>> 16, K[1] & 4294901760 | K[2] & 65535, K[0] << 16 | K[0] >>> 16, K[2] & 4294901760 | K[3] & 65535, K[1] << 16 | K[1] >>> 16, K[3] & 4294901760 | K[0] & 65535];
                  this._b = 0;
                  for (var i = 0; i < 4; i++) {
                    nextState.call(this);
                  }
                  for (var i = 0; i < 8; i++) {
                    C2[i] ^= X[i + 4 & 7];
                  }
                  if (iv) {
                    var IV = iv.words;
                    var IV_0 = IV[0];
                    var IV_1 = IV[1];
                    var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                    var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                    var i1 = i0 >>> 16 | i2 & 4294901760;
                    var i3 = i2 << 16 | i0 & 65535;
                    C2[0] ^= i0;
                    C2[1] ^= i1;
                    C2[2] ^= i2;
                    C2[3] ^= i3;
                    C2[4] ^= i0;
                    C2[5] ^= i1;
                    C2[6] ^= i2;
                    C2[7] ^= i3;
                    for (var i = 0; i < 4; i++) {
                      nextState.call(this);
                    }
                  }
                },
                _doProcessBlock: function(M, offset) {
                  var X = this._X;
                  nextState.call(this);
                  S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                  S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                  S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                  S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                  for (var i = 0; i < 4; i++) {
                    S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                    M[offset + i] ^= S[i];
                  }
                },
                blockSize: 128 / 32,
                ivSize: 64 / 32
              });
              function nextState() {
                var X = this._X;
                var C2 = this._C;
                for (var i = 0; i < 8; i++) {
                  C_[i] = C2[i];
                }
                C2[0] = C2[0] + 1295307597 + this._b | 0;
                C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
                C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
                C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
                C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
                C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
                C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
                C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
                this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
                for (var i = 0; i < 8; i++) {
                  var gx = X[i] + C2[i];
                  var ga = gx & 65535;
                  var gb = gx >>> 16;
                  var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                  var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                  G[i] = gh ^ gl;
                }
                X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
                X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
                X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
                X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
                X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
                X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
                X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
                X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
              }
              C.Rabbit = StreamCipher._createHelper(Rabbit);
            })();
            return CryptoJS.Rabbit;
          });
        })(rabbit$1, rabbit$1.exports);
        return rabbit$1.exports;
      }
      var rabbitLegacy$1 = { exports: {} };
      var rabbitLegacy = rabbitLegacy$1.exports;
      var hasRequiredRabbitLegacy;
      function requireRabbitLegacy() {
        if (hasRequiredRabbitLegacy) return rabbitLegacy$1.exports;
        hasRequiredRabbitLegacy = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
            }
          })(rabbitLegacy, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var StreamCipher = C_lib.StreamCipher;
              var C_algo = C.algo;
              var S = [];
              var C_ = [];
              var G = [];
              var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
                _doReset: function() {
                  var K = this._key.words;
                  var iv = this.cfg.iv;
                  var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];
                  var C2 = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 4294901760 | K[1] & 65535, K[3] << 16 | K[3] >>> 16, K[1] & 4294901760 | K[2] & 65535, K[0] << 16 | K[0] >>> 16, K[2] & 4294901760 | K[3] & 65535, K[1] << 16 | K[1] >>> 16, K[3] & 4294901760 | K[0] & 65535];
                  this._b = 0;
                  for (var i = 0; i < 4; i++) {
                    nextState.call(this);
                  }
                  for (var i = 0; i < 8; i++) {
                    C2[i] ^= X[i + 4 & 7];
                  }
                  if (iv) {
                    var IV = iv.words;
                    var IV_0 = IV[0];
                    var IV_1 = IV[1];
                    var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                    var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                    var i1 = i0 >>> 16 | i2 & 4294901760;
                    var i3 = i2 << 16 | i0 & 65535;
                    C2[0] ^= i0;
                    C2[1] ^= i1;
                    C2[2] ^= i2;
                    C2[3] ^= i3;
                    C2[4] ^= i0;
                    C2[5] ^= i1;
                    C2[6] ^= i2;
                    C2[7] ^= i3;
                    for (var i = 0; i < 4; i++) {
                      nextState.call(this);
                    }
                  }
                },
                _doProcessBlock: function(M, offset) {
                  var X = this._X;
                  nextState.call(this);
                  S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                  S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                  S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                  S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                  for (var i = 0; i < 4; i++) {
                    S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                    M[offset + i] ^= S[i];
                  }
                },
                blockSize: 128 / 32,
                ivSize: 64 / 32
              });
              function nextState() {
                var X = this._X;
                var C2 = this._C;
                for (var i = 0; i < 8; i++) {
                  C_[i] = C2[i];
                }
                C2[0] = C2[0] + 1295307597 + this._b | 0;
                C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
                C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
                C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
                C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
                C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
                C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
                C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
                this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
                for (var i = 0; i < 8; i++) {
                  var gx = X[i] + C2[i];
                  var ga = gx & 65535;
                  var gb = gx >>> 16;
                  var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                  var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                  G[i] = gh ^ gl;
                }
                X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
                X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
                X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
                X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
                X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
                X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
                X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
                X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
              }
              C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
            })();
            return CryptoJS.RabbitLegacy;
          });
        })(rabbitLegacy$1, rabbitLegacy$1.exports);
        return rabbitLegacy$1.exports;
      }
      var blowfish$1 = { exports: {} };
      var blowfish = blowfish$1.exports;
      var hasRequiredBlowfish;
      function requireBlowfish() {
        if (hasRequiredBlowfish) return blowfish$1.exports;
        hasRequiredBlowfish = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
            }
          })(blowfish, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var BlockCipher = C_lib.BlockCipher;
              var C_algo = C.algo;
              const N = 16;
              const ORIG_P = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731];
              const ORIG_S = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]];
              var BLOWFISH_CTX = {
                pbox: [],
                sbox: []
              };
              function F(ctx, x) {
                let a = x >> 24 & 255;
                let b = x >> 16 & 255;
                let c = x >> 8 & 255;
                let d = x & 255;
                let y = ctx.sbox[0][a] + ctx.sbox[1][b];
                y = y ^ ctx.sbox[2][c];
                y = y + ctx.sbox[3][d];
                return y;
              }
              function BlowFish_Encrypt(ctx, left, right) {
                let Xl = left;
                let Xr = right;
                let temp;
                for (let i = 0; i < N; ++i) {
                  Xl = Xl ^ ctx.pbox[i];
                  Xr = F(ctx, Xl) ^ Xr;
                  temp = Xl;
                  Xl = Xr;
                  Xr = temp;
                }
                temp = Xl;
                Xl = Xr;
                Xr = temp;
                Xr = Xr ^ ctx.pbox[N];
                Xl = Xl ^ ctx.pbox[N + 1];
                return {
                  left: Xl,
                  right: Xr
                };
              }
              function BlowFish_Decrypt(ctx, left, right) {
                let Xl = left;
                let Xr = right;
                let temp;
                for (let i = N + 1; i > 1; --i) {
                  Xl = Xl ^ ctx.pbox[i];
                  Xr = F(ctx, Xl) ^ Xr;
                  temp = Xl;
                  Xl = Xr;
                  Xr = temp;
                }
                temp = Xl;
                Xl = Xr;
                Xr = temp;
                Xr = Xr ^ ctx.pbox[1];
                Xl = Xl ^ ctx.pbox[0];
                return {
                  left: Xl,
                  right: Xr
                };
              }
              function BlowFishInit(ctx, key, keysize) {
                for (let Row = 0; Row < 4; Row++) {
                  ctx.sbox[Row] = [];
                  for (let Col = 0; Col < 256; Col++) {
                    ctx.sbox[Row][Col] = ORIG_S[Row][Col];
                  }
                }
                let keyIndex = 0;
                for (let index = 0; index < N + 2; index++) {
                  ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
                  keyIndex++;
                  if (keyIndex >= keysize) {
                    keyIndex = 0;
                  }
                }
                let Data1 = 0;
                let Data2 = 0;
                let res = 0;
                for (let i = 0; i < N + 2; i += 2) {
                  res = BlowFish_Encrypt(ctx, Data1, Data2);
                  Data1 = res.left;
                  Data2 = res.right;
                  ctx.pbox[i] = Data1;
                  ctx.pbox[i + 1] = Data2;
                }
                for (let i = 0; i < 4; i++) {
                  for (let j = 0; j < 256; j += 2) {
                    res = BlowFish_Encrypt(ctx, Data1, Data2);
                    Data1 = res.left;
                    Data2 = res.right;
                    ctx.sbox[i][j] = Data1;
                    ctx.sbox[i][j + 1] = Data2;
                  }
                }
                return true;
              }
              var Blowfish = C_algo.Blowfish = BlockCipher.extend({
                _doReset: function() {
                  if (this._keyPriorReset === this._key) {
                    return;
                  }
                  var key = this._keyPriorReset = this._key;
                  var keyWords = key.words;
                  var keySize = key.sigBytes / 4;
                  BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
                },
                encryptBlock: function(M, offset) {
                  var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
                  M[offset] = res.left;
                  M[offset + 1] = res.right;
                },
                decryptBlock: function(M, offset) {
                  var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
                  M[offset] = res.left;
                  M[offset + 1] = res.right;
                },
                blockSize: 64 / 32,
                keySize: 128 / 32,
                ivSize: 64 / 32
              });
              C.Blowfish = BlockCipher._createHelper(Blowfish);
            })();
            return CryptoJS.Blowfish;
          });
        })(blowfish$1, blowfish$1.exports);
        return blowfish$1.exports;
      }
      var cryptoJs = cryptoJs$1.exports;
      var hasRequiredCryptoJs;
      function requireCryptoJs() {
        if (hasRequiredCryptoJs) return cryptoJs$1.exports;
        hasRequiredCryptoJs = 1;
        (function(module2, exports2) {
          (function(root, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
            }
          })(cryptoJs, function(CryptoJS) {
            return CryptoJS;
          });
        })(cryptoJs$1, cryptoJs$1.exports);
        return cryptoJs$1.exports;
      }
      var cryptoJsExports = requireCryptoJs();
      var _key = _classPrivateFieldLooseKey("key");
      var _logger$b = _classPrivateFieldLooseKey("logger");
      var _encryptLocalStorage = _classPrivateFieldLooseKey("encryptLocalStorage");
      class Encryption {
        constructor() {
          Object.defineProperty(this, _key, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _logger$b, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _encryptLocalStorage, {
            writable: true,
            value: false
          });
        }
        set logger(classInstance) {
          _classPrivateFieldLooseBase(this, _logger$b)[_logger$b] = classInstance;
        }
        get logger() {
          return _classPrivateFieldLooseBase(this, _logger$b)[_logger$b];
        }
        set key(value) {
          _classPrivateFieldLooseBase(this, _key)[_key] = value;
        }
        get key() {
          return _classPrivateFieldLooseBase(this, _key)[_key];
        }
        set enableLocalStorageEncryption(value) {
          _classPrivateFieldLooseBase(this, _encryptLocalStorage)[_encryptLocalStorage] = value;
        }
        get enableLocalStorageEncryption() {
          return _classPrivateFieldLooseBase(this, _encryptLocalStorage)[_encryptLocalStorage];
        }
        shouldEncrypt(key) {
          return _classPrivateFieldLooseBase(this, _encryptLocalStorage)[_encryptLocalStorage] && KEYS_TO_ENCRYPT.includes(key);
        }
        // For backwards compatibility, we should decrypt even if encrypt is false.
        // This means someone switched it on and then off.
        shouldDecrypt(key) {
          return KEYS_TO_ENCRYPT.includes(key);
        }
        encrypt(data) {
          return cryptoJsExports.AES.encrypt(data, this.key).toString();
        }
        decrypt(data) {
          const decryptedData = cryptoJsExports.AES.decrypt(data, this.key).toString(cryptoJsExports.enc.Utf8);
          if (decryptedData === "") {
            return data;
          } else {
            return decryptedData;
          }
        }
      }
      const encryption = new Encryption();
      class StorageManager {
        static save(key, value) {
          if (!key || !value) {
            return false;
          }
          if (this._isLocalStorageSupported()) {
            if (encryption.shouldEncrypt(key)) {
              localStorage.setItem(key, encryption.encrypt(value));
              return true;
            }
            localStorage.setItem(key, typeof value === "string" ? value : JSON.stringify(value));
            return true;
          }
        }
        static read(key) {
          if (!key) {
            return false;
          }
          let data = null;
          if (this._isLocalStorageSupported()) {
            data = localStorage.getItem(key);
          }
          if (data != null) {
            try {
              if (encryption.shouldDecrypt(key)) {
                data = encryption.decrypt(data);
              }
              data = JSON.parse(data);
            } catch (e) {
            }
          }
          return data;
        }
        static remove(key) {
          if (!key) {
            return false;
          }
          if (this._isLocalStorageSupported()) {
            localStorage.removeItem(key);
            return true;
          }
        }
        static removeCookie(name, domain) {
          let cookieStr = name + "=; expires=Thu, 01 Jan 1970 00:00:01 GMT;";
          if (domain) {
            cookieStr = cookieStr + " domain=" + domain + "; path=/";
          }
          document.cookie = cookieStr;
        }
        static createCookie(name, value, seconds, domain) {
          let expires = "";
          let domainStr = "";
          if (seconds) {
            const date = /* @__PURE__ */ new Date();
            date.setTime(date.getTime() + seconds * 1e3);
            expires = "; expires=" + date.toGMTString();
          }
          if (domain) {
            domainStr = "; domain=" + domain;
          }
          value = encodeURIComponent(value);
          document.cookie = name + "=" + value + expires + domainStr + "; path=/";
        }
        static readCookie(name) {
          const nameEQ = name + "=";
          const ca = document.cookie.split(";");
          for (let idx = 0; idx < ca.length; idx++) {
            let c = ca[idx];
            while (c.charAt(0) === " ") {
              c = c.substring(1, c.length);
            }
            if (c.indexOf(nameEQ) == 0) {
              return decodeURIComponent(c.substring(nameEQ.length, c.length));
            }
          }
          return null;
        }
        static _isLocalStorageSupported() {
          return "localStorage" in window && window.localStorage !== null && typeof window.localStorage.setItem === "function";
        }
        static saveToLSorCookie(property, value) {
          if (value == null) {
            return;
          }
          try {
            if (this._isLocalStorageSupported()) {
              this.save(property, encodeURIComponent(JSON.stringify(value)));
            } else {
              if (property === GCOOKIE_NAME) {
                this.createCookie(property, encodeURIComponent(value), 0, window.location.hostname);
              } else {
                this.createCookie(property, encodeURIComponent(JSON.stringify(value)), 0, window.location.hostname);
              }
            }
            $ct.globalCache[property] = value;
          } catch (e) {
          }
        }
        static readFromLSorCookie(property) {
          let data;
          if ($ct.globalCache.hasOwnProperty(property)) {
            return $ct.globalCache[property];
          }
          if (this._isLocalStorageSupported()) {
            data = this.read(property);
          } else {
            data = this.readCookie(property);
          }
          if (data !== null && data !== void 0 && !(typeof data.trim === "function" && data.trim() === "")) {
            let value;
            try {
              value = JSON.parse(decodeURIComponent(data));
            } catch (err) {
              value = decodeURIComponent(data);
            }
            $ct.globalCache[property] = value;
            return value;
          }
        }
        static createBroadCookie(name, value, seconds, domain) {
          if (domain) {
            let broadDomain = $ct.broadDomain;
            if (broadDomain == null) {
              const domainParts = domain.split(".");
              let testBroadDomain = "";
              for (let idx = domainParts.length - 1; idx >= 0; idx--) {
                if (idx === 0) {
                  testBroadDomain = domainParts[idx] + testBroadDomain;
                } else {
                  testBroadDomain = "." + domainParts[idx] + testBroadDomain;
                }
                if (this.readCookie(name)) {
                  var testCookieName = "test_" + name + idx;
                  this.createCookie(testCookieName, value, 10, testBroadDomain);
                  if (!this.readCookie(testCookieName)) {
                    continue;
                  } else {
                    this.removeCookie(testCookieName, testBroadDomain);
                  }
                }
                this.createCookie(name, value, seconds, testBroadDomain);
                const tempCookie = this.readCookie(name);
                if (tempCookie == value) {
                  broadDomain = testBroadDomain;
                  $ct.broadDomain = broadDomain;
                  break;
                }
              }
            } else {
              this.createCookie(name, value, seconds, broadDomain);
            }
          } else {
            this.createCookie(name, value, seconds, domain);
          }
        }
        static getMetaProp(property) {
          const metaObj = this.readFromLSorCookie(META_COOKIE);
          if (metaObj != null) {
            return metaObj[property];
          }
        }
        static setMetaProp(property, value) {
          if (this._isLocalStorageSupported()) {
            let wzrkMetaObj = this.readFromLSorCookie(META_COOKIE);
            if (wzrkMetaObj == null) {
              wzrkMetaObj = {};
            }
            if (value === void 0) {
              delete wzrkMetaObj[property];
            } else {
              wzrkMetaObj[property] = value;
            }
            this.saveToLSorCookie(META_COOKIE, wzrkMetaObj);
          }
        }
        static getAndClearMetaProp(property) {
          const value = this.getMetaProp(property);
          this.setMetaProp(property, void 0);
          return value;
        }
        static setInstantDeleteFlagInK() {
          let k = this.readFromLSorCookie(KCOOKIE_NAME);
          if (k == null) {
            k = {};
          }
          k.flag = true;
          this.saveToLSorCookie(KCOOKIE_NAME, k);
        }
        static backupEvent(data, reqNo, logger2) {
          let backupArr = this.readFromLSorCookie(LCOOKIE_NAME);
          if (typeof backupArr === "undefined") {
            backupArr = {};
          }
          backupArr[reqNo] = {
            q: data
          };
          this.saveToLSorCookie(LCOOKIE_NAME, backupArr);
          logger2.debug("stored in ".concat(LCOOKIE_NAME, " reqNo : ").concat(reqNo, " -> ").concat(data));
        }
        static removeBackup(respNo, logger2) {
          const backupMap = this.readFromLSorCookie(LCOOKIE_NAME);
          if (typeof backupMap !== "undefined" && backupMap !== null && typeof backupMap[respNo] !== "undefined") {
            logger2.debug("del event: ".concat(respNo, " data-> ").concat(backupMap[respNo].q));
            delete backupMap[respNo];
            this.saveToLSorCookie(LCOOKIE_NAME, backupMap);
          }
        }
      }
      const $ct = {
        globalCache: {
          gcookie: null,
          REQ_N: 0,
          RESP_N: 0
        },
        LRU_CACHE: null,
        globalProfileMap: void 0,
        globalEventsMap: void 0,
        blockRequest: false,
        isOptInRequest: false,
        broadDomain: null,
        webPushEnabled: null,
        campaignDivMap: {},
        currentSessionId: null,
        wiz_counter: 0,
        // to keep track of number of times we load the body
        notifApi: {
          notifEnabledFromApi: false
        },
        // helper variable to handle race condition and check when notifications were called
        unsubGroups: [],
        updatedCategoryLong: null,
        inbox: null,
        isPrivacyArrPushed: false,
        privacyArray: [],
        offline: false,
        location: null,
        dismissSpamControl: false,
        globalUnsubscribe: true,
        flutterVersion: null,
        variableStore: {},
        pushConfig: null
        // domain: window.location.hostname, url -> getHostName()
        // gcookie: -> device
      };
      var _keyOrder = _classPrivateFieldLooseKey("keyOrder");
      var _deleteFromObject = _classPrivateFieldLooseKey("deleteFromObject");
      class LRUCache {
        constructor(max) {
          Object.defineProperty(this, _deleteFromObject, {
            value: _deleteFromObject2
          });
          Object.defineProperty(this, _keyOrder, {
            writable: true,
            value: void 0
          });
          this.max = max;
          let lruCache = StorageManager.readFromLSorCookie(LRU_CACHE);
          if (lruCache) {
            const tempLruCache = {};
            _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder] = [];
            lruCache = lruCache.cache;
            for (const entry in lruCache) {
              if (lruCache.hasOwnProperty(entry)) {
                tempLruCache[lruCache[entry][0]] = lruCache[entry][1];
                _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder].push(lruCache[entry][0]);
              }
            }
            this.cache = tempLruCache;
          } else {
            this.cache = {};
            _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder] = [];
          }
        }
        get(key) {
          const item = this.cache[key];
          if (item) {
            this.cache = _classPrivateFieldLooseBase(this, _deleteFromObject)[_deleteFromObject](key, this.cache);
            this.cache[key] = item;
            _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder].push(key);
          }
          this.saveCacheToLS(this.cache);
          return item;
        }
        set(key, value) {
          const item = this.cache[key];
          const allKeys = _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder];
          if (item != null) {
            this.cache = _classPrivateFieldLooseBase(this, _deleteFromObject)[_deleteFromObject](key, this.cache);
          } else if (allKeys.length === this.max) {
            this.cache = _classPrivateFieldLooseBase(this, _deleteFromObject)[_deleteFromObject](allKeys[0], this.cache);
          }
          this.cache[key] = value;
          if (_classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder][_classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder] - 1] !== key) {
            _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder].push(key);
          }
          this.saveCacheToLS(this.cache);
        }
        saveCacheToLS(cache) {
          const objToArray = [];
          const allKeys = _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder];
          for (const index in allKeys) {
            if (allKeys.hasOwnProperty(index)) {
              const temp = [];
              temp.push(allKeys[index]);
              temp.push(cache[allKeys[index]]);
              objToArray.push(temp);
            }
          }
          StorageManager.saveToLSorCookie(LRU_CACHE, {
            cache: objToArray
          });
        }
        getKey(value) {
          if (value === null) {
            return null;
          }
          const allKeys = _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder];
          for (const index in allKeys) {
            if (allKeys.hasOwnProperty(index)) {
              if (this.cache[allKeys[index]] === value) {
                return allKeys[index];
              }
            }
          }
          return null;
        }
        getSecondLastKey() {
          const keysArr = _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder];
          if (keysArr != null && keysArr.length > 1) {
            return keysArr[keysArr.length - 2];
          }
          return -1;
        }
        getLastKey() {
          const keysLength = _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder].length;
          if (keysLength) {
            return _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder][keysLength - 1];
          }
        }
      }
      var _deleteFromObject2 = function _deleteFromObject22(key, obj) {
        const allKeys = JSON.parse(JSON.stringify(_classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder]));
        const newCache = {};
        let indexToDelete;
        for (const index in allKeys) {
          if (allKeys.hasOwnProperty(index)) {
            if (allKeys[index] !== key) {
              newCache[allKeys[index]] = obj[allKeys[index]];
            } else {
              indexToDelete = index;
            }
          }
        }
        allKeys.splice(indexToDelete, 1);
        _classPrivateFieldLooseBase(this, _keyOrder)[_keyOrder] = JSON.parse(JSON.stringify(allKeys));
        return newCache;
      };
      var _logger$a = _classPrivateFieldLooseKey("logger");
      var _request$7 = _classPrivateFieldLooseKey("request");
      var _device$3 = _classPrivateFieldLooseKey("device");
      var _session$3 = _classPrivateFieldLooseKey("session");
      class CleverTapAPI {
        constructor(_ref) {
          let {
            logger: logger2,
            request: request2,
            device,
            session
          } = _ref;
          Object.defineProperty(this, _logger$a, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _request$7, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _device$3, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _session$3, {
            writable: true,
            value: void 0
          });
          _classPrivateFieldLooseBase(this, _logger$a)[_logger$a] = logger2;
          _classPrivateFieldLooseBase(this, _request$7)[_request$7] = request2;
          _classPrivateFieldLooseBase(this, _device$3)[_device$3] = device;
          _classPrivateFieldLooseBase(this, _session$3)[_session$3] = session;
        }
        /**
         *
         * @param {string} global gcookie
         * @param {string} session
         * @param {boolean} resume sent true in case of an OUL request from client side, which is returned as it is by server
         * @param {number} respNumber the index of the request in backupmanager
         * @param {boolean} optOutResponse
         * @returns
         */
        s(global2, session, resume, respNumber, optOutResponse) {
          let oulReq = false;
          let newGuid = false;
          if (window.isOULInProgress) {
            if (resume || respNumber !== "undefined" && respNumber === window.oulReqN) {
              window.isOULInProgress = false;
              oulReq = true;
            }
          }
          if (typeof respNumber === "undefined") {
            respNumber = 0;
          }
          StorageManager.removeBackup(respNumber, _classPrivateFieldLooseBase(this, _logger$a)[_logger$a]);
          if (respNumber > $ct.globalCache.REQ_N) {
            return;
          }
          if (!isValueValid(_classPrivateFieldLooseBase(this, _device$3)[_device$3].gcookie)) {
            if (global2) {
              newGuid = true;
            }
          }
          if (!isValueValid(_classPrivateFieldLooseBase(this, _device$3)[_device$3].gcookie) || resume || typeof optOutResponse === "boolean") {
            const sessionObj = _classPrivateFieldLooseBase(this, _session$3)[_session$3].getSessionCookieObject();
            if (window.isOULInProgress || sessionObj.s && session < sessionObj.s) {
              return;
            }
            _classPrivateFieldLooseBase(this, _logger$a)[_logger$a].debug("Cookie was ".concat(_classPrivateFieldLooseBase(this, _device$3)[_device$3].gcookie, " set to ").concat(global2));
            _classPrivateFieldLooseBase(this, _device$3)[_device$3].gcookie = global2;
            if (!isValueValid(_classPrivateFieldLooseBase(this, _device$3)[_device$3].gcookie)) {
              StorageManager.getAndClearMetaProp(USEIP_KEY);
            }
            if (global2 && StorageManager._isLocalStorageSupported()) {
              if ($ct.LRU_CACHE == null) {
                $ct.LRU_CACHE = new LRUCache(LRU_CACHE_SIZE);
              }
              const kIdFromLS = StorageManager.readFromLSorCookie(KCOOKIE_NAME);
              let guidFromLRUCache;
              if (kIdFromLS != null && kIdFromLS.id) {
                guidFromLRUCache = $ct.LRU_CACHE.cache[kIdFromLS.id];
                if (resume) {
                  if (!guidFromLRUCache) {
                    StorageManager.saveToLSorCookie(FIRE_PUSH_UNREGISTERED, true);
                    $ct.LRU_CACHE.set(kIdFromLS.id, global2);
                  }
                }
              }
              StorageManager.saveToLSorCookie(GCOOKIE_NAME, global2);
              const lastK = $ct.LRU_CACHE.getSecondLastKey();
              if (StorageManager.readFromLSorCookie(FIRE_PUSH_UNREGISTERED) && lastK !== -1) {
                const lastGUID = $ct.LRU_CACHE.cache[lastK];
                _classPrivateFieldLooseBase(this, _request$7)[_request$7].unregisterTokenForGuid(lastGUID);
              }
            }
            StorageManager.createBroadCookie(GCOOKIE_NAME, global2, COOKIE_EXPIRY, window.location.hostname);
            StorageManager.saveToLSorCookie(GCOOKIE_NAME, global2);
          }
          if (StorageManager._isLocalStorageSupported()) {
            _classPrivateFieldLooseBase(this, _session$3)[_session$3].manageSession(session);
          }
          const obj = _classPrivateFieldLooseBase(this, _session$3)[_session$3].getSessionCookieObject();
          if (typeof obj.s === "undefined" || obj.s <= session) {
            obj.s = session;
            obj.t = getNow();
            _classPrivateFieldLooseBase(this, _session$3)[_session$3].setSessionCookieObject(obj);
          }
          if (isValueValid(_classPrivateFieldLooseBase(this, _device$3)[_device$3].gcookie)) {
            $ct.blockRequest = false;
          }
          if ((oulReq || newGuid) && !_classPrivateFieldLooseBase(this, _request$7)[_request$7].processingBackup) {
            _classPrivateFieldLooseBase(this, _request$7)[_request$7].processBackupEvents();
          }
          $ct.globalCache.RESP_N = respNumber;
        }
      }
      var _logger$9 = _classPrivateFieldLooseKey("logger");
      class DeviceManager {
        constructor(_ref) {
          let {
            logger: logger2,
            customId
          } = _ref;
          Object.defineProperty(this, _logger$9, {
            writable: true,
            value: void 0
          });
          this.gcookie = void 0;
          _classPrivateFieldLooseBase(this, _logger$9)[_logger$9] = logger2;
          this.gcookie = this.getGuid() || customId;
        }
        getGuid() {
          let guid = null;
          if (isValueValid(this.gcookie)) {
            return this.gcookie;
          }
          if (StorageManager._isLocalStorageSupported()) {
            const value = StorageManager.read(GCOOKIE_NAME);
            if (isValueValid(value)) {
              try {
                guid = JSON.parse(decodeURIComponent(value));
              } catch (e) {
                _classPrivateFieldLooseBase(this, _logger$9)[_logger$9].debug("Cannot parse Gcookie from localstorage - must be encoded " + value);
                if (value.length === 32) {
                  guid = value;
                  StorageManager.saveToLSorCookie(GCOOKIE_NAME, value);
                } else {
                  _classPrivateFieldLooseBase(this, _logger$9)[_logger$9].error("Illegal guid " + value);
                }
              }
              if (isValueValid(guid)) {
                StorageManager.createBroadCookie(GCOOKIE_NAME, guid, COOKIE_EXPIRY, window.location.hostname);
              }
            }
          }
          if (!isValueValid(guid)) {
            guid = StorageManager.readCookie(GCOOKIE_NAME);
            if (isValueValid(guid) && (guid.indexOf("%") === 0 || guid.indexOf("'") === 0 || guid.indexOf('"') === 0)) {
              guid = null;
            }
            if (isValueValid(guid)) {
              StorageManager.saveToLSorCookie(GCOOKIE_NAME, guid);
            }
          }
          return guid;
        }
      }
      const DATA_NOT_SENT_TEXT = "This property has been ignored.";
      const CLEVERTAP_ERROR_PREFIX = "CleverTap error:";
      const EMBED_ERROR = "".concat(CLEVERTAP_ERROR_PREFIX, " Incorrect embed script.");
      const EVENT_ERROR = "".concat(CLEVERTAP_ERROR_PREFIX, " Event structure not valid. ").concat(DATA_NOT_SENT_TEXT);
      const GENDER_ERROR = "".concat(CLEVERTAP_ERROR_PREFIX, " Gender value should one of the following: m,f,o,u,male,female,unknown,others (case insensitive). ").concat(DATA_NOT_SENT_TEXT);
      const EMPLOYED_ERROR = "".concat(CLEVERTAP_ERROR_PREFIX, " Employed value should be either Y or N. ").concat(DATA_NOT_SENT_TEXT);
      const MARRIED_ERROR = "".concat(CLEVERTAP_ERROR_PREFIX, " Married value should be either Y or N. ").concat(DATA_NOT_SENT_TEXT);
      const EDUCATION_ERROR = "".concat(CLEVERTAP_ERROR_PREFIX, " Education value should be either School, College or Graduate. ").concat(DATA_NOT_SENT_TEXT);
      const AGE_ERROR = "".concat(CLEVERTAP_ERROR_PREFIX, " Age value should be a number. ").concat(DATA_NOT_SENT_TEXT);
      const DOB_ERROR = "".concat(CLEVERTAP_ERROR_PREFIX, " DOB value should be a Date Object");
      const ENUM_FORMAT_ERROR = "".concat(CLEVERTAP_ERROR_PREFIX, " setEnum(value). value should be a string or a number");
      const PHONE_FORMAT_ERROR = "".concat(CLEVERTAP_ERROR_PREFIX, " Phone number should be formatted as +[country code][number]");
      let _globalChargedId;
      const isEventStructureFlat = (eventObj) => {
        if (isObject(eventObj)) {
          for (var key in eventObj) {
            if (eventObj.hasOwnProperty(key)) {
              if (isObject(eventObj[key]) || Array.isArray(eventObj[key])) {
                return false;
              } else if (isDateObject(eventObj[key])) {
                eventObj[key] = convertToWZRKDate(eventObj[key]);
              }
            }
          }
          return true;
        }
        return false;
      };
      const isChargedEventStructureValid = (chargedObj, logger2) => {
        if (isObject(chargedObj)) {
          for (var key in chargedObj) {
            if (chargedObj.hasOwnProperty(key)) {
              if (key === "Items") {
                if (!Array.isArray(chargedObj[key])) {
                  return false;
                }
                if (chargedObj[key].length > 50) {
                  logger2.reportError(522, "Charged Items exceed 50 limit. Actual count: " + chargedObj[key].length);
                }
                for (var itemKey in chargedObj[key]) {
                  if (chargedObj[key].hasOwnProperty(itemKey)) {
                    if (!isObject(chargedObj[key][itemKey]) || !isEventStructureFlat(chargedObj[key][itemKey])) {
                      return false;
                    }
                  }
                }
              } else {
                if (isObject(chargedObj[key]) || Array.isArray(chargedObj[key])) {
                  return false;
                } else if (isDateObject(chargedObj[key])) {
                  chargedObj[key] = convertToWZRKDate(chargedObj[key]);
                }
              }
            }
          }
          if (isString(chargedObj[CHARGED_ID]) || isNumber(chargedObj[CHARGED_ID])) {
            const chargedId = chargedObj[CHARGED_ID] + "";
            if (typeof _globalChargedId === "undefined") {
              _globalChargedId = StorageManager.readFromLSorCookie(CHARGEDID_COOKIE_NAME);
            }
            if (typeof _globalChargedId !== "undefined" && _globalChargedId.trim() === chargedId.trim()) {
              logger2.error("Duplicate charged Id - Dropped" + chargedObj);
              return false;
            }
            _globalChargedId = chargedId;
            StorageManager.saveToLSorCookie(CHARGEDID_COOKIE_NAME, chargedId);
          }
          return true;
        }
        return false;
      };
      var _logger$8 = _classPrivateFieldLooseKey("logger");
      var _oldValues$4 = _classPrivateFieldLooseKey("oldValues");
      var _request$6 = _classPrivateFieldLooseKey("request");
      var _isPersonalisationActive$4 = _classPrivateFieldLooseKey("isPersonalisationActive");
      var _processEventArray = _classPrivateFieldLooseKey("processEventArray");
      class EventHandler extends Array {
        constructor(_ref, values) {
          let {
            logger: logger2,
            request: request2,
            isPersonalisationActive
          } = _ref;
          super();
          Object.defineProperty(this, _processEventArray, {
            value: _processEventArray2
          });
          Object.defineProperty(this, _logger$8, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _oldValues$4, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _request$6, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _isPersonalisationActive$4, {
            writable: true,
            value: void 0
          });
          _classPrivateFieldLooseBase(this, _logger$8)[_logger$8] = logger2;
          _classPrivateFieldLooseBase(this, _oldValues$4)[_oldValues$4] = values;
          _classPrivateFieldLooseBase(this, _request$6)[_request$6] = request2;
          _classPrivateFieldLooseBase(this, _isPersonalisationActive$4)[_isPersonalisationActive$4] = isPersonalisationActive;
        }
        push() {
          if (StorageManager.readFromLSorCookie(ACCOUNT_ID)) {
            for (var _len = arguments.length, eventsArr = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
              eventsArr[_key2] = arguments[_key2];
            }
            _classPrivateFieldLooseBase(this, _processEventArray)[_processEventArray](eventsArr);
            return 0;
          } else {
            _classPrivateFieldLooseBase(this, _logger$8)[_logger$8].error("Account ID is not set");
          }
        }
        _processOldValues() {
          if (_classPrivateFieldLooseBase(this, _oldValues$4)[_oldValues$4]) {
            _classPrivateFieldLooseBase(this, _processEventArray)[_processEventArray](_classPrivateFieldLooseBase(this, _oldValues$4)[_oldValues$4]);
          }
          _classPrivateFieldLooseBase(this, _oldValues$4)[_oldValues$4] = null;
        }
        getDetails(evtName) {
          if (!_classPrivateFieldLooseBase(this, _isPersonalisationActive$4)[_isPersonalisationActive$4]()) {
            return;
          }
          if (typeof $ct.globalEventsMap === "undefined") {
            $ct.globalEventsMap = StorageManager.readFromLSorCookie(EV_COOKIE);
          }
          if (typeof $ct.globalEventsMap === "undefined") {
            return;
          }
          const evtObj = $ct.globalEventsMap[evtName];
          const respObj = {};
          if (typeof evtObj !== "undefined") {
            respObj.firstTime = new Date(evtObj[1] * 1e3);
            respObj.lastTime = new Date(evtObj[2] * 1e3);
            respObj.count = evtObj[0];
            return respObj;
          }
        }
      }
      var _processEventArray2 = function _processEventArray22(eventsArr) {
        if (Array.isArray(eventsArr)) {
          while (eventsArr.length > 0) {
            var eventName = eventsArr.shift();
            if (!isString(eventName)) {
              _classPrivateFieldLooseBase(this, _logger$8)[_logger$8].error(EVENT_ERROR);
              continue;
            }
            if (eventName.length > 1024) {
              eventName = eventName.substring(0, 1024);
              _classPrivateFieldLooseBase(this, _logger$8)[_logger$8].reportError(510, eventName + "... length exceeded 1024 chars. Trimmed.");
            }
            if (SYSTEM_EVENTS.includes(eventName)) {
              _classPrivateFieldLooseBase(this, _logger$8)[_logger$8].reportError(513, eventName + " is a restricted system event. It cannot be used as an event name.");
              continue;
            }
            const data = {};
            data.type = "event";
            data.evtName = sanitize(eventName, unsupportedKeyCharRegex);
            if (eventsArr.length !== 0) {
              const eventObj = eventsArr.shift();
              if (!isObject(eventObj)) {
                eventsArr.unshift(eventObj);
              } else {
                if (eventName === "Charged") {
                  if (!isChargedEventStructureValid(eventObj, _classPrivateFieldLooseBase(this, _logger$8)[_logger$8])) {
                    _classPrivateFieldLooseBase(this, _logger$8)[_logger$8].reportError(511, "Charged event structure invalid. Not sent.");
                    continue;
                  }
                } else {
                  if (!isEventStructureFlat(eventObj)) {
                    _classPrivateFieldLooseBase(this, _logger$8)[_logger$8].reportError(512, eventName + " event structure invalid. Not sent.");
                    continue;
                  }
                }
                data.evtData = eventObj;
              }
            }
            _classPrivateFieldLooseBase(this, _request$6)[_request$6].processEvent(data);
          }
        }
      };
      const getURLParams = (url) => {
        const urlParams = {};
        const idx = url.indexOf("?");
        if (idx > 1) {
          const uri = url.substring(idx + 1);
          let match;
          const pl = /\+/g;
          const search = /([^&=]+)=?([^&]*)/g;
          const decode = function(s) {
            let replacement = s.replace(pl, " ");
            try {
              replacement = decodeURIComponent(replacement);
            } catch (e) {
            }
            return replacement;
          };
          match = search.exec(uri);
          while (match) {
            urlParams[decode(match[1])] = decode(match[2]);
            match = search.exec(uri);
          }
        }
        return urlParams;
      };
      const getDomain = (url) => {
        if (url === "") return "";
        var a = document.createElement("a");
        a.href = url;
        return a.hostname;
      };
      const addToURL = (url, k, v) => {
        return url + "&" + k + "=" + encodeURIComponent(v);
      };
      const getHostName = () => {
        return window.location.hostname;
      };
      const urlBase64ToUint8Array = (base64String) => {
        let padding = "=".repeat((4 - base64String.length % 4) % 4);
        let base64 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
        let rawData = window.atob(base64);
        let processedData = [];
        for (let i = 0; i < rawData.length; i++) {
          processedData.push(rawData.charCodeAt(i));
        }
        return new Uint8Array(processedData);
      };
      const compressData = (dataObject, logger2) => {
        logger2 && typeof logger2.debug === "function" && logger2.debug("dobj:" + dataObject);
        return compressToBase64(dataObject);
      };
      const compress = (uncompressed) => {
        if (uncompressed == null) return "";
        let i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data_string = "", context_data_val = 0, context_data_position = 0, ii, f = String.fromCharCode;
        for (ii = 0; ii < uncompressed.length; ii += 1) {
          context_c = uncompressed.charAt(ii);
          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }
          context_wc = context_w + context_c;
          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == 15) {
                    context_data_position = 0;
                    context_data_string += f(context_data_val);
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == 15) {
                    context_data_position = 0;
                    context_data_string += f(context_data_val);
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == 15) {
                    context_data_position = 0;
                    context_data_string += f(context_data_val);
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == 15) {
                    context_data_position = 0;
                    context_data_string += f(context_data_val);
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == 15) {
                  context_data_position = 0;
                  context_data_string += f(context_data_val);
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }
        if (context_w !== "") {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1;
                if (context_data_position == 15) {
                  context_data_position = 0;
                  context_data_string += f(context_data_val);
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 8; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == 15) {
                  context_data_position = 0;
                  context_data_string += f(context_data_val);
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value;
                if (context_data_position == 15) {
                  context_data_position = 0;
                  context_data_string += f(context_data_val);
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 16; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == 15) {
                  context_data_position = 0;
                  context_data_string += f(context_data_val);
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == 15) {
                context_data_position = 0;
                context_data_string += f(context_data_val);
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
        }
        value = 2;
        for (i = 0; i < context_numBits; i++) {
          context_data_val = context_data_val << 1 | value & 1;
          if (context_data_position == 15) {
            context_data_position = 0;
            context_data_string += f(context_data_val);
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
        while (true) {
          context_data_val = context_data_val << 1;
          if (context_data_position == 15) {
            context_data_string += f(context_data_val);
            break;
          } else context_data_position++;
        }
        return context_data_string;
      };
      const getKeyStr = () => {
        let key = "";
        let i = 0;
        for (i = 0; i <= 25; i++) {
          key = key + String.fromCharCode(i + 65);
        }
        for (i = 0; i <= 25; i++) {
          key = key + String.fromCharCode(i + 97);
        }
        for (i = 0; i < 10; i++) {
          key = key + i;
        }
        return key + "+/=";
      };
      const _keyStr = getKeyStr();
      const compressToBase64 = (input) => {
        if (input == null) return "";
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        input = compress(input);
        while (i < input.length * 2) {
          if (i % 2 == 0) {
            chr1 = input.charCodeAt(i / 2) >> 8;
            chr2 = input.charCodeAt(i / 2) & 255;
            if (i / 2 + 1 < input.length) chr3 = input.charCodeAt(i / 2 + 1) >> 8;
            else chr3 = NaN;
          } else {
            chr1 = input.charCodeAt((i - 1) / 2) & 255;
            if ((i + 1) / 2 < input.length) {
              chr2 = input.charCodeAt((i + 1) / 2) >> 8;
              chr3 = input.charCodeAt((i + 1) / 2) & 255;
            } else chr2 = chr3 = NaN;
          }
          i += 3;
          enc1 = chr1 >> 2;
          enc2 = (chr1 & 3) << 4 | chr2 >> 4;
          enc3 = (chr2 & 15) << 2 | chr3 >> 6;
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }
          output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
        }
        return output;
      };
      var _fireRequest = _classPrivateFieldLooseKey("fireRequest");
      var _dropRequestDueToOptOut = _classPrivateFieldLooseKey("dropRequestDueToOptOut");
      var _addUseIPToRequest = _classPrivateFieldLooseKey("addUseIPToRequest");
      var _addARPToRequest = _classPrivateFieldLooseKey("addARPToRequest");
      class RequestDispatcher {
        constructor() {
          this.networkRetryCount = 0;
          this.minDelayFrequency = 0;
        }
        /**
         *
         * @param {string} url
         * @param {*} skipARP
         * @param {boolean} sendOULFlag
         */
        static fireRequest(url, skipARP, sendOULFlag, evtName) {
          _classPrivateFieldLooseBase(this, _fireRequest)[_fireRequest](url, 1, skipARP, sendOULFlag, evtName);
        }
        getDelayFrequency() {
          this.logger.debug("Network retry #" + this.networkRetryCount);
          if (this.networkRetryCount < 10) {
            this.logger.debug(this.account.id, "Failure count is " + this.networkRetryCount + ". Setting delay frequency to 1s");
            this.minDelayFrequency = PUSH_DELAY_MS;
            return this.minDelayFrequency;
          }
          if (this.account.region == null) {
            this.logger.debug(this.account.id, "Setting delay frequency to 1s");
            return PUSH_DELAY_MS;
          } else {
            const randomDelay = (Math.floor(Math.random() * 10) + 1) * 1e3;
            this.minDelayFrequency += randomDelay;
            if (this.minDelayFrequency < MAX_DELAY_FREQUENCY) {
              this.logger.debug(this.account.id, "Setting delay frequency to " + this.minDelayFrequency);
              return this.minDelayFrequency;
            } else {
              this.minDelayFrequency = PUSH_DELAY_MS;
            }
            this.logger.debug(this.account.id, "Setting delay frequency to " + this.minDelayFrequency);
            return this.minDelayFrequency;
          }
        }
      }
      var _addARPToRequest2 = function _addARPToRequest22(url, skipResARP) {
        if (skipResARP === true) {
          const _arp = {};
          _arp.skipResARP = true;
          return addToURL(url, "arp", compressData(JSON.stringify(_arp), this.logger));
        }
        if (StorageManager._isLocalStorageSupported() && typeof localStorage.getItem(ARP_COOKIE) !== "undefined" && localStorage.getItem(ARP_COOKIE) !== null) {
          return addToURL(url, "arp", compressData(JSON.stringify(StorageManager.readFromLSorCookie(ARP_COOKIE)), this.logger));
        }
        return url;
      };
      var _addUseIPToRequest2 = function _addUseIPToRequest22(pageLoadUrl) {
        var useIP = StorageManager.getMetaProp(USEIP_KEY);
        if (typeof useIP !== "boolean") {
          useIP = false;
        }
        return addToURL(pageLoadUrl, USEIP_KEY, useIP ? "true" : "false");
      };
      var _dropRequestDueToOptOut2 = function _dropRequestDueToOptOut22() {
        if ($ct.isOptInRequest || !isValueValid(this.device.gcookie) || !isString(this.device.gcookie)) {
          $ct.isOptInRequest = false;
          return false;
        }
        return this.device.gcookie.slice(-3) === OPTOUT_COOKIE_ENDSWITH;
      };
      var _fireRequest2 = function _fireRequest22(url, tries, skipARP, sendOULFlag, evtName) {
        var _window$clevertap, _window$wizrocket;
        if (_classPrivateFieldLooseBase(this, _dropRequestDueToOptOut)[_dropRequestDueToOptOut]()) {
          this.logger.debug("req dropped due to optout cookie: " + this.device.gcookie);
          return;
        }
        if (!isValueValid(this.device.gcookie)) {
          $ct.blockRequest = true;
        }
        if (evtName && evtName === WZRK_FETCH) {
          if (!isValueValid(this.device.gcookie) && $ct.globalCache.RESP_N < $ct.globalCache.REQ_N - 1) {
            setTimeout(() => {
              this.logger.debug("retrying fire request for url: ".concat(url, ", tries: ").concat(this.networkRetryCount));
              _classPrivateFieldLooseBase(this, _fireRequest)[_fireRequest](url, void 0, skipARP, sendOULFlag);
            }, this.getDelayFrequency());
          }
        } else {
          if (!isValueValid(this.device.gcookie) && $ct.globalCache.RESP_N < $ct.globalCache.REQ_N - 1 && tries < MAX_TRIES) {
            setTimeout(() => {
              this.logger.debug("retrying fire request for url: ".concat(url, ", tries: ").concat(tries));
              _classPrivateFieldLooseBase(this, _fireRequest)[_fireRequest](url, tries + 1, skipARP, sendOULFlag);
            }, 50);
            return;
          }
        }
        if (!sendOULFlag) {
          if (isValueValid(this.device.gcookie)) {
            url = addToURL(url, "gc", this.device.gcookie);
          }
          url = _classPrivateFieldLooseBase(this, _addARPToRequest)[_addARPToRequest](url, skipARP);
        } else {
          window.isOULInProgress = true;
        }
        url = addToURL(url, "tries", tries);
        url = _classPrivateFieldLooseBase(this, _addUseIPToRequest)[_addUseIPToRequest](url);
        url = addToURL(url, "r", (/* @__PURE__ */ new Date()).getTime());
        if (((_window$clevertap = window.clevertap) === null || _window$clevertap === void 0 ? void 0 : _window$clevertap.hasOwnProperty("plugin")) || ((_window$wizrocket = window.wizrocket) === null || _window$wizrocket === void 0 ? void 0 : _window$wizrocket.hasOwnProperty("plugin"))) {
          const plugin = window.clevertap.plugin || window.wizrocket.plugin;
          url = addToURL(url, "ct_pl", plugin);
        }
        if (url.indexOf("chrome-extension:") !== -1) {
          url = url.replace("chrome-extension:", "https:");
        }
        var ctCbScripts = document.getElementsByClassName("ct-jp-cb");
        while (ctCbScripts[0] && ctCbScripts[0].parentNode) {
          ctCbScripts[0].parentNode.removeChild(ctCbScripts[0]);
        }
        const s = document.createElement("script");
        s.setAttribute("type", "text/javascript");
        s.setAttribute("src", url);
        s.setAttribute("class", "ct-jp-cb");
        s.setAttribute("rel", "nofollow");
        s.async = true;
        document.getElementsByTagName("head")[0].appendChild(s);
        this.logger.debug("req snt -> url: " + url);
      };
      RequestDispatcher.logger = void 0;
      RequestDispatcher.device = void 0;
      RequestDispatcher.account = void 0;
      Object.defineProperty(RequestDispatcher, _fireRequest, {
        value: _fireRequest2
      });
      Object.defineProperty(RequestDispatcher, _dropRequestDueToOptOut, {
        value: _dropRequestDueToOptOut2
      });
      Object.defineProperty(RequestDispatcher, _addUseIPToRequest, {
        value: _addUseIPToRequest2
      });
      Object.defineProperty(RequestDispatcher, _addARPToRequest, {
        value: _addARPToRequest2
      });
      const getCampaignObject = () => {
        let finalcampObj = {};
        if (StorageManager._isLocalStorageSupported()) {
          let campObj = StorageManager.read(CAMP_COOKIE_NAME);
          if (campObj != null) {
            campObj = JSON.parse(decodeURIComponent(campObj).replace(singleQuoteRegex, '"'));
            if (campObj.hasOwnProperty("global")) {
              finalcampObj.wp = campObj;
            } else {
              finalcampObj = campObj;
            }
          } else {
            finalcampObj = {};
          }
        }
        return finalcampObj;
      };
      const saveCampaignObject = (campaignObj) => {
        if (StorageManager._isLocalStorageSupported()) {
          const newObj = {
            ...getCampaignObject(),
            ...campaignObj
          };
          const campObj = JSON.stringify(newObj);
          StorageManager.save(CAMP_COOKIE_NAME, encodeURIComponent(campObj));
          setCampaignObjectForGuid();
        }
      };
      const setCampaignObjectForGuid = () => {
        if (StorageManager._isLocalStorageSupported()) {
          let guid = StorageManager.read(GCOOKIE_NAME);
          if (isValueValid(guid)) {
            try {
              guid = JSON.parse(decodeURIComponent(StorageManager.read(GCOOKIE_NAME)));
              const guidCampObj = StorageManager.read(CAMP_COOKIE_G) ? JSON.parse(decodeURIComponent(StorageManager.read(CAMP_COOKIE_G))) : {};
              if (guid && StorageManager._isLocalStorageSupported()) {
                var finalCampObj = {};
                var campObj = getCampaignObject();
                Object.keys(campObj).forEach((key) => {
                  const campKeyObj = guid in guidCampObj && Object.keys(guidCampObj[guid]).length && guidCampObj[guid][key] ? guidCampObj[guid][key] : {};
                  const globalObj = campObj[key].global;
                  const today = getToday();
                  const dailyObj = campObj[key][today];
                  if (typeof globalObj !== "undefined") {
                    const campaignIdArray = Object.keys(globalObj);
                    for (const index in campaignIdArray) {
                      let resultObj = [];
                      if (campaignIdArray.hasOwnProperty(index)) {
                        let dailyC = 0;
                        let totalC = 0;
                        const campaignId = campaignIdArray[index];
                        if (campaignId === "tc") {
                          continue;
                        }
                        if (typeof dailyObj !== "undefined" && typeof dailyObj[campaignId] !== "undefined") {
                          dailyC = dailyObj[campaignId];
                        }
                        if (typeof globalObj !== "undefined" && typeof globalObj[campaignId] !== "undefined") {
                          totalC = globalObj[campaignId];
                        }
                        resultObj = [campaignId, dailyC, totalC];
                        campKeyObj[campaignId] = resultObj;
                      }
                    }
                  }
                  finalCampObj = {
                    ...finalCampObj,
                    [key]: campKeyObj
                  };
                });
                guidCampObj[guid] = finalCampObj;
                StorageManager.save(CAMP_COOKIE_G, encodeURIComponent(JSON.stringify(guidCampObj)));
              }
            } catch (e) {
              console.error("Invalid clevertap Id " + e);
            }
          }
        }
      };
      const getCampaignObjForLc = () => {
        const guid = JSON.parse(decodeURIComponent(StorageManager.read(GCOOKIE_NAME)));
        let campObj = {};
        if (StorageManager._isLocalStorageSupported()) {
          let resultObj = {};
          campObj = getCampaignObject();
          const storageValue = StorageManager.read(CAMP_COOKIE_G);
          const decodedValue = storageValue ? decodeURIComponent(storageValue) : null;
          const parsedValue = decodedValue ? JSON.parse(decodedValue) : null;
          const resultObjWP = !!guid && storageValue !== void 0 && storageValue !== null && parsedValue && parsedValue[guid] && parsedValue[guid].wp ? Object.values(parsedValue[guid].wp) : [];
          const resultObjWI = !!guid && storageValue !== void 0 && storageValue !== null && parsedValue && parsedValue[guid] && parsedValue[guid].wi ? Object.values(parsedValue[guid].wi) : [];
          const today = getToday();
          let todayCwp = 0;
          let todayCwi = 0;
          if (campObj.wp && campObj.wp[today] && campObj.wp[today].tc !== "undefined") {
            todayCwp = campObj.wp[today].tc;
          }
          if (campObj.wi && campObj.wi[today] && campObj.wi[today].tc !== "undefined") {
            todayCwi = campObj.wi[today].tc;
          }
          resultObj = {
            wmp: todayCwp,
            wimp: todayCwi,
            tlc: resultObjWP,
            witlc: resultObjWI
          };
          return resultObj;
        }
      };
      const isProfileValid = (profileObj, _ref) => {
        let {
          logger: logger2
        } = _ref;
        let valid = false;
        if (isObject(profileObj)) {
          for (const profileKey in profileObj) {
            if (profileObj.hasOwnProperty(profileKey)) {
              valid = true;
              let profileVal = profileObj[profileKey];
              if (profileVal == null) {
                delete profileObj[profileKey];
                continue;
              }
              if (profileKey === "Gender" && !profileVal.match(/\b(?:[mM](?:ale)?|[fF](?:emale)?|[oO](?:thers)?|[uU](?:nknown)?)\b/)) {
                valid = false;
                logger2.error(GENDER_ERROR);
              }
              if (profileKey === "Employed" && !profileVal.match(/^Y$|^N$/)) {
                valid = false;
                logger2.error(EMPLOYED_ERROR);
              }
              if (profileKey === "Married" && !profileVal.match(/^Y$|^N$/)) {
                valid = false;
                logger2.error(MARRIED_ERROR);
              }
              if (profileKey === "Education" && !profileVal.match(/^School$|^College$|^Graduate$/)) {
                valid = false;
                logger2.error(EDUCATION_ERROR);
              }
              if (profileKey === "Age" && profileVal != null) {
                if (isConvertibleToNumber(profileVal)) {
                  profileObj.Age = +profileVal;
                } else {
                  valid = false;
                  logger2.error(AGE_ERROR);
                }
              }
              if (profileKey === "DOB") {
                if ((!/^\$D_/.test(profileVal) || (profileVal + "").length !== 11) && !isDateObject(profileVal)) {
                  valid = false;
                  logger2.error(DOB_ERROR);
                }
                if (isDateObject(profileVal)) {
                  profileObj[profileKey] = convertToWZRKDate(profileVal);
                }
              } else if (isDateObject(profileVal)) {
                profileObj[profileKey] = convertToWZRKDate(profileVal);
              }
              if (profileKey === "Phone" && !isObjectEmpty(profileVal)) {
                if (profileVal.length > 8 && profileVal.charAt(0) === "+") {
                  profileVal = profileVal.substring(1, profileVal.length);
                  if (isConvertibleToNumber(profileVal)) {
                    profileObj.Phone = +profileVal;
                  } else {
                    valid = false;
                    logger2.error(PHONE_FORMAT_ERROR + ". Removed.");
                  }
                } else {
                  valid = false;
                  logger2.error(PHONE_FORMAT_ERROR + ". Removed.");
                }
              }
              if (!valid) {
                delete profileObj[profileKey];
              }
            }
          }
        }
        return valid;
      };
      const processFBUserObj = (user) => {
        const profileData = {};
        profileData.Name = user.name;
        if (user.id != null) {
          profileData.FBID = user.id + "";
        }
        if (user.gender === "male") {
          profileData.Gender = "M";
        } else if (user.gender === "female") {
          profileData.Gender = "F";
        } else {
          profileData.Gender = "O";
        }
        const getHighestEducation = function(eduArr) {
          if (eduArr != null) {
            let college = "";
            let highschool = "";
            for (let i = 0; i < eduArr.length; i++) {
              const edu2 = eduArr[i];
              if (edu2.type != null) {
                const type = edu2.type;
                if (type === "Graduate School") {
                  return "Graduate";
                } else if (type === "College") {
                  college = "1";
                } else if (type === "High School") {
                  highschool = "1";
                }
              }
            }
            if (college === "1") {
              return "College";
            } else if (highschool === "1") {
              return "School";
            }
          }
        };
        if (user.relationship_status != null) {
          profileData.Married = "N";
          if (user.relationship_status === "Married") {
            profileData.Married = "Y";
          }
        }
        const edu = getHighestEducation(user.education);
        if (edu != null) {
          profileData.Education = edu;
        }
        const work = user.work != null ? user.work.length : 0;
        if (work > 0) {
          profileData.Employed = "Y";
        } else {
          profileData.Employed = "N";
        }
        if (user.email != null) {
          profileData.Email = user.email;
        }
        if (user.birthday != null) {
          const mmddyy = user.birthday.split("/");
          profileData.DOB = setDate(mmddyy[2] + mmddyy[0] + mmddyy[1]);
        }
        return profileData;
      };
      const processGPlusUserObj = (user, _ref2) => {
        let {
          logger: logger2
        } = _ref2;
        const profileData = {};
        if (user.displayName != null) {
          profileData.Name = user.displayName;
        }
        if (user.id != null) {
          profileData.GPID = user.id + "";
        }
        if (user.gender != null) {
          if (user.gender === "male") {
            profileData.Gender = "M";
          } else if (user.gender === "female") {
            profileData.Gender = "F";
          } else if (user.gender === "other") {
            profileData.Gender = "O";
          }
        }
        if (user.image != null) {
          if (user.image.isDefault === false) {
            profileData.Photo = user.image.url.split("?sz")[0];
          }
        }
        if (user.emails != null) {
          for (let emailIdx = 0; emailIdx < user.emails.length; emailIdx++) {
            const emailObj = user.emails[emailIdx];
            if (emailObj.type === "account") {
              profileData.Email = emailObj.value;
            }
          }
        }
        if (user.organizations != null) {
          profileData.Employed = "N";
          for (let i = 0; i < user.organizations.length; i++) {
            const orgObj = user.organizations[i];
            if (orgObj.type === "work") {
              profileData.Employed = "Y";
            }
          }
        }
        if (user.birthday != null) {
          const yyyymmdd = user.birthday.split("-");
          profileData.DOB = setDate(yyyymmdd[0] + yyyymmdd[1] + yyyymmdd[2]);
        }
        if (user.relationshipStatus != null) {
          profileData.Married = "N";
          if (user.relationshipStatus === "married") {
            profileData.Married = "Y";
          }
        }
        logger2.debug("gplus usr profile " + JSON.stringify(profileData));
        return profileData;
      };
      const addToLocalProfileMap = (profileObj, override) => {
        if (StorageManager._isLocalStorageSupported()) {
          if ($ct.globalProfileMap == null) {
            $ct.globalProfileMap = StorageManager.readFromLSorCookie(PR_COOKIE);
            if ($ct.globalProfileMap == null) {
              $ct.globalProfileMap = {};
            }
          }
          if (profileObj._custom != null) {
            const keys = profileObj._custom;
            for (const key in keys) {
              if (keys.hasOwnProperty(key)) {
                profileObj[key] = keys[key];
              }
            }
            delete profileObj._custom;
          }
          for (const prop in profileObj) {
            if (profileObj.hasOwnProperty(prop)) {
              if ($ct.globalProfileMap.hasOwnProperty(prop) && !override) {
                continue;
              }
              $ct.globalProfileMap[prop] = profileObj[prop];
            }
          }
          if ($ct.globalProfileMap._custom != null) {
            delete $ct.globalProfileMap._custom;
          }
          StorageManager.saveToLSorCookie(PR_COOKIE, $ct.globalProfileMap);
        }
      };
      const closeIframe = (campaignId, divIdIgnored, currentSessionId) => {
        if (campaignId != null && campaignId !== "-1") {
          if (StorageManager._isLocalStorageSupported()) {
            const campaignObj = getCampaignObject();
            let sessionCampaignObj = campaignObj.wp[currentSessionId];
            if (sessionCampaignObj == null) {
              sessionCampaignObj = {};
              campaignObj[currentSessionId] = sessionCampaignObj;
            }
            sessionCampaignObj[campaignId] = "dnd";
            saveCampaignObject(campaignObj);
          }
        }
        if ($ct.campaignDivMap != null) {
          const divId = $ct.campaignDivMap[campaignId];
          if (divId != null) {
            document.getElementById(divId).remove();
            if (divId === "intentPreview") {
              if (document.getElementById("intentOpacityDiv") != null) {
                document.getElementById("intentOpacityDiv").remove();
              }
            } else if (divId === "wizParDiv0") {
              if (document.getElementById("intentOpacityDiv0") != null) {
                document.getElementById("intentOpacityDiv0").remove();
              }
            } else if (divId === "wizParDiv2") {
              if (document.getElementById("intentOpacityDiv2") != null) {
                document.getElementById("intentOpacityDiv2").remove();
              }
            }
          }
        }
      };
      const arp = (jsonMap) => {
        if (jsonMap.skipResARP != null && jsonMap.skipResARP) {
          console.debug("Update ARP Request rejected", jsonMap);
          return null;
        }
        const isOULARP = jsonMap[IS_OUL] === true;
        if (StorageManager._isLocalStorageSupported()) {
          try {
            let arpFromStorage = StorageManager.readFromLSorCookie(ARP_COOKIE);
            if (arpFromStorage == null || isOULARP) {
              arpFromStorage = {};
              for (const key in jsonMap) {
                if (jsonMap.hasOwnProperty(key)) {
                  if (jsonMap[key] === -1) {
                    delete arpFromStorage[key];
                  } else {
                    arpFromStorage[key] = jsonMap[key];
                  }
                }
              }
              StorageManager.saveToLSorCookie(ARP_COOKIE, arpFromStorage);
            }
          } catch (e) {
            console.error("Unable to parse ARP JSON: " + e);
          }
        }
      };
      const setEnum = (enumVal, logger2) => {
        if (isString(enumVal) || isNumber(enumVal)) {
          return "$E_" + enumVal;
        }
        logger2.error(ENUM_FORMAT_ERROR);
      };
      const handleEmailSubscription = (subscription, reEncoded, fetchGroups, account2, logger2) => {
        const urlParamsAsIs = getURLParams(location.href);
        const encodedEmailId = urlParamsAsIs.e;
        const encodedProfileProps = urlParamsAsIs.p;
        const pageType = urlParamsAsIs.page_type;
        if (typeof encodedEmailId !== "undefined") {
          const data = {};
          data.id = account2.id;
          data.unsubGroups = $ct.unsubGroups;
          if ($ct.updatedCategoryLong) {
            data[categoryLongKey] = $ct.updatedCategoryLong;
          }
          let url = account2.emailURL;
          if (fetchGroups) {
            url = addToURL(url, "fetchGroups", fetchGroups);
          }
          if (reEncoded) {
            url = addToURL(url, "encoded", reEncoded);
          }
          url = addToURL(url, "e", encodedEmailId);
          url = addToURL(url, "d", compressData(JSON.stringify(data), logger2));
          if (encodedProfileProps) {
            url = addToURL(url, "p", encodedProfileProps);
          }
          if (subscription !== "-1") {
            url = addToURL(url, "sub", subscription);
          }
          if (pageType) {
            $ct.globalUnsubscribe = pageType === GLOBAL;
            url = addToURL(url, "page_type", pageType);
          }
          RequestDispatcher.fireRequest(url);
        }
      };
      var _logger$7 = _classPrivateFieldLooseKey("logger");
      var _request$5 = _classPrivateFieldLooseKey("request");
      var _account$6 = _classPrivateFieldLooseKey("account");
      var _oldValues$3 = _classPrivateFieldLooseKey("oldValues");
      var _isPersonalisationActive$3 = _classPrivateFieldLooseKey("isPersonalisationActive");
      var _processProfileArray = _classPrivateFieldLooseKey("processProfileArray");
      class ProfileHandler extends Array {
        constructor(_ref, values) {
          let {
            logger: logger2,
            request: request2,
            account: account2,
            isPersonalisationActive
          } = _ref;
          super();
          Object.defineProperty(this, _processProfileArray, {
            value: _processProfileArray2
          });
          Object.defineProperty(this, _logger$7, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _request$5, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _account$6, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _oldValues$3, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _isPersonalisationActive$3, {
            writable: true,
            value: void 0
          });
          _classPrivateFieldLooseBase(this, _logger$7)[_logger$7] = logger2;
          _classPrivateFieldLooseBase(this, _request$5)[_request$5] = request2;
          _classPrivateFieldLooseBase(this, _account$6)[_account$6] = account2;
          _classPrivateFieldLooseBase(this, _oldValues$3)[_oldValues$3] = values;
          _classPrivateFieldLooseBase(this, _isPersonalisationActive$3)[_isPersonalisationActive$3] = isPersonalisationActive;
        }
        push() {
          if (StorageManager.readFromLSorCookie(ACCOUNT_ID)) {
            for (var _len = arguments.length, profilesArr = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
              profilesArr[_key2] = arguments[_key2];
            }
            _classPrivateFieldLooseBase(this, _processProfileArray)[_processProfileArray](profilesArr);
            return 0;
          } else {
            _classPrivateFieldLooseBase(this, _logger$7)[_logger$7].error("Account ID is not set");
          }
        }
        _processOldValues() {
          if (_classPrivateFieldLooseBase(this, _oldValues$3)[_oldValues$3]) {
            _classPrivateFieldLooseBase(this, _processProfileArray)[_processProfileArray](_classPrivateFieldLooseBase(this, _oldValues$3)[_oldValues$3]);
          }
          _classPrivateFieldLooseBase(this, _oldValues$3)[_oldValues$3] = null;
        }
        getAttribute(propName) {
          if (!_classPrivateFieldLooseBase(this, _isPersonalisationActive$3)[_isPersonalisationActive$3]()) {
            return;
          }
          if ($ct.globalProfileMap == null) {
            $ct.globalProfileMap = StorageManager.readFromLSorCookie(PR_COOKIE);
          }
          if ($ct.globalProfileMap != null) {
            return $ct.globalProfileMap[propName];
          }
        }
        /**
         *
         * @param {any} key
         * @param {number} value
         * @param {string} command
         * increases or decreases value of the number type properties in profile object
         */
        _handleIncrementDecrementValue(key, value, command) {
          var _$ct$globalProfileMap;
          if ($ct.globalProfileMap == null) {
            $ct.globalProfileMap = StorageManager.readFromLSorCookie(PR_COOKIE);
          }
          if ($ct.globalProfileMap == null && !((_$ct$globalProfileMap = $ct.globalProfileMap) === null || _$ct$globalProfileMap === void 0 ? void 0 : _$ct$globalProfileMap.hasOwnProperty(key))) {
            console.error("Kindly create profile with required proprty to increment/decrement.");
          } else if (!value || typeof value !== "number" || value <= 0) {
            console.error("Value should be a number greater than 0");
          } else {
            if (command === COMMAND_INCREMENT) {
              $ct.globalProfileMap[key] = $ct.globalProfileMap[key] + value;
            } else {
              $ct.globalProfileMap[key] = $ct.globalProfileMap[key] - value;
            }
            StorageManager.saveToLSorCookie(PR_COOKIE, $ct.globalProfileMap);
            let data = {};
            const profileObj = {};
            data.type = "profile";
            profileObj[key] = {
              [command]: value
            };
            if (profileObj.tz == null) {
              profileObj.tz = (/* @__PURE__ */ new Date()).toString().match(/([A-Z]+[\+-][0-9]+)/)[1];
            }
            data.profile = profileObj;
            data = _classPrivateFieldLooseBase(this, _request$5)[_request$5].addSystemDataToObject(data, true);
            _classPrivateFieldLooseBase(this, _request$5)[_request$5].addFlags(data);
            const compressedData = compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger$7)[_logger$7]);
            let pageLoadUrl = _classPrivateFieldLooseBase(this, _account$6)[_account$6].dataPostURL;
            pageLoadUrl = addToURL(pageLoadUrl, "type", EVT_PUSH);
            pageLoadUrl = addToURL(pageLoadUrl, "d", compressedData);
            _classPrivateFieldLooseBase(this, _request$5)[_request$5].saveAndFireRequest(pageLoadUrl, $ct.blockRequest);
          }
        }
        /**
         *
         * @param {any} key
         * @param {array} arrayVal
         * @param {string} command
         * overwrites/sets new value(s) against a key/property in profile object
         */
        _handleMultiValueSet(key, arrayVal, command) {
          const array = [];
          for (let i = 0; i < arrayVal.length; i++) {
            if (typeof arrayVal[i] === "number" && !array.includes(arrayVal[i])) {
              array.push(arrayVal[i]);
            } else if (typeof arrayVal[i] === "string" && !array.includes(arrayVal[i].toLowerCase())) {
              array.push(arrayVal[i].toLowerCase());
            } else {
              console.error("array supports only string or number type values");
            }
          }
          if ($ct.globalProfileMap == null) {
            var _StorageManager$readF;
            $ct.globalProfileMap = (_StorageManager$readF = StorageManager.readFromLSorCookie(PR_COOKIE)) !== null && _StorageManager$readF !== void 0 ? _StorageManager$readF : {};
          }
          $ct.globalProfileMap[key] = array;
          StorageManager.saveToLSorCookie(PR_COOKIE, $ct.globalProfileMap);
          this.sendMultiValueData(key, arrayVal, command);
        }
        /**
         *
         * @param {any} propKey - the property name to be added in the profile object
         * @param {string, number, array} propVal - the property value to be added against the @propkey key
         * @param {string} command
         * Adds array or single value against a key/property in profile object
         */
        _handleMultiValueAdd(propKey, propVal, command) {
          if ($ct.globalProfileMap == null) {
            $ct.globalProfileMap = StorageManager.readFromLSorCookie(PR_COOKIE) || {};
          }
          const existingValue = $ct.globalProfileMap[propKey];
          const array = Array.isArray(existingValue) ? existingValue : existingValue != null ? [existingValue] : [];
          const addValue = (value) => {
            const normalizedValue = typeof value === "number" ? value : value.toLowerCase();
            if (!array.includes(normalizedValue)) {
              array.push(normalizedValue);
            }
          };
          if (Array.isArray(propVal)) {
            propVal.forEach((value) => {
              if (typeof value === "string" || typeof value === "number") {
                addValue(value);
              } else {
                _classPrivateFieldLooseBase(this, _logger$7)[_logger$7].error("Array supports only string or number type values");
              }
            });
          } else if (typeof propVal === "string" || typeof propVal === "number") {
            addValue(propVal);
          } else {
            _classPrivateFieldLooseBase(this, _logger$7)[_logger$7].error("Unsupported value type");
            return;
          }
          $ct.globalProfileMap[propKey] = array;
          StorageManager.saveToLSorCookie(PR_COOKIE, $ct.globalProfileMap);
          this.sendMultiValueData(propKey, propVal, command);
        }
        /**
         *
         * @param {any} propKey
         * @param {string, number, array} propVal
         * @param {string} command
         * removes value(s) against a key/property in profile object
         */
        _handleMultiValueRemove(propKey, propVal, command) {
          if ($ct.globalProfileMap == null) {
            $ct.globalProfileMap = StorageManager.readFromLSorCookie(PR_COOKIE) || {};
          }
          if (!$ct.globalProfileMap.hasOwnProperty(propKey)) {
            _classPrivateFieldLooseBase(this, _logger$7)[_logger$7].error("The property ".concat(propKey, " does not exist."));
            return;
          }
          const removeValue = (value) => {
            const index = $ct.globalProfileMap[propKey].indexOf(value);
            if (index !== -1) {
              $ct.globalProfileMap[propKey].splice(index, 1);
            }
          };
          if (Array.isArray(propVal)) {
            propVal.forEach(removeValue);
          } else if (typeof propVal === "string" || typeof propVal === "number") {
            removeValue(propVal);
          } else {
            _classPrivateFieldLooseBase(this, _logger$7)[_logger$7].error("Unsupported propVal type");
            return;
          }
          if ($ct.globalProfileMap[propKey].length === 0) {
            delete $ct.globalProfileMap[propKey];
          }
          StorageManager.saveToLSorCookie(PR_COOKIE, $ct.globalProfileMap);
          this.sendMultiValueData(propKey, propVal, command);
        }
        /**
         *
         * @param {any} propKey
         * @param {string} command
         * deletes a key value pair from the profile object
         */
        _handleMultiValueDelete(propKey, command) {
          var _$ct$globalProfileMap2;
          if ($ct.globalProfileMap == null) {
            $ct.globalProfileMap = StorageManager.readFromLSorCookie(PR_COOKIE);
          }
          if (!($ct === null || $ct === void 0 ? void 0 : (_$ct$globalProfileMap2 = $ct.globalProfileMap) === null || _$ct$globalProfileMap2 === void 0 ? void 0 : _$ct$globalProfileMap2.hasOwnProperty(propKey))) {
            _classPrivateFieldLooseBase(this, _logger$7)[_logger$7].error("The property ".concat(propKey, " does not exist."));
          } else {
            delete $ct.globalProfileMap[propKey];
          }
          StorageManager.saveToLSorCookie(PR_COOKIE, $ct.globalProfileMap);
          this.sendMultiValueData(propKey, null, command);
        }
        sendMultiValueData(propKey, propVal, command) {
          let data = {};
          const profileObj = {};
          data.type = "profile";
          profileObj[propKey] = {
            [command]: command === COMMAND_DELETE ? true : propVal
          };
          if (profileObj.tz == null) {
            profileObj.tz = (/* @__PURE__ */ new Date()).toString().match(/([A-Z]+[\+-][0-9]+)/)[1];
          }
          data.profile = profileObj;
          data = _classPrivateFieldLooseBase(this, _request$5)[_request$5].addSystemDataToObject(data, true);
          _classPrivateFieldLooseBase(this, _request$5)[_request$5].addFlags(data);
          const compressedData = compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger$7)[_logger$7]);
          let pageLoadUrl = _classPrivateFieldLooseBase(this, _account$6)[_account$6].dataPostURL;
          pageLoadUrl = addToURL(pageLoadUrl, "type", EVT_PUSH);
          pageLoadUrl = addToURL(pageLoadUrl, "d", compressedData);
          _classPrivateFieldLooseBase(this, _request$5)[_request$5].saveAndFireRequest(pageLoadUrl, $ct.blockRequest);
        }
      }
      var _processProfileArray2 = function _processProfileArray22(profileArr) {
        if (Array.isArray(profileArr) && profileArr.length > 0) {
          for (const index in profileArr) {
            if (profileArr.hasOwnProperty(index)) {
              const outerObj = profileArr[index];
              let data = {};
              let profileObj;
              if (outerObj.Site != null) {
                profileObj = outerObj.Site;
                if (isObjectEmpty(profileObj) || !isProfileValid(profileObj, {
                  logger: _classPrivateFieldLooseBase(this, _logger$7)[_logger$7]
                })) {
                  return;
                }
              } else if (outerObj.Facebook != null) {
                const FbProfileObj = outerObj.Facebook;
                if (!isObjectEmpty(FbProfileObj) && !FbProfileObj.error) {
                  profileObj = processFBUserObj(FbProfileObj);
                }
              } else if (outerObj["Google Plus"] != null) {
                const GPlusProfileObj = outerObj["Google Plus"];
                if (!isObjectEmpty(GPlusProfileObj) && !GPlusProfileObj.error) {
                  profileObj = processGPlusUserObj(GPlusProfileObj, {
                    logger: _classPrivateFieldLooseBase(this, _logger$7)[_logger$7]
                  });
                }
              }
              if (profileObj != null && !isObjectEmpty(profileObj)) {
                data.type = "profile";
                if (profileObj.tz == null) {
                  profileObj.tz = (/* @__PURE__ */ new Date()).toString().match(/([A-Z]+[\+-][0-9]+)/)[1];
                }
                data.profile = profileObj;
                addToLocalProfileMap(profileObj, true);
                data = _classPrivateFieldLooseBase(this, _request$5)[_request$5].addSystemDataToObject(data, void 0);
                _classPrivateFieldLooseBase(this, _request$5)[_request$5].addFlags(data);
                const compressedData = compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger$7)[_logger$7]);
                let pageLoadUrl = _classPrivateFieldLooseBase(this, _account$6)[_account$6].dataPostURL;
                pageLoadUrl = addToURL(pageLoadUrl, "type", EVT_PUSH);
                pageLoadUrl = addToURL(pageLoadUrl, "d", compressedData);
                _classPrivateFieldLooseBase(this, _request$5)[_request$5].saveAndFireRequest(pageLoadUrl, $ct.blockRequest);
              }
            }
          }
        }
      };
      var _request$4 = _classPrivateFieldLooseKey("request");
      var _logger$6 = _classPrivateFieldLooseKey("logger");
      var _account$5 = _classPrivateFieldLooseKey("account");
      var _session$2 = _classPrivateFieldLooseKey("session");
      var _oldValues$2 = _classPrivateFieldLooseKey("oldValues");
      var _device$2 = _classPrivateFieldLooseKey("device");
      var _processOUL = _classPrivateFieldLooseKey("processOUL");
      var _handleCookieFromCache = _classPrivateFieldLooseKey("handleCookieFromCache");
      var _deleteUser = _classPrivateFieldLooseKey("deleteUser");
      var _processLoginArray = _classPrivateFieldLooseKey("processLoginArray");
      class UserLoginHandler extends Array {
        constructor(_ref, values) {
          let {
            request: request2,
            account: account2,
            session,
            logger: logger2,
            device
          } = _ref;
          super();
          Object.defineProperty(this, _processLoginArray, {
            value: _processLoginArray2
          });
          Object.defineProperty(this, _deleteUser, {
            value: _deleteUser2
          });
          Object.defineProperty(this, _handleCookieFromCache, {
            value: _handleCookieFromCache2
          });
          Object.defineProperty(this, _processOUL, {
            value: _processOUL2
          });
          Object.defineProperty(this, _request$4, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _logger$6, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _account$5, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _session$2, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _oldValues$2, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _device$2, {
            writable: true,
            value: void 0
          });
          _classPrivateFieldLooseBase(this, _request$4)[_request$4] = request2;
          _classPrivateFieldLooseBase(this, _account$5)[_account$5] = account2;
          _classPrivateFieldLooseBase(this, _session$2)[_session$2] = session;
          _classPrivateFieldLooseBase(this, _logger$6)[_logger$6] = logger2;
          _classPrivateFieldLooseBase(this, _oldValues$2)[_oldValues$2] = values;
          _classPrivateFieldLooseBase(this, _device$2)[_device$2] = device;
        }
        // On User Login
        clear() {
          _classPrivateFieldLooseBase(this, _logger$6)[_logger$6].debug("clear called. Reset flag has been set.");
          _classPrivateFieldLooseBase(this, _deleteUser)[_deleteUser]();
          StorageManager.setMetaProp(CLEAR, true);
        }
        push() {
          for (var _len = arguments.length, profilesArr = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            profilesArr[_key2] = arguments[_key2];
          }
          _classPrivateFieldLooseBase(this, _processLoginArray)[_processLoginArray](profilesArr);
          return 0;
        }
        _processOldValues() {
          if (_classPrivateFieldLooseBase(this, _oldValues$2)[_oldValues$2]) {
            _classPrivateFieldLooseBase(this, _processLoginArray)[_processLoginArray](_classPrivateFieldLooseBase(this, _oldValues$2)[_oldValues$2]);
          }
          _classPrivateFieldLooseBase(this, _oldValues$2)[_oldValues$2] = null;
        }
      }
      var _processOUL2 = function _processOUL22(profileArr) {
        let sendOULFlag = true;
        StorageManager.saveToLSorCookie(FIRE_PUSH_UNREGISTERED, sendOULFlag);
        const addToK = (ids) => {
          let k = StorageManager.readFromLSorCookie(KCOOKIE_NAME);
          const g = StorageManager.readFromLSorCookie(GCOOKIE_NAME);
          let kId;
          if (k == null) {
            k = {};
            kId = ids;
          } else {
            kId = k.id;
            let anonymousUser = false;
            let foundInCache = false;
            if (kId == null) {
              kId = ids[0];
              anonymousUser = true;
            }
            if ($ct.LRU_CACHE == null && StorageManager._isLocalStorageSupported()) {
              $ct.LRU_CACHE = new LRUCache(LRU_CACHE_SIZE);
            }
            if (anonymousUser) {
              if (g != null) {
                $ct.LRU_CACHE.set(kId, g);
                $ct.blockRequest = false;
              }
            } else {
              for (const idx in ids) {
                if (ids.hasOwnProperty(idx)) {
                  const id2 = ids[idx];
                  if ($ct.LRU_CACHE.cache[id2]) {
                    kId = id2;
                    foundInCache = true;
                    break;
                  }
                }
              }
            }
            if (foundInCache) {
              if (kId !== $ct.LRU_CACHE.getLastKey()) {
                _classPrivateFieldLooseBase(this, _handleCookieFromCache)[_handleCookieFromCache]();
              } else {
                sendOULFlag = false;
                StorageManager.saveToLSorCookie(FIRE_PUSH_UNREGISTERED, sendOULFlag);
              }
              const gFromCache = $ct.LRU_CACHE.get(kId);
              $ct.LRU_CACHE.set(kId, gFromCache);
              StorageManager.saveToLSorCookie(GCOOKIE_NAME, gFromCache);
              _classPrivateFieldLooseBase(this, _device$2)[_device$2].gcookie = gFromCache;
              const lastK = $ct.LRU_CACHE.getSecondLastKey();
              if (StorageManager.readFromLSorCookie(FIRE_PUSH_UNREGISTERED) && lastK !== -1) {
                const lastGUID = $ct.LRU_CACHE.cache[lastK];
                _classPrivateFieldLooseBase(this, _request$4)[_request$4].unregisterTokenForGuid(lastGUID);
              }
            } else {
              if (!anonymousUser) {
                this.clear();
              } else {
                if (g != null) {
                  _classPrivateFieldLooseBase(this, _device$2)[_device$2].gcookie = g;
                  StorageManager.saveToLSorCookie(GCOOKIE_NAME, g);
                  sendOULFlag = false;
                }
              }
              StorageManager.saveToLSorCookie(FIRE_PUSH_UNREGISTERED, false);
              kId = ids[0];
            }
          }
          k.id = kId;
          StorageManager.saveToLSorCookie(KCOOKIE_NAME, k);
        };
        if (Array.isArray(profileArr) && profileArr.length > 0) {
          for (const index in profileArr) {
            if (profileArr.hasOwnProperty(index)) {
              const outerObj = profileArr[index];
              let data = {};
              let profileObj;
              if (outerObj.Site != null) {
                profileObj = outerObj.Site;
                if (isObjectEmpty(profileObj) || !isProfileValid(profileObj, {
                  logger: _classPrivateFieldLooseBase(this, _logger$6)[_logger$6]
                })) {
                  return;
                }
              } else if (outerObj.Facebook != null) {
                const FbProfileObj = outerObj.Facebook;
                if (!isObjectEmpty(FbProfileObj) && !FbProfileObj.error) {
                  profileObj = processFBUserObj(FbProfileObj);
                }
              } else if (outerObj["Google Plus"] != null) {
                const GPlusProfileObj = outerObj["Google Plus"];
                if (isObjectEmpty(GPlusProfileObj) && !GPlusProfileObj.error) {
                  profileObj = processGPlusUserObj(GPlusProfileObj, {
                    logger: _classPrivateFieldLooseBase(this, _logger$6)[_logger$6]
                  });
                }
              }
              if (profileObj != null && !isObjectEmpty(profileObj)) {
                data.type = "profile";
                if (profileObj.tz == null) {
                  profileObj.tz = (/* @__PURE__ */ new Date()).toString().match(/([A-Z]+[\+-][0-9]+)/)[1];
                }
                data.profile = profileObj;
                const ids = [];
                if (StorageManager._isLocalStorageSupported()) {
                  if (profileObj.Identity) {
                    ids.push(profileObj.Identity);
                  }
                  if (profileObj.Email) {
                    ids.push(profileObj.Email);
                  }
                  if (profileObj.GPID) {
                    ids.push("GP:" + profileObj.GPID);
                  }
                  if (profileObj.FBID) {
                    ids.push("FB:" + profileObj.FBID);
                  }
                  if (ids.length > 0) {
                    addToK(ids);
                  }
                }
                addToLocalProfileMap(profileObj, true);
                data = _classPrivateFieldLooseBase(this, _request$4)[_request$4].addSystemDataToObject(data, void 0);
                _classPrivateFieldLooseBase(this, _request$4)[_request$4].addFlags(data);
                if (sendOULFlag) {
                  data[IS_OUL] = true;
                }
                const compressedData = compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger$6)[_logger$6]);
                let pageLoadUrl = _classPrivateFieldLooseBase(this, _account$5)[_account$5].dataPostURL;
                pageLoadUrl = addToURL(pageLoadUrl, "type", EVT_PUSH);
                pageLoadUrl = addToURL(pageLoadUrl, "d", compressedData);
                _classPrivateFieldLooseBase(this, _request$4)[_request$4].saveAndFireRequest(pageLoadUrl, $ct.blockRequest, sendOULFlag);
              }
            }
          }
        }
      };
      var _handleCookieFromCache2 = function _handleCookieFromCache22() {
        $ct.blockRequest = false;
        console.debug("Block request is false");
        if (StorageManager._isLocalStorageSupported()) {
          delete localStorage[PR_COOKIE];
          delete localStorage[EV_COOKIE];
          delete localStorage[META_COOKIE];
          delete localStorage[ARP_COOKIE];
          delete localStorage[CAMP_COOKIE_NAME];
          delete localStorage[CHARGEDID_COOKIE_NAME];
        }
        StorageManager.removeCookie(CAMP_COOKIE_NAME, getHostName());
        StorageManager.removeCookie(_classPrivateFieldLooseBase(this, _session$2)[_session$2].cookieName, $ct.broadDomain);
        StorageManager.removeCookie(ARP_COOKIE, $ct.broadDomain);
        _classPrivateFieldLooseBase(this, _session$2)[_session$2].setSessionCookieObject("");
      };
      var _deleteUser2 = function _deleteUser22() {
        $ct.blockRequest = true;
        _classPrivateFieldLooseBase(this, _logger$6)[_logger$6].debug("Block request is true");
        $ct.globalCache = {
          gcookie: null,
          REQ_N: 0,
          RESP_N: 0
        };
        if (StorageManager._isLocalStorageSupported()) {
          delete localStorage[GCOOKIE_NAME];
          delete localStorage[KCOOKIE_NAME];
          delete localStorage[PR_COOKIE];
          delete localStorage[EV_COOKIE];
          delete localStorage[META_COOKIE];
          delete localStorage[ARP_COOKIE];
          delete localStorage[CAMP_COOKIE_NAME];
          delete localStorage[CHARGEDID_COOKIE_NAME];
        }
        StorageManager.removeCookie(GCOOKIE_NAME, $ct.broadDomain);
        StorageManager.removeCookie(CAMP_COOKIE_NAME, getHostName());
        StorageManager.removeCookie(KCOOKIE_NAME, getHostName());
        StorageManager.removeCookie(_classPrivateFieldLooseBase(this, _session$2)[_session$2].cookieName, $ct.broadDomain);
        StorageManager.removeCookie(ARP_COOKIE, $ct.broadDomain);
        _classPrivateFieldLooseBase(this, _device$2)[_device$2].gcookie = null;
        _classPrivateFieldLooseBase(this, _session$2)[_session$2].setSessionCookieObject("");
      };
      var _processLoginArray2 = function _processLoginArray22(loginArr) {
        if (Array.isArray(loginArr) && loginArr.length > 0) {
          const profileObj = loginArr.pop();
          const processProfile = profileObj != null && isObject(profileObj) && (profileObj.Site != null && Object.keys(profileObj.Site).length > 0 || profileObj.Facebook != null && Object.keys(profileObj.Facebook).length > 0 || profileObj["Google Plus"] != null && Object.keys(profileObj["Google Plus"]).length > 0);
          if (processProfile) {
            StorageManager.setInstantDeleteFlagInK();
            try {
              _classPrivateFieldLooseBase(this, _processOUL)[_processOUL]([profileObj]);
            } catch (e) {
              _classPrivateFieldLooseBase(this, _logger$6)[_logger$6].debug(e);
            }
          } else {
            _classPrivateFieldLooseBase(this, _logger$6)[_logger$6].error("Profile object is in incorrect format");
          }
        }
      };
      class CTWebPopupImageOnly extends HTMLElement {
        constructor() {
          super();
          this._target = null;
          this._session = null;
          this.shadow = null;
          this.popup = null;
          this.container = null;
          this.resizeObserver = null;
          this.shadow = this.attachShadow({
            mode: "open"
          });
        }
        get target() {
          return this._target || "";
        }
        set target(val) {
          if (this._target === null) {
            this._target = val;
            this.renderImageOnlyPopup();
          }
        }
        get session() {
          return this._session || "";
        }
        set session(val) {
          this._session = val;
        }
        get msgId() {
          return this.target.wzrk_id;
        }
        get pivotId() {
          return this.target.wzrk_pivot;
        }
        get onClickUrl() {
          return this.target.display.onClickUrl;
        }
        get onClickAction() {
          return this.target.display.onClickAction;
        }
        renderImageOnlyPopup() {
          this.shadow.innerHTML = this.getImageOnlyPopupContent();
          this.popup = this.shadowRoot.getElementById("imageOnlyPopup");
          this.container = this.shadowRoot.getElementById("container");
          this.closeIcon = this.shadowRoot.getElementById("close");
          this.popup.addEventListener("load", this.updateImageAndContainerWidth());
          this.resizeObserver = new ResizeObserver(() => this.handleResize(this.popup, this.container));
          this.resizeObserver.observe(this.popup);
          this.closeIcon.addEventListener("click", () => {
            const campaignId = this.target.wzrk_id.split("_")[0];
            const currentSessionId = this.session.sessionId;
            this.resizeObserver.unobserve(this.popup);
            document.getElementById("wzrkImageOnlyDiv").style.display = "none";
            this.remove();
            if (campaignId != null && campaignId !== "-1") {
              if (StorageManager._isLocalStorageSupported()) {
                const campaignObj = getCampaignObject();
                let sessionCampaignObj = campaignObj.wp[currentSessionId];
                if (sessionCampaignObj == null) {
                  sessionCampaignObj = {};
                  campaignObj[currentSessionId] = sessionCampaignObj;
                }
                sessionCampaignObj[campaignId] = "dnd";
                saveCampaignObject(campaignObj);
              }
            }
          });
          if (!this.target.display.preview) {
            window.clevertap.renderNotificationViewed({
              msgId: this.msgId,
              pivotId: this.pivotId
            });
          }
          if (this.onClickUrl) {
            this.popup.addEventListener("click", () => {
              if (!this.target.display.preview) {
                window.clevertap.renderNotificationClicked({
                  msgId: this.msgId,
                  pivotId: this.pivotId
                });
              }
              switch (this.onClickAction) {
                case ACTION_TYPES.OPEN_LINK_AND_CLOSE:
                  this.target.display.window ? window.open(this.onClickUrl, "_blank") : window.parent.location.href = this.onClickUrl;
                  this.closeIcon.click();
                  break;
                case ACTION_TYPES.OPEN_LINK:
                default:
                  this.target.display.window ? window.open(this.onClickUrl, "_blank") : window.parent.location.href = this.onClickUrl;
              }
            });
          }
        }
        handleResize(popup, container2) {
          const width = this.getRenderedImageWidth(popup);
          container2.style.setProperty("width", "".concat(width, "px"));
        }
        getImageOnlyPopupContent() {
          return "\n        ".concat(this.target.msgContent.css, "\n        ").concat(this.target.msgContent.html, "\n      ");
        }
        updateImageAndContainerWidth() {
          return () => {
            const width = this.getRenderedImageWidth(this.popup);
            this.popup.style.setProperty("width", "".concat(width, "px"));
            this.container.style.setProperty("width", "".concat(width, "px"));
            this.container.style.setProperty("height", "auto");
            this.container.style.setProperty("position", "fixed");
            this.popup.style.setProperty("visibility", "visible");
            this.closeIcon.style.setProperty("visibility", "visible");
            document.getElementById("wzrkImageOnlyDiv").style.visibility = "visible";
          };
        }
        getRenderedImageWidth(img) {
          const ratio = img.naturalWidth / img.naturalHeight;
          return img.height * ratio;
        }
      }
      class Message extends HTMLElement {
        constructor(config, message) {
          super();
          this.wrapper = null;
          this.snackBar = null;
          this.shadow = this.attachShadow({
            mode: "open"
          });
          this.config = config;
          this.message = message;
          message && this.renderMessage(message);
        }
        get pivotId() {
          return this.message.wzrk_pivot;
        }
        get campaignId() {
          return this.message.wzrk_id;
        }
        createEl(type, id2, part) {
          const _el = document.createElement(type);
          _el.setAttribute("id", id2);
          _el.setAttribute("part", part || id2);
          return _el;
        }
        renderMessage(msg) {
          this.wrapper = this.createEl("div", "messageWrapper");
          switch (msg.templateType) {
            case "text-only":
            case "text-with-icon":
            case "text-with-icon-and-image": {
              const message = this.prepareBasicMessage(msg.msg[0]);
              this.wrapper.appendChild(message);
            }
          }
          const timeStamp = this.createEl("div", "timeStamp");
          timeStamp.innerHTML = "<span>".concat(determineTimeStampText(msg.id.split("_")[1]), "<span>");
          if (!msg.viewed) {
            const unreadMarker = this.createEl("span", "unreadMarker");
            timeStamp.appendChild(unreadMarker);
          }
          this.wrapper.appendChild(timeStamp);
          this.shadow.appendChild(this.wrapper);
        }
        prepareBasicMessage(msg) {
          const message = this.createEl("div", "message");
          if (msg.imageUrl) {
            const imageContainer = this.addImage(msg.imageUrl, "mainImg");
            message.appendChild(imageContainer);
          }
          const iconTitleDescWrapper = this.createEl("div", "iconTitleDescWrapper");
          if (msg.iconUrl) {
            const iconContainer = this.addImage(msg.iconUrl, "iconImg");
            iconTitleDescWrapper.appendChild(iconContainer);
          }
          const titleDescWrapper = this.createEl("div", "titleDescWrapper");
          if (msg.title) {
            const title = this.createEl("div", "title");
            title.innerText = msg.title;
            titleDescWrapper.appendChild(title);
          }
          if (msg.description) {
            const description = this.createEl("div", "description");
            description.innerText = msg.description;
            titleDescWrapper.appendChild(description);
          }
          if (msg.title || msg.description) {
            iconTitleDescWrapper.appendChild(titleDescWrapper);
          }
          if (msg.iconUrl || msg.title || msg.description) {
            message.appendChild(iconTitleDescWrapper);
          }
          if (msg.buttons && msg.buttons.length) {
            const buttonsContainer = this.addButtons(msg.buttons);
            message.appendChild(buttonsContainer);
          }
          return message;
        }
        addButtons() {
          let buttons = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          const buttonsContainer = this.createEl("div", "buttonsContainer");
          let hasCopyAction = false;
          buttons.forEach((b, i) => {
            const button = this.createEl("button", "button-".concat(i), "button");
            button.innerText = b.text;
            if (i > 0) {
              button.style.cssText += "margin-left: 2px;";
            }
            if (b.action === "copy") {
              hasCopyAction = true;
            }
            buttonsContainer.appendChild(button);
          });
          if (hasCopyAction) {
            this.addSnackbar(buttonsContainer);
          }
          return buttonsContainer;
        }
        addSnackbar(buttonsContainer) {
          this.snackBar = this.createEl("div", "snackbar-".concat(this.campaignId), "snackbar");
          this.snackBar.innerHTML = greenTickSvg;
          const clipboardMsg = this.createEl("span", "snackbar-msg-".concat(this.campaignId), "snackbar-msg");
          clipboardMsg.innerText = "Copied to clipboard";
          this.snackBar.appendChild(clipboardMsg);
          buttonsContainer.appendChild(this.snackBar);
        }
        addImage(url, type) {
          const imageContainer = this.createEl("div", "".concat(type, "Container"));
          const image = this.createEl("img", type);
          image.setAttribute("src", url);
          image.setAttribute("loading", "lazy");
          imageContainer.appendChild(image);
          return imageContainer;
        }
        raiseClickedEvent(path, isPreview) {
          switch (this.message.templateType) {
            case "text-only":
            case "text-with-icon":
            case "text-with-icon-and-image": {
              this.raiseClickedForBasicTemplates(path, isPreview);
            }
          }
        }
        raiseClickedForBasicTemplates(path, isPreview) {
          const msg = this.message.msg[0];
          const payload = {
            msgId: this.campaignId,
            pivotId: this.pivotId
          };
          if (path.tagName === "BUTTON") {
            const id2 = path.id.split("-")[1];
            const button = msg.buttons[id2];
            payload.kv = {
              wzrk_c2a: button.text
            };
            if (button.action === "url") {
              button.openUrlInNewTab ? window.open(button.url, "_blank") : window.location = button.url;
            } else if (button.action === "copy") {
              window.focus();
              navigator.clipboard.writeText(button.clipboardText);
              this.snackBar.style.setProperty("display", "flex", "important");
              setTimeout(() => {
                this.snackBar.style.setProperty("display", "none", "important");
              }, 2e3);
            }
          } else if (path.tagName === "CT-INBOX-MESSAGE" && msg.onClickUrl) {
            msg.openUrlInNewTab ? window.open(msg.onClickUrl, "_blank") : window.location = msg.onClickUrl;
          }
          if (isPreview) {
            console.log("Notifiction clicked event will be raised at run time with payload ::", payload);
          } else {
            window.clevertap.renderNotificationClicked(payload);
          }
        }
      }
      const messageStyles = (_ref) => {
        let {
          backgroundColor,
          borderColor,
          titleColor,
          descriptionColor,
          buttonColor,
          buttonTextColor,
          unreadMarkerColor
        } = _ref;
        return '\n    <style id="messageStyles">\n      ct-inbox-message::part(messageWrapper) {\n        margin-bottom: 16px; \n      }\n      ct-inbox-message::part(message) {\n        background-color: '.concat(backgroundColor, "; \n        border: 1px solid ").concat(borderColor, ";\n        border-radius: 4px; \n        overflow: hidden;\n        min-height: 40px;\n      }\n      ct-inbox-message::part(message):hover {\n        box-shadow: 0px 4px 8px rgb(0 0 0 / 10%);\n        cursor: pointer;\n      }\n      ct-inbox-message::part(iconTitleDescWrapper) {\n        display: flex; \n        padding: 16px;\n      }\n      ct-inbox-message::part(titleDescWrapper) {\n        display: flex; \n        flex-direction: column;\n      }\n      ct-inbox-message::part(iconImgContainer) {\n        display: flex; \n        margin-right: 16px;\n      }\n      ct-inbox-message::part(mainImgContainer) {\n        line-height: 0;\n      }\n      ct-inbox-message::part(mainImg) {\n        width: 100%; \n        background: #b2b1ae;\n      }\n      ct-inbox-message::part(iconImg) {\n        height: 40px; \n        width: 40px;\n      }\n      ct-inbox-message::part(title) {\n        font-size: 14px !important; \n        line-height: 20px; \n        font-weight: 600; \n        color: ").concat(titleColor, "\n      }\n      ct-inbox-message::part(description) {\n        font-size: 14px !important; \n        line-height: 20px; \n        font-weight: 400; \n        color: ").concat(descriptionColor, "\n      }\n      ct-inbox-message::part(button) {\n        background-color: ").concat(buttonColor, "; \n        color: ").concat(buttonTextColor, "; \n        padding: 8px 16px; \n        font-size: 12px; \n        line-height: 16px; \n        font-weight: 600; \n        flex: 1; \n        border-radius: 0px; \n        text-transform: capitalize; \n        cursor: pointer; \n        border: none;\n      }\n      ct-inbox-message::part(buttonsContainer) {\n        display: flex;\n        position: relative;\n      }\n      ct-inbox-message::part(snackbar) {\n        position: absolute;\n        top: calc(-100% - 12px);\n        left: 50%;\n        transform: translate(-50%, 0px);\n        font-size: 14px;\n        font-weight: 400;\n        background: #FFFFFF;\n        border: 1px solid #ECEDF2;\n        box-shadow: 0px 4px 8px rgb(0 0 0 / 6%), 0px 0px 2px rgb(0 0 0 / 4%);\n        border-radius: 4px;\n        z-index: 2;\n        display: none;\n        width: max-content;\n        align-items: center;\n        padding: 8px 16px;\n        justify-content: center;\n      }\n\n      ct-inbox-message::part(snackbar-msg) {\n        color: black;\n        margin-left: 8px;\n      }\n\n      ct-inbox-message::part(timeStamp) {\n        display: flex; \n        justify-content: end; \n        align-items: center; \n        margin-top: 4px; \n        font-size: 12px !important; \n        line-height: 16px; \n        color: black;\n      }\n      ct-inbox-message::part(unreadMarker) {\n        height: 8px; \n        width: 8px; \n        border-radius: 50%; \n        background-color: ").concat(unreadMarkerColor, "; \n        margin-left: 8px;\n      }\n      @media only screen and (min-width: 420px) {\n        ct-inbox-message::part(mainImg) {\n          height: 180px;\n        }\n      }\n    </style>\n  ");
      };
      const inboxContainerStyles = (_ref2) => {
        let {
          panelBackgroundColor,
          panelBorderColor,
          headerBackgroundColor,
          headerTitleColor,
          closeIconColor,
          categoriesTabColor,
          categoriesTitleColor,
          categoriesBorderColor,
          selectedCategoryTabColor,
          selectedCategoryTitleColor,
          selectedCategoryBorderColor,
          headerCategoryHeight
        } = _ref2;
        return '\n      <style id="webInboxStyles">\n        #inbox {\n          width: 100%;\n          position: fixed;\n          background-color: #fff; \n          display: none; \n          box-shadow: 0px 2px 10px 0px #d7d7d791;\n          background-color: '.concat(panelBackgroundColor, "; \n          border: 1px solid ").concat(panelBorderColor, ";\n          top: 0;\n          left: 0;\n          height: 100%;\n          overflow: auto;\n          z-index: 1;\n          box-sizing: content-box;\n          border-radius: 4px;\n        }\n  \n        #emptyInboxMsg {\n          display: block;\n          padding: 10px;\n          text-align: center;\n          color: black;\n        }\n  \n        #header {\n          height: 36px; \n          width: 100%; \n          display: flex; \n          justify-content: center; \n          align-items: center; \n          background-color: ").concat(headerBackgroundColor, "; \n          background-color: var(--card-bg, ").concat(headerBackgroundColor, ");\n          color: ").concat(headerTitleColor, ";\n          position: sticky;\n          top: 0;\n        }\n  \n        #closeInbox {\n          font-size: 20px; \n          margin-right: 12px; \n          color: ").concat(closeIconColor, "; \n          cursor: pointer;\n        }\n  \n        #headerTitle {\n          font-size: 14px; \n          line-height: 20px; \n          flex-grow: 1; \n          font-weight: 700; \n          text-align: center;\n          flex-grow: 1;\n          text-align: center;\n        }\n  \n        #categoriesContainer {\n          padding: 16px 16px 0 16px; \n          height: 32px; \n          display: flex;\n          scroll-behavior: smooth;\n          position: relative;\n          z-index: -1;\n        }\n\n        #categoriesWrapper {\n          height: 32px; \n          overflow-x: scroll;\n          display: flex;\n          white-space: nowrap;\n          scrollbar-width: none;\n        }\n\n        #categoriesWrapper::-webkit-scrollbar {\n          display: none;\n        }\n  \n        #leftArrow, #rightArrow {\n          height: 32px;\n          align-items: center;\n          font-weight: 700;\n          position: absolute;\n          z-index: 2;\n          pointer-events: auto;\n          cursor: pointer;\n          display: none;\n        }\n\n        #leftArrow {\n          left: 0;\n          padding-left: 4px;\n          padding-right: 16px;\n          background: linear-gradient(90deg, ").concat(panelBackgroundColor, " 0%, ").concat(panelBackgroundColor, "99 80%, ").concat(panelBackgroundColor, "0d 100%);\n        }\n\n        #rightArrow {\n          right: 0;\n          padding-right: 4px;\n          padding-left: 16px;\n          background: linear-gradient(-90deg, ").concat(panelBackgroundColor, " 0%, ").concat(panelBackgroundColor, "99 80%, ").concat(panelBackgroundColor, '0d 100%);\n        }\n\n        [id^="category-"] {\n          display: flex; \n          flex: 1 1 0; \n          justify-content: center; \n          align-items: center; \n          font-size: 14px; \n          line-height: 20px; \n          background-color: ').concat(categoriesTabColor, "; \n          color: ").concat(categoriesTitleColor, "; \n          cursor: pointer;\n          padding: 6px 24px;\n          margin: 0 3px;\n          border-radius: 16px;\n          border: ").concat(categoriesBorderColor ? "1px solid " + categoriesBorderColor : "none", ';\n        }\n\n        [id^="category-"][selected="true"] {\n          background-color: ').concat(selectedCategoryTabColor, "; \n          color: ").concat(selectedCategoryTitleColor, "; \n          border: ").concat(selectedCategoryBorderColor ? "1px solid " + selectedCategoryBorderColor : "none", "\n        }\n  \n        #inboxCard {\n          padding: 0 16px 0 16px;\n          overflow-y: auto;\n          box-sizing: border-box;\n          margin-top: 16px;\n          height: 100%;\n          overflow: scroll;\n        }\n\n        @media only screen and (min-width: 480px) {\n          #inbox {\n            width: var(--inbox-width, 392px);\n            height: var(--inbox-height, 546px);\n            position: var(--inbox-position, fixed);\n            right: var(--inbox-right, unset);\n            bottom: var(--inbox-bottom, unset);\n            top: var(--inbox-top, unset);\n            left: var(--inbox-left, unset);\n          }\n  \n          #inboxCard {\n            height: calc(var(--inbox-height, 546px) - ").concat(headerCategoryHeight, "px); \n          }\n  \n        }\n      </style>\n      ");
      };
      class Inbox extends HTMLElement {
        constructor(logger2) {
          super();
          this.isInboxOpen = false;
          this.isInboxFromFlutter = false;
          this.selectedCategory = null;
          this.unviewedMessages = {};
          this.unviewedCounter = 0;
          this.isPreview = false;
          this.inboxConfigForPreview = {};
          this.inboxSelector = null;
          this.inbox = null;
          this.emptyInboxMsg = null;
          this.inboxCard = null;
          this.unviewedBadge = null;
          this.observer = null;
          this.selectedCategoryRef = null;
          this.addClickListenerOnDocument = /* @__PURE__ */ (() => {
            return (e) => {
              if (e.composedPath().includes(this.inbox)) {
                const path = e.path || e.composedPath && e.composedPath();
                if (path.length) {
                  const id2 = path[0].id;
                  if (id2 === "closeInbox") {
                    this.toggleInbox();
                  } else if (id2.startsWith("category-")) {
                    this.prevCategoryRef = this.selectedCategoryRef;
                    this.selectedCategoryRef = path[0];
                    this.updateActiveCategory(path[0].innerText);
                  } else {
                    const _path = path.filter((p) => {
                      var _p$id;
                      return ((_p$id = p.id) === null || _p$id === void 0 ? void 0 : _p$id.startsWith("button-")) || p.tagName === "CT-INBOX-MESSAGE";
                    });
                    if (_path.length) {
                      const messageEl = _path[_path.length - 1];
                      messageEl.raiseClickedEvent(_path[0], this.isPreview);
                    }
                  }
                }
              } else if (this.checkForWebInbox(e) || this.isInboxOpen) {
                if (this.isInboxFromFlutter) {
                  this.isInboxFromFlutter = false;
                } else {
                  this.toggleInbox(e);
                }
              }
            };
          })();
          this.setBadgeStyle = (msgCount) => {
            if (this.unviewedBadge !== null) {
              this.unviewedBadge.innerText = msgCount > 9 ? "9+" : msgCount;
              const shouldShowUnviewedBadge = msgCount > 0 && document.getElementById(this.config.inboxSelector);
              this.unviewedBadge.style.display = shouldShowUnviewedBadge ? "flex" : "none";
            }
          };
          this.logger = logger2;
          this.shadow = this.attachShadow({
            mode: "open"
          });
        }
        get incomingMessages() {
          return [];
        }
        set incomingMessages(msgs) {
          if (msgs === void 0) {
            msgs = [];
          }
          if (msgs.length > 0) {
            this.updateInboxMessages(msgs);
          }
        }
        get incomingMessagesForPreview() {
          return [];
        }
        set incomingMessagesForPreview(msgs) {
          if (msgs === void 0) {
            msgs = [];
          }
          const previewMsgs = {};
          if (msgs.length > 0 && this.inbox) {
            this.isPreview = true;
            this.unviewedCounter = 0;
            msgs.forEach((m) => {
              const key = "".concat(m.wzrk_id.split("_")[0], "_").concat(Date.now());
              m.id = key;
              previewMsgs[key] = m;
              this.unviewedMessages[key] = m;
              this.unviewedCounter++;
            });
            this.buildUIForMessages(previewMsgs);
            this.updateUnviewedBadgeCounter();
          }
        }
        connectedCallback() {
          this.init();
        }
        init() {
          this.config = this.isPreview ? this.inboxConfigForPreview : StorageManager.readFromLSorCookie(WEBINBOX_CONFIG) || {};
          if (Object.keys(this.config).length === 0) {
            return;
          }
          this.inboxSelector = document.getElementById(this.config.inboxSelector);
          if (this.inboxSelector === null) {
            return;
          }
          if (this.config.styles.notificationsBadge) {
            this.addUnviewedBadge();
          } else if (this.unviewedBadge) {
            this.unviewedBadge.remove();
          }
          this.createinbox();
          document.removeEventListener("click", this.addClickListenerOnDocument);
          document.addEventListener("click", this.addClickListenerOnDocument);
          this.config.categories.length && this.updateActiveCategory(this.selectedCategoryRef.innerText);
          this.shadow.innerHTML = this.getInboxStyles();
          this.shadow.appendChild(this.inbox);
        }
        addMsgsToInboxFromLS() {
          const messages = this.deleteExpiredAndGetUnexpiredMsgs(false);
          const msgIds = messages ? Object.keys(messages) : [];
          if (msgIds.length === 0) {
            return;
          }
          msgIds.forEach((m) => {
            if (!messages[m].viewed) {
              this.unviewedMessages[m] = messages[m];
              this.unviewedCounter++;
            }
          });
          this.buildUIForMessages(messages);
          this.updateUnviewedBadgeCounter();
        }
        /**
         * @param {*} deleteMsgsFromUI - If this param is true, then we'll have to check the UI and delete expired messages from the DOM
         * It'll be false when you are building the inbox layout for the very first time.
         *
         * This method reads the inbox messages from LS,
         * based on the deleteMsgsFromUI flag deletes the expired messages from UI and decrements the unviewed counter if the message was not viewed,
         * sorts the messages based on the date,
         * saves the unexpired messages to LS
         * and returns the sorted unexpired messages
         *
         * Scenarios when we encounter expired messages -
         * 1. building ui for the 1st time, no need to decrement the unviewed counter as the correct count will be set at the time of rendering
         * 2. UI is already built (deleteMsgsFromUI = true) and you open the inbox
         *    a. You'll find the expired msg in inbox
         *    b. You'll not find the expired msg in inbox.
         *       This happens when we receive new messages from LC, increment unviewed counter, save it in LS. (We build the UI only when the user opens inbox.)
         *  In both the above scenarios, we'll still have to decrement the unviewed counter if the message was not viewed.
         */
        deleteExpiredAndGetUnexpiredMsgs() {
          let deleteMsgsFromUI = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          let messages = getInboxMessages();
          const now = Math.floor(Date.now() / 1e3);
          for (const msg in messages) {
            if (messages[msg].wzrk_ttl && messages[msg].wzrk_ttl > 0 && messages[msg].wzrk_ttl < now) {
              if (deleteMsgsFromUI && this.inbox) {
                const el = this.shadowRoot.getElementById(messages[msg].id);
                el && el.remove();
                if (!messages[msg].viewed) {
                  this.unviewedCounter--;
                  this.updateUnviewedBadgeCounter();
                }
              }
              delete messages[msg];
            }
          }
          if (messages && messages.length > 0) {
            messages = Object.values(messages).sort((a, b) => b.date - a.date).reduce((acc, m) => {
              acc[m.id] = m;
              return acc;
            }, {});
          }
          saveInboxMessages(messages);
          return messages;
        }
        updateInboxMessages() {
          let msgs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          const inboxMsgs = this.deleteExpiredAndGetUnexpiredMsgs();
          const date = Date.now();
          const incomingMsgs = {};
          msgs.forEach((m, i) => {
            const key = "".concat(m.wzrk_id.split("_")[0], "_").concat(Date.now());
            m.id = key;
            m.date = date - i;
            m.viewed = 0;
            inboxMsgs[key] = m;
            incomingMsgs[key] = m;
            this.unviewedMessages[key] = m;
            this.unviewedCounter++;
          });
          saveInboxMessages(inboxMsgs);
          if (this.inbox) {
            this.buildUIForMessages(incomingMsgs);
            this.updateUnviewedBadgeCounter();
          }
        }
        createEl(type, id2, part) {
          const _el = document.createElement(type);
          _el.setAttribute("id", id2);
          _el.setAttribute("part", part || id2);
          return _el;
        }
        addUnviewedBadge() {
          if (!this.unviewedBadge) {
            this.unviewedBadge = this.createEl("div", "unviewedBadge");
            this.unviewedBadge.style.cssText = "display: none; position: absolute; height: 16px; width: 26px; border-radius: 8px; background-color: ".concat(this.config.styles.notificationsBadge.backgroundColor, "; font-size: 12px; color: ").concat(this.config.styles.notificationsBadge.textColor, "; font-weight: bold; align-items: center; justify-content: center;");
            document.body.appendChild(this.unviewedBadge);
          }
          this.updateUnviewedBadgePosition();
          window.addEventListener("resize", () => {
            this.updateUnviewedBadgePosition();
          });
        }
        updateUnviewedBadgePosition() {
          try {
            const inboxNode = document.getElementById(this.config.inboxSelector) || this.inboxSelector;
            const {
              top,
              right
            } = inboxNode.getBoundingClientRect();
            this.unviewedBadge.style.top = "".concat(top - 8, "px");
            this.unviewedBadge.style.left = "".concat(right - 8, "px");
          } catch (error) {
            this.logger.debug("Error updating unviewed badge position:", error);
          }
        }
        createinbox() {
          this.inbox = this.createEl("div", "inbox");
          const header = this.createEl("div", "header");
          const headerTitle = this.createEl("div", "headerTitle");
          headerTitle.innerText = this.config.title;
          const closeIcon = this.createEl("div", "closeInbox");
          closeIcon.innerHTML = "&times";
          header.appendChild(headerTitle);
          header.appendChild(closeIcon);
          this.inbox.appendChild(header);
          if (this.config.categories.length) {
            const categories = this.createCategories();
            this.inbox.appendChild(categories);
          }
          this.inboxCard = this.createEl("div", "inboxCard");
          this.inbox.appendChild(this.inboxCard);
          this.emptyInboxMsg = this.createEl("div", "emptyInboxMsg");
          this.emptyInboxMsg.innerText = "All messages will be displayed here.";
          this.inboxCard.appendChild(this.emptyInboxMsg);
          const options = {
            root: this.inboxCard,
            rootMargin: "0px",
            threshold: 0.5
          };
          this.observer = new IntersectionObserver((entries, observer) => {
            this.handleMessageViewed(entries);
          }, options);
          this.addMsgsToInboxFromLS();
        }
        createCategories() {
          const categoriesContainer = this.createEl("div", "categoriesContainer");
          const leftArrow = this.createEl("div", "leftArrow");
          leftArrow.innerHTML = arrowSvg;
          leftArrow.children[0].style = "transform: rotate(180deg)";
          leftArrow.addEventListener("click", () => {
            this.shadowRoot.getElementById("categoriesWrapper").scrollBy(-70, 0);
          });
          categoriesContainer.appendChild(leftArrow);
          const categoriesWrapper = this.createEl("div", "categoriesWrapper");
          const _categories = ["All", ...this.config.categories];
          _categories.forEach((c, i) => {
            const category = this.createEl("div", "category-".concat(i), "category");
            category.innerText = c;
            if (i === 0) {
              this.selectedCategoryRef = category;
            }
            categoriesWrapper.appendChild(category);
          });
          categoriesContainer.appendChild(categoriesWrapper);
          const rightArrow = this.createEl("div", "rightArrow");
          rightArrow.innerHTML = arrowSvg;
          rightArrow.addEventListener("click", () => {
            this.shadowRoot.getElementById("categoriesWrapper").scrollBy(70, 0);
          });
          categoriesContainer.appendChild(rightArrow);
          const options = {
            root: categoriesContainer,
            threshold: 0.9
          };
          const firstCategory = categoriesWrapper.children[0];
          const lastCategory = categoriesWrapper.children[this.config.categories.length];
          const firstCategoryObserver = new IntersectionObserver((e) => {
            this.categoryObserverCb(leftArrow, e[0].intersectionRatio >= 0.9);
          }, options);
          firstCategoryObserver.observe(firstCategory);
          const lastCategoryObserver = new IntersectionObserver((e) => {
            this.categoryObserverCb(rightArrow, e[0].intersectionRatio >= 0.9);
          }, options);
          lastCategoryObserver.observe(lastCategory);
          return categoriesContainer;
        }
        categoryObserverCb(el, hide) {
          if (!el) {
            return;
          }
          el.style.display = hide ? "none" : "flex";
        }
        updateActiveCategory(activeCategory) {
          this.selectedCategory = activeCategory;
          this.inboxCard.scrollTop = 0;
          let counter = 0;
          this.prevCategoryRef && this.prevCategoryRef.setAttribute("selected", "false");
          this.selectedCategoryRef.setAttribute("selected", "true");
          this.inboxCard.childNodes.forEach((c) => {
            if (c.getAttribute("id") !== "emptyInboxMsg") {
              c.style.display = this.selectedCategory === "All" || c.getAttribute("category") === this.selectedCategory ? "block" : "none";
              if (c.style.display === "block") {
                counter++;
              }
            }
          });
          if (counter === 0) {
            this.emptyInboxMsg.innerText = "".concat(activeCategory, " messages will be displayed here.");
            this.emptyInboxMsg.style.display = "block";
          } else {
            this.emptyInboxMsg.style.display = "none";
          }
        }
        buildUIForMessages() {
          var _this$config$maxMsgsI;
          let messages = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          !this.isPreview && this.updateTSForRenderedMsgs();
          this.inboxCard.scrollTop = 0;
          const maxMsgsInInbox = (_this$config$maxMsgsI = this.config.maxMsgsInInbox) !== null && _this$config$maxMsgsI !== void 0 ? _this$config$maxMsgsI : MAX_INBOX_MSG;
          const firstChild = this.inboxCard.firstChild;
          const sortedMsgs = Object.values(messages).sort((a, b) => b.date - a.date).map((m) => m.id);
          for (const m of sortedMsgs) {
            const item = new Message(this.config, messages[m]);
            item.setAttribute("id", messages[m].id);
            item.setAttribute("pivot", messages[m].wzrk_pivot);
            item.setAttribute("part", "ct-inbox-message");
            if (this.config.categories.length > 0) {
              item.setAttribute("category", messages[m].tags[0] || "");
              item.style.display = this.selectedCategory === "All" || messages[m].category === this.selectedCategory ? "block" : "none";
            } else {
              item.style.display = "block";
            }
            this.inboxCard.insertBefore(item, firstChild);
            this.observer.observe(item);
          }
          let msgTotalCount = this.inboxCard.querySelectorAll("ct-inbox-message").length;
          while (msgTotalCount > maxMsgsInInbox) {
            const ctInboxMsgs = this.inboxCard.querySelectorAll("ct-inbox-message");
            if (ctInboxMsgs.length > 0) {
              ctInboxMsgs[ctInboxMsgs.length - 1].remove();
            }
            msgTotalCount--;
          }
          const hasMessages = this.inboxCard.querySelectorAll('ct-inbox-message[style*="display: block"]').length;
          this.emptyInboxMsg.style.display = hasMessages ? "none" : "block";
        }
        /**
         * Adds a click listener on the document. For every click we check
         * 1. if the click has happenned within the inbox
         *    - on close button, we close the inbox
         *    - on any of the category, we set that as the activeCategory
         *    - on any of the message, we mark raise notification clicked event. To identify the clicks on a button, we have p.id.startsWith('button-')
         * 2. if the user has clicked on the inboxSelector, we toggle inbox
         * 3. if the click is anywhere else on the UI and the inbox is open, we simply close it
         */
        /**
         * Checks if the current event target is part of the stored inboxSelector or the inboxSelector in the document.
         *
         * @param {Event} e - The event object to check.
         * @returns {boolean} - Returns true if the event target is within the inboxSelector, otherwise false.
         */
        checkForWebInbox(e) {
          var _this$inboxSelector;
          const config = StorageManager.readFromLSorCookie(WEBINBOX_CONFIG) || {};
          const inboxElement = document.getElementById(config.inboxSelector);
          return ((_this$inboxSelector = this.inboxSelector) === null || _this$inboxSelector === void 0 ? void 0 : _this$inboxSelector.contains(e.target)) || (inboxElement === null || inboxElement === void 0 ? void 0 : inboxElement.contains(e.target));
        }
        /**
         * This function will be called every time when a message comes into the inbox viewport and it's visibility increases to 50% or drops below 50%
         * If a msg is 50% visible in the UI, we need to mark the message as viewed in LS and raise notification viewed event
         */
        handleMessageViewed(entries) {
          const raiseViewedEvent = !this.isPreview;
          if (this.isInboxOpen) {
            entries.forEach((e) => {
              if (e.isIntersecting && this.unviewedMessages.hasOwnProperty(e.target.id) && e.target.message.viewed === 0) {
                e.target.message.viewed = 1;
                if (raiseViewedEvent) {
                  window.clevertap.renderNotificationViewed({
                    msgId: e.target.campaignId,
                    pivotId: e.target.pivotId
                  });
                  this.updateMessageInLS(e.target.id, {
                    ...e.target.message,
                    viewed: 1
                  });
                  setTimeout(() => {
                    e.target.shadowRoot.getElementById("unreadMarker").style.display = "none";
                  }, 1e3);
                } else {
                  console.log("Notifiction viewed event will be raised at run time with payload ::", {
                    msgId: e.target.campaignId,
                    pivotId: e.target.pivotId
                  });
                }
                this.unviewedCounter--;
                this.updateUnviewedBadgeCounter();
                delete this.unviewedMessages[e.target.id];
              }
            });
          }
        }
        updateMessageInLS(key, value) {
          if (!this.isPreview) {
            const messages = getInboxMessages();
            messages[key] = value;
            saveInboxMessages(messages);
          }
        }
        // create a separte fn fro refactoring
        toggleInbox(e) {
          this.isInboxOpen = !this.isInboxOpen;
          this.isInboxFromFlutter = !!(e === null || e === void 0 ? void 0 : e.rect);
          if (this.isInboxOpen) {
            this.inboxCard.scrollTop = 0;
            !this.isPreview && this.deleteExpiredAndGetUnexpiredMsgs();
            this.inbox.style.display = "block";
            this.inbox.style.zIndex = "2147483647";
            if (this.config.categories.length) {
              this.selectedCategoryRef.setAttribute("selected", "false");
              this.selectedCategoryRef = this.shadowRoot.getElementById("category-0");
              this.updateActiveCategory(this.selectedCategoryRef.innerText);
              this.shadowRoot.getElementById("categoriesWrapper").scrollLeft -= this.shadowRoot.getElementById("categoriesWrapper").scrollWidth;
            }
            this.setInboxPosition(e);
          } else {
            this.inbox.style.display = "none";
          }
        }
        setInboxPosition(e) {
          const windowWidth = window.outerWidth;
          const customInboxStyles = getComputedStyle($ct.inbox);
          const top = customInboxStyles.getPropertyValue("--inbox-top");
          const bottom = customInboxStyles.getPropertyValue("--inbox-bottom");
          const left = customInboxStyles.getPropertyValue("--inbox-left");
          const right = customInboxStyles.getPropertyValue("--inbox-right");
          const hasPositionDefined = top || bottom || left || right;
          if (windowWidth > 481 && !hasPositionDefined) {
            const res = getInboxPosition(e, this.inbox.clientHeight, this.inbox.clientWidth);
            const xPos = res.xPos;
            const yPos = res.yPos;
            this.inbox.style.top = yPos + "px";
            this.inbox.style.left = xPos + "px";
          }
        }
        /**
         * Updates the UI with the number of unviewed messages
         * If there are more than 9 unviewed messages, we show the count as 9+
         * Only show this badge if the current document has the inboxNode
         */
        updateUnviewedBadgeCounter() {
          if (this.isPreview) {
            this.setBadgeStyle(this.unviewedCounter);
            return;
          }
          let counter = 0;
          this.inboxCard.querySelectorAll("ct-inbox-message").forEach((m) => {
            const messages = getInboxMessages();
            if (messages[m.id] && messages[m.id].viewed === 0) {
              counter++;
            }
          });
          this.setBadgeStyle(counter);
        }
        updateTSForRenderedMsgs() {
          this.inboxCard.querySelectorAll("ct-inbox-message").forEach((m) => {
            const ts = m.id.split("_")[1];
            m.shadow.getElementById("timeStamp").firstChild.innerText = determineTimeStampText(ts);
          });
        }
        getInboxStyles() {
          const headerHeight = 36;
          const categoriesHeight = this.config.categories.length ? 64 : 16;
          const styles = {
            panelBackgroundColor: this.config.styles.panelBackgroundColor,
            panelBorderColor: this.config.styles.panelBorderColor,
            headerBackgroundColor: this.config.styles.header.backgroundColor,
            headerTitleColor: this.config.styles.header.titleColor,
            closeIconColor: this.config.styles.closeIconColor,
            categoriesTabColor: this.config.styles.categories.tabColor,
            categoriesTitleColor: this.config.styles.categories.titleColor,
            selectedCategoryTabColor: this.config.styles.categories.selectedTab.tabColor,
            selectedCategoryTitleColor: this.config.styles.categories.selectedTab.titleColor,
            headerCategoryHeight: headerHeight + categoriesHeight
          };
          if (this.config.styles.categories.borderColor) {
            styles.categoriesBorderColor = this.config.styles.categories.borderColor;
          }
          if (this.config.styles.categories.selectedTab.borderColor) {
            styles.selectedCategoryBorderColor = this.config.styles.categories.selectedTab.borderColor;
          }
          const inboxStyles = inboxContainerStyles(styles);
          const cardStyles = this.config.styles.cards;
          const msgStyles = messageStyles({
            backgroundColor: cardStyles.backgroundColor,
            borderColor: cardStyles.borderColor,
            titleColor: cardStyles.titleColor,
            descriptionColor: cardStyles.descriptionColor,
            buttonColor: cardStyles.buttonColor,
            buttonTextColor: cardStyles.buttonTextColor,
            unreadMarkerColor: cardStyles.unreadMarkerColor
          });
          return inboxStyles + msgStyles;
        }
      }
      const processWebInboxSettings = function(webInboxSetting) {
        let isPreview = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const _settings = StorageManager.readFromLSorCookie(WEBINBOX_CONFIG) || {};
        if (isPreview) {
          $ct.inbox.inboxConfigForPreview = webInboxSetting;
          $ct.inbox.isPreview = true;
          $ct.inbox && $ct.inbox.init();
        } else if (JSON.stringify(_settings) !== JSON.stringify(webInboxSetting)) {
          StorageManager.saveToLSorCookie(WEBINBOX_CONFIG, webInboxSetting);
          $ct.inbox && $ct.inbox.init();
        }
      };
      const processInboxNotifs = (msg) => {
        if (msg.inbox_preview) {
          $ct.inbox.incomingMessagesForPreview = msg.inbox_notifs;
        } else {
          $ct.inbox.incomingMessages = msg;
        }
      };
      const addWebInbox = (logger2) => {
        checkAndRegisterWebInboxElements();
        $ct.inbox = new Inbox({
          logger: logger2
        });
        document.body.appendChild($ct.inbox);
      };
      const getAndMigrateInboxMessages = (guid) => {
        const messages = StorageManager.readFromLSorCookie(WEBINBOX) || {};
        if (Object.keys(messages).length > 0 && Object.keys(messages)[0].includes("_")) {
          const gudInboxObj = {};
          gudInboxObj[guid] = messages;
          StorageManager.saveToLSorCookie(WEBINBOX, gudInboxObj);
          return gudInboxObj;
        }
        return messages;
      };
      const getInboxMessages = () => {
        const guid = JSON.parse(decodeURIComponent(StorageManager.read(GCOOKIE_NAME)));
        if (!isValueValid(guid)) {
          return {};
        }
        const messages = getAndMigrateInboxMessages(guid);
        return messages.hasOwnProperty(guid) ? messages[guid] : {};
      };
      const saveInboxMessages = (messages) => {
        const guid = JSON.parse(decodeURIComponent(StorageManager.read(GCOOKIE_NAME)));
        if (!isValueValid(guid)) {
          return;
        }
        const storedInboxObj = getAndMigrateInboxMessages(guid);
        const newObj = {
          ...storedInboxObj,
          [guid]: messages
        };
        StorageManager.saveToLSorCookie(WEBINBOX, newObj);
      };
      const initializeWebInbox = (logger2) => {
        return new Promise((resolve, reject) => {
          const retryUntil = function(condition) {
            let interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 500;
            let maxRetries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 20;
            return new Promise((resolve2, reject2) => {
              let attempts = 0;
              const retry = setInterval(() => {
                logger2.debug("Retry attempt: ".concat(attempts + 1));
                if (condition()) {
                  clearInterval(retry);
                  resolve2();
                } else if ($ct.inbox !== null) {
                  clearInterval(retry);
                  resolve2();
                } else if (attempts >= maxRetries) {
                  clearInterval(retry);
                  reject2(new Error("Condition not met within max retries"));
                }
                attempts++;
              }, interval);
            });
          };
          const addInboxSafely = () => {
            if ($ct.inbox === null) {
              addWebInbox(logger2);
            }
          };
          const checkElementCondition = () => {
            const config = StorageManager.readFromLSorCookie(WEBINBOX_CONFIG) || {};
            return document.getElementById(config.inboxSelector) && $ct.inbox === null;
          };
          const onFailure = () => {
            logger2.debug("Failed to add inbox");
          };
          let retryStarted = false;
          const startRetry = () => {
            const config = StorageManager.readFromLSorCookie(WEBINBOX_CONFIG) || {};
            if (!config.inboxSelector) {
              logger2.debug("Web Inbox Retry Skipped, Inbox selector is not configured");
              return false;
            }
            if (!retryStarted) {
              retryStarted = true;
              retryUntil(checkElementCondition, 500, 20).then(() => {
                addInboxSafely();
                resolve();
              }).catch(onFailure);
            }
          };
          const setupEventListeners = () => {
            if (document.readyState === "complete") {
              startRetry();
            } else {
              window.addEventListener("load", startRetry);
              document.addEventListener("readystatechange", () => {
                if (document.readyState === "complete") {
                  startRetry();
                }
              });
            }
          };
          setupEventListeners();
        });
      };
      const checkAndRegisterWebInboxElements = () => {
        if (customElements.get("ct-web-inbox") === void 0) {
          customElements.define("ct-web-inbox", Inbox);
          customElements.define("ct-inbox-message", Message);
        }
      };
      const getInboxPosition = (e, inboxHeight, inboxWidth) => {
        const horizontalScroll = document.scrollingElement.scrollLeft;
        const verticalScroll = document.scrollingElement.scrollTop;
        const windowWidth = window.innerWidth + horizontalScroll;
        const windowHeight = window.innerHeight + verticalScroll;
        const selectorRect = e.rect || e.target.getBoundingClientRect();
        const selectorX = selectorRect.x + horizontalScroll;
        const selectorY = selectorRect.y + verticalScroll;
        const selectorLeft = selectorRect.left + horizontalScroll;
        const selectorRight = selectorRect.right + horizontalScroll;
        const selectorTop = selectorRect.top + verticalScroll;
        const selectorBottom = selectorRect.bottom;
        const selectorHeight = selectorRect.height;
        const selectorWidth = selectorRect.width;
        const selectorCenter = {
          x: selectorX + selectorWidth / 2,
          y: selectorY + selectorHeight / 2
        };
        const halfOfInboxHeight = inboxHeight / 2;
        const halfOfInboxWidth = inboxWidth / 2;
        let inboxOnSide = false;
        let xPos, yPos;
        const padding = 16;
        if (selectorBottom + inboxHeight <= windowHeight) {
          const availableHeight = windowHeight - (selectorBottom + inboxHeight);
          yPos = availableHeight >= padding ? selectorBottom + padding : selectorBottom + availableHeight;
        } else if (selectorTop - inboxHeight >= verticalScroll) {
          const availableHeight = selectorTop - inboxHeight;
          yPos = availableHeight >= padding ? selectorTop - inboxHeight - padding : selectorTop - inboxHeight - availableHeight;
        } else {
          inboxOnSide = true;
          yPos = selectorCenter.y - halfOfInboxHeight;
          if (yPos < verticalScroll) {
            yPos = verticalScroll;
          } else if (yPos + inboxHeight > windowHeight) {
            yPos = windowHeight - inboxHeight;
          }
        }
        if (inboxOnSide) {
          const inboxRight = selectorRight + inboxWidth;
          if (inboxRight <= windowWidth) {
            const availableWidth = inboxRight + padding <= windowWidth ? padding : windowWidth - inboxRight;
            xPos = selectorRight + availableWidth;
          } else {
            const inboxLeft = selectorLeft - inboxWidth;
            const availableWidth = inboxLeft - padding >= horizontalScroll ? padding : inboxLeft - horizontalScroll;
            xPos = inboxLeft - availableWidth;
          }
        } else {
          xPos = selectorCenter.x - halfOfInboxWidth;
          if (xPos < horizontalScroll) {
            if (selectorLeft + inboxWidth <= windowWidth) {
              xPos = selectorLeft;
            } else {
              xPos = horizontalScroll;
            }
          } else if (xPos + inboxWidth > windowWidth) {
            if (selectorRight - inboxWidth >= horizontalScroll) {
              xPos = selectorRight - inboxWidth;
            } else {
              xPos = windowWidth - inboxWidth;
            }
          }
        }
        return {
          xPos,
          yPos
        };
      };
      const determineTimeStampText = (ts) => {
        const now = Date.now();
        let diff = Math.floor((now - ts) / 6e4);
        if (diff < 5) {
          return "Just now";
        }
        if (diff < 60) {
          return "".concat(diff, " minute").concat(diff > 1 ? "s" : "", " ago");
        }
        diff = Math.floor(diff / 60);
        if (diff < 24) {
          return "".concat(diff, " hour").concat(diff > 1 ? "s" : "", " ago");
        }
        diff = Math.floor(diff / 24);
        return "".concat(diff, " day").concat(diff > 1 ? "s" : "", " ago");
      };
      const hasWebInboxSettingsInLS = () => {
        return Object.keys(StorageManager.readFromLSorCookie(WEBINBOX_CONFIG) || {}).length > 0;
      };
      const arrowSvg = '<svg width="6" height="10" viewBox="0 0 6 10" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path fill-rule="evenodd" clip-rule="evenodd" d="M0.258435 9.74751C-0.0478584 9.44825 -0.081891 8.98373 0.156337 8.64775L0.258435 8.52836L3.87106 5L0.258435 1.47164C-0.0478588 1.17239 -0.0818914 0.707867 0.156337 0.371887L0.258435 0.252494C0.564728 -0.0467585 1.04018 -0.0800085 1.38407 0.152743L1.50627 0.252494L5.74156 4.39042C6.04786 4.68968 6.08189 5.1542 5.84366 5.49018L5.74156 5.60957L1.50627 9.74751C1.16169 10.0842 0.603015 10.0842 0.258435 9.74751Z" fill="#63698F"/>\n</svg>\n';
      const greenTickSvg = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path fill-rule="evenodd" clip-rule="evenodd" d="M16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8C0 12.4183 3.58172 16 8 16C12.4183 16 16 12.4183 16 8ZM9.6839 5.93602C9.97083 5.55698 10.503 5.48833 10.8725 5.78269C11.2135 6.0544 11.2968 6.54044 11.0819 6.91173L11.0219 7.00198L8.09831 10.864C7.80581 11.2504 7.26654 11.3086 6.90323 11.0122L6.82822 10.9433L5.04597 9.10191C4.71635 8.76136 4.71826 8.21117 5.05023 7.87303C5.35666 7.5609 5.83722 7.53855 6.16859 7.80482L6.24814 7.87739L7.35133 9.01717L9.6839 5.93602Z" fill="#03A387"/>\n</svg>\n';
      const OVERLAY_PATH = "https://web-native-display-campaign.clevertap.com/production/lib-overlay/overlay.js";
      const CSS_PATH = "https://web-native-display-campaign.clevertap.com/production/lib-overlay/style.css";
      const WVE_CLASS = {
        FLICKER_SHOW: "wve-anti-flicker-show",
        FLICKER_HIDE: "wve-anti-flicker-hide",
        FLICKER_ID: "wve-flicker-style"
      };
      const WVE_QUERY_PARAMS = {
        BUILDER: "ctBuilder",
        PREVIEW: "ctBuilderPreview",
        SDK_CHECK: "ctBuilderSDKCheck"
      };
      const WVE_URL_ORIGIN = {
        CLEVERTAP: "dashboard.clevertap.com",
        LOCAL: "localhost"
      };
      const updateFormData = function(element, formStyle, payload) {
        let isPreview = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        if (formStyle !== void 0) {
          if (formStyle.style !== void 0) {
            Object.keys(formStyle.style).forEach((property) => {
              element.style.setProperty(property, formStyle.style[property]);
            });
          }
          if (formStyle.underline !== void 0) {
            const curTextDecoration = element.style.textDecoration;
            if (formStyle.underline) {
              element.style.textDecoration = "".concat(curTextDecoration, " underline").trim();
            } else {
              element.style.textDecoration = curTextDecoration.replace("underline", "").trim();
            }
          }
          if (formStyle.text !== void 0) {
            element.innerText = isPreview ? formStyle.text.text : formStyle.text;
          }
          if (formStyle.clickDetails !== void 0) {
            const url = formStyle.clickDetails.clickUrl;
            element.onclick = formStyle.clickDetails.newTab ? () => {
              if (!isPreview) {
                window.clevertap.raiseNotificationClicked(payload);
              }
              window.open(url, "_blank").focus();
            } : () => {
              if (!isPreview) {
                window.clevertap.raiseNotificationClicked(payload);
              }
              window.location.href = url;
            };
          }
          if (formStyle.imgURL !== void 0 && element.tagName.toLowerCase() === "img") {
            element.src = formStyle.imgURL;
          }
        }
      };
      const updateElementCSS = (element) => {
        if (element.elementCSS !== void 0) {
          const style = document.createElement("style");
          style.innerHTML = element.elementCSS;
          document.head.appendChild(style);
        }
      };
      const invokeExternalJs = (jsFunc, targetingMsgJson) => {
        const func = window.parent[jsFunc];
        if (typeof func === "function") {
          if (targetingMsgJson.display.kv != null) {
            func(targetingMsgJson.display.kv);
          } else {
            func();
          }
        }
      };
      const appendScriptForCustomEvent = (targetingMsgJson, html) => {
        const script = "<script>\n      const ct__camapignId = '".concat(targetingMsgJson.wzrk_id, `';
      const ct__formatVal = (v) => {
          return v && v.trim().substring(0, 20);
      }
      const ct__parentOrigin =  window.parent.origin;
      document.body.addEventListener('click', (event) => {
        const elem = event.target.closest?.('a[wzrk_c2a], button[wzrk_c2a]');
        if (elem) {
            const {innerText, id, name, value, href} = elem;
            const clickAttr = elem.getAttribute('onclick') || elem.getAttribute('click');
            const onclickURL = clickAttr?.match(/(window.open)[(]("|')(.*)("|',)/)?.[3] || clickAttr?.match(/(location.href *= *)("|')(.*)("|')/)?.[3];
            const props = {innerText, id, name, value};
            let msgCTkv = Object.keys(props).reduce((acc, c) => {
                const formattedVal = ct__formatVal(props[c]);
                formattedVal && (acc['wzrk_click_' + c] = formattedVal);
                return acc;
            }, {});
            if(onclickURL) { msgCTkv['wzrk_click_' + 'url'] = onclickURL; }
            if(href) { msgCTkv['wzrk_click_' + 'c2a'] = href; }
            const notifData = { msgId: ct__camapignId, msgCTkv, pivotId: '`).concat(targetingMsgJson.wzrk_pivot, "' };\n            window.parent.clevertap.renderNotificationClicked(notifData);\n        }\n      });\n      <\/script>\n    ");
        return html.replace(/(<\s*\/\s*body)/, "".concat(script, "\n$1"));
      };
      const staleDataUpdate = (staledata, campType) => {
        const campObj = getCampaignObject();
        const globalObj = campObj[campType].global;
        if (globalObj != null && campType) {
          for (const idx in staledata) {
            if (staledata.hasOwnProperty(idx)) {
              delete globalObj[staledata[idx]];
              if (StorageManager.read(CAMP_COOKIE_G)) {
                const guidCampObj = JSON.parse(decodeURIComponent(StorageManager.read(CAMP_COOKIE_G)));
                const guid = JSON.parse(decodeURIComponent(StorageManager.read(GCOOKIE_NAME)));
                if (guidCampObj[guid] && guidCampObj[guid][campType] && guidCampObj[guid][campType][staledata[idx]]) {
                  delete guidCampObj[guid][campType][staledata[idx]];
                  StorageManager.save(CAMP_COOKIE_G, encodeURIComponent(JSON.stringify(guidCampObj)));
                }
              }
            }
          }
        }
        saveCampaignObject(campObj);
      };
      const mergeEventMap = (newEvtMap) => {
        if ($ct.globalEventsMap == null) {
          $ct.globalEventsMap = StorageManager.readFromLSorCookie(EV_COOKIE);
          if ($ct.globalEventsMap == null) {
            $ct.globalEventsMap = newEvtMap;
            return;
          }
        }
        for (const key in newEvtMap) {
          if (newEvtMap.hasOwnProperty(key)) {
            const oldEvtObj = $ct.globalEventsMap[key];
            const newEvtObj = newEvtMap[key];
            if ($ct.globalEventsMap[key] != null) {
              if (newEvtObj[0] != null && newEvtObj[0] > oldEvtObj[0]) {
                $ct.globalEventsMap[key] = newEvtObj;
              }
            } else {
              $ct.globalEventsMap[key] = newEvtObj;
            }
          }
        }
      };
      const incrementImpression = (targetingMsgJson, _request2) => {
        const data = {};
        data.type = "event";
        data.evtName = NOTIFICATION_VIEWED;
        data.evtData = {
          [WZRK_ID]: targetingMsgJson.wzrk_id
        };
        if (targetingMsgJson.wzrk_pivot) {
          data.evtData = {
            ...data.evtData,
            wzrk_pivot: targetingMsgJson.wzrk_pivot
          };
        }
        _request2.processEvent(data);
      };
      const setupClickEvent = (onClick, targetingMsgJson, contentDiv, divId, isLegacy, _device2, _session2) => {
        if (onClick !== "" && onClick != null) {
          let ctaElement;
          let jsCTAElements;
          if (isLegacy) {
            ctaElement = contentDiv;
          } else if (contentDiv !== null) {
            jsCTAElements = contentDiv.getElementsByClassName("jsCT_CTA");
            if (jsCTAElements != null && jsCTAElements.length === 1) {
              ctaElement = jsCTAElements[0];
            }
          }
          const jsFunc = targetingMsgJson.display.jsFunc;
          const isPreview = targetingMsgJson.display.preview;
          if (isPreview == null) {
            onClick += getCookieParams(_device2, _session2);
          }
          if (ctaElement != null) {
            ctaElement.onclick = () => {
              if (jsFunc != null) {
                if (isPreview == null) {
                  RequestDispatcher.fireRequest(onClick);
                }
                invokeExternalJs(jsFunc, targetingMsgJson);
                closeIframe("-1", divId, _session2.sessionId);
              } else {
                const rValue = targetingMsgJson.display.preview ? targetingMsgJson.display.onClick : new URL(targetingMsgJson.display.onClick).searchParams.get("r");
                const campaignId = targetingMsgJson.wzrk_id.split("_")[0];
                if (rValue === "pushPrompt") {
                  if (!targetingMsgJson.display.preview) {
                    window.parent.clevertap.renderNotificationClicked({
                      msgId: targetingMsgJson.wzrk_id,
                      pivotId: targetingMsgJson.wzrk_pivot
                    });
                  }
                  window.clevertap.notifications.push({
                    skipDialog: true
                  });
                  closeIframe(campaignId, divId, _session2.sessionId);
                } else if (rValue === "none") {
                  closeIframe(campaignId, divId, _session2.sessionId);
                } else {
                  if (targetingMsgJson.display.window === 1) {
                    window.open(onClick, "_blank");
                    if (targetingMsgJson.display["close-popup"]) {
                      closeIframe(campaignId, divId, _session2.sessionId);
                    }
                    if (!targetingMsgJson.display.preview) {
                      window.parent.clevertap.renderNotificationClicked({
                        msgId: targetingMsgJson.wzrk_id,
                        pivotId: targetingMsgJson.wzrk_pivot
                      });
                    }
                  } else {
                    window.location = onClick;
                  }
                }
              }
            };
          }
        }
      };
      const getCookieParams = (_device2, _session2) => {
        const gcookie = _device2.getGuid();
        const scookieObj = _session2.getSessionCookieObject();
        return "&t=wc&d=" + encodeURIComponent(compressToBase64(gcookie + "|" + scookieObj.p + "|" + scookieObj.s));
      };
      const webNativeDisplayCampaignUtils = {
        /**
         * Checks if a campaign triggers a custom event push based on its template type.
         *
         * @param {Object} campaign - The campaign object to evaluate.
         * @returns {boolean} - Returns true if the campaign pushes a custom event, otherwise false.
         */
        doesCampaignPushCustomEvent: (campaign) => {
          var _campaign$msgContent, _campaign$msgContent2, _campaign$display, _campaign$display$det, _campaign$display$det2, _campaign$display$det3, _campaign$display$det4;
          return [WEB_NATIVE_TEMPLATES.KV_PAIR, WEB_NATIVE_TEMPLATES.JSON].includes(campaign === null || campaign === void 0 ? void 0 : (_campaign$msgContent = campaign.msgContent) === null || _campaign$msgContent === void 0 ? void 0 : _campaign$msgContent.type) || (campaign === null || campaign === void 0 ? void 0 : (_campaign$msgContent2 = campaign.msgContent) === null || _campaign$msgContent2 === void 0 ? void 0 : _campaign$msgContent2.type) === WEB_NATIVE_TEMPLATES.VISUAL_BUILDER && (campaign === null || campaign === void 0 ? void 0 : (_campaign$display = campaign.display) === null || _campaign$display === void 0 ? void 0 : (_campaign$display$det = _campaign$display.details) === null || _campaign$display$det === void 0 ? void 0 : (_campaign$display$det2 = _campaign$display$det[0]) === null || _campaign$display$det2 === void 0 ? void 0 : (_campaign$display$det3 = _campaign$display$det2.selectorData) === null || _campaign$display$det3 === void 0 ? void 0 : (_campaign$display$det4 = _campaign$display$det3.map((s) => {
            var _s$values;
            return s === null || s === void 0 ? void 0 : (_s$values = s.values) === null || _s$values === void 0 ? void 0 : _s$values.editor;
          })) === null || _campaign$display$det4 === void 0 ? void 0 : _campaign$display$det4.includes(WEB_NATIVE_DISPLAY_VISUAL_EDITOR_TYPES.JSON));
        },
        /**
         * Determines if a campaign mutates the DOM node based on its template type.
         *
         * @param {Object} campaign - The campaign object to evaluate.
         * @returns {boolean} - Returns true if the campaign mutates the DOM node, otherwise false.
         */
        doesCampaignMutateDOMNode: (campaign) => {
          var _campaign$msgContent3, _campaign$msgContent4, _campaign$display2, _campaign$display2$de, _campaign$display2$de2, _campaign$display2$de3;
          return [WEB_NATIVE_TEMPLATES.BANNER, WEB_NATIVE_TEMPLATES.CAROUSEL, WEB_NATIVE_TEMPLATES.CUSTOM_HTML].includes(campaign === null || campaign === void 0 ? void 0 : (_campaign$msgContent3 = campaign.msgContent) === null || _campaign$msgContent3 === void 0 ? void 0 : _campaign$msgContent3.type) || WEB_NATIVE_TEMPLATES.VISUAL_BUILDER === (campaign === null || campaign === void 0 ? void 0 : (_campaign$msgContent4 = campaign.msgContent) === null || _campaign$msgContent4 === void 0 ? void 0 : _campaign$msgContent4.type) && (campaign === null || campaign === void 0 ? void 0 : (_campaign$display2 = campaign.display) === null || _campaign$display2 === void 0 ? void 0 : (_campaign$display2$de = _campaign$display2.details) === null || _campaign$display2$de === void 0 ? void 0 : (_campaign$display2$de2 = _campaign$display2$de[0]) === null || _campaign$display2$de2 === void 0 ? void 0 : (_campaign$display2$de3 = _campaign$display2$de2.selectorData) === null || _campaign$display2$de3 === void 0 ? void 0 : _campaign$display2$de3.some((s) => {
            var _s$values2;
            return [WEB_NATIVE_DISPLAY_VISUAL_EDITOR_TYPES.HTML, WEB_NATIVE_DISPLAY_VISUAL_EDITOR_TYPES.FORM].includes(s === null || s === void 0 ? void 0 : (_s$values2 = s.values) === null || _s$values2 === void 0 ? void 0 : _s$values2.editor);
          }));
        },
        /**
         * Sorts campaigns based on their priority in descending order.
         *
         * @param {Array<Object>} campaigns - The list of campaign objects.
         * @returns {Array<Object>} - A new array of campaigns sorted by priority.
         */
        sortCampaignsByPriority: (campaigns) => {
          return campaigns.sort((a, b) => b.priority - a.priority);
        },
        /**
         * Retrieves the DOM nodes associated with a campaign based on its template type.
         *
         * @param {Object} campaign - The campaign object to extract nodes from.
         * @returns {Array<string>} - An array of DOM node selectors or IDs associated with the campaign.
         */
        getCampaignNodes: (campaign) => {
          var _display$details, _display$details$, _display$details$$sel, _display$details$$sel2;
          const {
            msgContent,
            display
          } = campaign;
          const {
            type
          } = msgContent;
          switch (type) {
            case WEB_NATIVE_TEMPLATES.BANNER:
            case WEB_NATIVE_TEMPLATES.CAROUSEL:
              return [display === null || display === void 0 ? void 0 : display.divSelector];
            case WEB_NATIVE_TEMPLATES.CUSTOM_HTML:
              return [display === null || display === void 0 ? void 0 : display.divId];
            case WEB_NATIVE_TEMPLATES.VISUAL_BUILDER:
              return (display === null || display === void 0 ? void 0 : (_display$details = display.details) === null || _display$details === void 0 ? void 0 : (_display$details$ = _display$details[0]) === null || _display$details$ === void 0 ? void 0 : (_display$details$$sel = _display$details$.selectorData) === null || _display$details$$sel === void 0 ? void 0 : (_display$details$$sel2 = _display$details$$sel.filter((s) => {
                var _s$values3;
                return (s === null || s === void 0 ? void 0 : (_s$values3 = s.values) === null || _s$values3 === void 0 ? void 0 : _s$values3.editor) === WEB_NATIVE_DISPLAY_VISUAL_EDITOR_TYPES.HTML;
              })) === null || _display$details$$sel2 === void 0 ? void 0 : _display$details$$sel2.map((s) => s === null || s === void 0 ? void 0 : s.selector)) || [];
            default:
              return [];
          }
        },
        /**
         * Determines whether the current custom event campaign should be skipped based on existing executed targets.
         *
         * @param {Object} targetNotif - The current notification object containing campaign details.
         * @param {ExecutedTargets} executedTargets - An object holding already executed custom events.
         * @returns {boolean} - Returns true if the current custom event campaign should be skipped, false otherwise.
        */
        shouldCurrentCustomEventCampaignBeSkipped(targetNotif, executedTargets) {
          var _targetNotif$msgConte2, _currentSameTypeCampa, _targetNotif$display, _targetNotif$display$;
          const currentSameTypeCampaigns = executedTargets.customEvents.filter((customEvent) => {
            var _targetNotif$msgConte;
            return customEvent.customEventType === (targetNotif === null || targetNotif === void 0 ? void 0 : (_targetNotif$msgConte = targetNotif.msgContent) === null || _targetNotif$msgConte === void 0 ? void 0 : _targetNotif$msgConte.type);
          });
          let shouldSkip = false;
          if (currentSameTypeCampaigns === null || currentSameTypeCampaigns === void 0 ? void 0 : currentSameTypeCampaigns.length) {
            switch (targetNotif === null || targetNotif === void 0 ? void 0 : (_targetNotif$msgConte2 = targetNotif.msgContent) === null || _targetNotif$msgConte2 === void 0 ? void 0 : _targetNotif$msgConte2.type) {
              case WEB_NATIVE_TEMPLATES.KV_PAIR:
                if ((_currentSameTypeCampa = currentSameTypeCampaigns.map((c) => c === null || c === void 0 ? void 0 : c.eventTopic)) === null || _currentSameTypeCampa === void 0 ? void 0 : _currentSameTypeCampa.includes(targetNotif === null || targetNotif === void 0 ? void 0 : (_targetNotif$display = targetNotif.display) === null || _targetNotif$display === void 0 ? void 0 : (_targetNotif$display$ = _targetNotif$display.kv) === null || _targetNotif$display$ === void 0 ? void 0 : _targetNotif$display$.topic)) {
                  shouldSkip = true;
                }
                break;
              case WEB_NATIVE_TEMPLATES.VISUAL_BUILDER:
              case WEB_NATIVE_TEMPLATES.JSON:
                shouldSkip = true;
                break;
            }
          }
          return shouldSkip;
        }
      };
      function addScriptTo(script) {
        let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "body";
        const targetEl = document.querySelector(target);
        if (!targetEl) return;
        const newScript = document.createElement("script");
        newScript.textContent = script.textContent;
        if (script.src) newScript.src = script.src;
        newScript.async = script.async;
        Array.from(script.attributes).forEach((attr) => {
          if (attr.name !== "src" && attr.name !== "async") {
            newScript.setAttribute(attr.name, attr.value);
          }
        });
        targetEl.appendChild(newScript);
        script.remove();
      }
      function addCampaignToLocalStorage(campaign) {
        var _campaign$display3;
        let region = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "eu1";
        let accountId = arguments.length > 2 ? arguments[2] : void 0;
        if ((campaign === null || campaign === void 0 ? void 0 : (_campaign$display3 = campaign.display) === null || _campaign$display3 === void 0 ? void 0 : _campaign$display3.preview) === true) {
          return;
        }
        const campaignId = campaign.wzrk_id.split("_")[0];
        const dashboardUrl = "https://".concat(region, ".dashboard.clevertap.com/").concat(accountId, "/campaigns/campaign/").concat(campaignId, "/report/stats");
        const enrichedCampaign = {
          ...campaign,
          url: dashboardUrl
        };
        const storedData = StorageManager.readFromLSorCookie(QUALIFIED_CAMPAIGNS);
        const existingCampaigns = storedData ? JSON.parse(decodeURIComponent(storedData)) : [];
        const isDuplicate = existingCampaigns.some((c) => c.wzrk_id === campaign.wzrk_id);
        if (!isDuplicate) {
          const updatedCampaigns = [...existingCampaigns, enrichedCampaign];
          StorageManager.saveToLSorCookie(QUALIFIED_CAMPAIGNS, encodeURIComponent(JSON.stringify(updatedCampaigns)));
        }
      }
      let logger$1 = null;
      const handleActionMode = (_logger2, accountId) => {
        const searchParams = new URLSearchParams(window.location.search);
        const ctType = searchParams.get("ctActionMode");
        logger$1 = _logger2;
        if (ctType) {
          const parentWindow = window.opener;
          switch (ctType) {
            case WVE_QUERY_PARAMS.BUILDER:
              logger$1.debug("open in visual builder mode");
              window.addEventListener("message", handleMessageEvent, false);
              if (parentWindow) {
                parentWindow.postMessage({
                  message: "builder",
                  originUrl: window.location.href
                }, "*");
              }
              break;
            case WVE_QUERY_PARAMS.PREVIEW:
              logger$1.debug("preview of visual editor");
              window.addEventListener("message", handleMessageEvent, false);
              if (parentWindow) {
                parentWindow.postMessage({
                  message: "preview",
                  originUrl: window.location.href
                }, "*");
              }
              break;
            case WVE_QUERY_PARAMS.SDK_CHECK:
              if (parentWindow) {
                logger$1.debug("SDK version check");
                const sdkVersion = "1.15.3";
                parentWindow.postMessage({
                  message: "SDKVersion",
                  accountId,
                  originUrl: window.location.href,
                  sdkVersion
                }, "*");
              }
              break;
            default:
              logger$1.debug("unknown query param ".concat(ctType));
              break;
          }
        }
      };
      const handleMessageEvent = (event) => {
        if (event.data && isValidUrl(event.data.originUrl)) {
          if (!event.origin.endsWith(WVE_URL_ORIGIN.CLEVERTAP) && !event.origin.endsWith(window.location.origin)) {
            return;
          }
        } else {
          return;
        }
        if (event.data.message === "Dashboard") {
          var _event$data$variant, _event$data$details;
          window.evtMaster = event.data.personalisation.evtMaster;
          initialiseCTBuilder(event.data.url, (_event$data$variant = event.data.variant) !== null && _event$data$variant !== void 0 ? _event$data$variant : null, (_event$data$details = event.data.details) !== null && _event$data$details !== void 0 ? _event$data$details : {}, event.data.personalisation);
        } else if (event.data.message === "Overlay") {
          renderVisualBuilder(event.data, true);
        }
      };
      const initialiseCTBuilder = (url, variant, details, personalisation) => {
        if (document.readyState === "complete") {
          onContentLoad(url, variant, details, personalisation);
        } else {
          document.addEventListener("readystatechange", () => {
            if (document.readyState === "complete") {
              onContentLoad(url, variant, details, personalisation);
            }
          });
        }
      };
      let container;
      let contentLoaded = false;
      let isShopify = false;
      function onContentLoad(url, variant, details, personalisation) {
        if (!contentLoaded) {
          if (window.Shopify) {
            isShopify = true;
          }
          document.body.innerHTML = "";
          document.head.innerHTML = "";
          document.documentElement.innerHTML = "";
          container = document.createElement("div");
          container.id = "overlayDiv";
          container.style.position = "relative";
          container.style.display = "flex";
          document.body.appendChild(container);
          loadOverlayScript(OVERLAY_PATH, url, variant, details, personalisation).then(() => {
            logger$1.debug("Overlay script loaded successfully.");
            contentLoaded = true;
          }).catch((error) => {
            logger$1.debug("Error loading overlay script:", error);
          });
          loadCSS();
        }
      }
      function loadCSS() {
        var link = document.createElement("link");
        link.rel = "stylesheet";
        link.type = "text/css";
        link.href = CSS_PATH;
        document.head.appendChild(link);
      }
      function loadOverlayScript(overlayPath, url, variant, details, personalisation) {
        return new Promise((resolve, reject) => {
          var script = document.createElement("script");
          script.type = "module";
          script.src = overlayPath;
          script.onload = function() {
            if (typeof window.Overlay === "function") {
              window.Overlay({
                id: "#overlayDiv",
                url,
                variant,
                details,
                isShopify,
                personalisation
              });
              resolve();
            } else {
              reject(new Error("ContentLayout not found in overlay.js"));
            }
          };
          script.onerror = function(error) {
            reject(error);
          };
          document.head.appendChild(script);
        });
      }
      const renderVisualBuilder = (targetingMsgJson, isPreview, _logger2) => {
        if (_logger2) {
          logger$1 = _logger2;
        }
        const insertedElements = [];
        const details = isPreview ? targetingMsgJson.details : targetingMsgJson.display.details;
        let url = window.location.href;
        if (isPreview) {
          const currentUrl = new URL(url);
          currentUrl.searchParams.delete("ctActionMode");
          url = currentUrl.toString();
        }
        let notificationViewed = false;
        const payload = {
          msgId: targetingMsgJson.wzrk_id,
          pivotId: targetingMsgJson.wzrk_pivot
        };
        const raiseViewed = () => {
          if (!isPreview && !notificationViewed) {
            notificationViewed = true;
            window.clevertap.renderNotificationViewed(payload);
          }
        };
        const raiseClicked = (payload2) => {
          window.clevertap.renderNotificationClicked(payload2);
        };
        const processElement = (element, selector) => {
          var _selector$isTrackingC;
          if (selector.elementCSS) {
            updateElementCSS(selector);
          }
          if ((_selector$isTrackingC = selector.isTrackingClicks) === null || _selector$isTrackingC === void 0 ? void 0 : _selector$isTrackingC.name) {
            element.addEventListener("click", () => {
              const clickedPayload = {
                msgId: targetingMsgJson.wzrk_id,
                pivotId: targetingMsgJson.wzrk_pivot,
                msgCTkv: {
                  wzrk_selector: selector.isTrackingClicks.name
                }
              };
              raiseClicked(clickedPayload);
            });
          }
          if (selector.values) {
            switch (selector.values.editor) {
              case "html":
                if (isPreview) {
                  element.outerHTML = selector.values.html.text;
                } else {
                  element.outerHTML = selector.values.html;
                }
                executeScripts(selector.selector);
                break;
              case "json":
                dispatchJsonData(targetingMsgJson, selector.values, isPreview);
                break;
              case "form":
                payload.msgCTkv = {
                  wzrk_selector: selector.selector
                };
                updateFormData(element, selector.values.form, payload, isPreview);
                break;
            }
          }
        };
        const tryFindingElement = (selector) => {
          let count = 0;
          const intervalId = setInterval(() => {
            let retryElement;
            try {
              retryElement = document.querySelector(selector.selector);
            } catch (_) {
            }
            if (retryElement) {
              raiseViewed();
              processElement(retryElement, selector);
              clearInterval(intervalId);
            } else if (++count >= 20) {
              logger$1.debug("No element present on DOM with selector '".concat(selector, "'."));
              clearInterval(intervalId);
            }
          }, 500);
        };
        details.forEach((d) => {
          if (d.url === url) {
            d.selectorData.forEach((s) => {
              if ((s.selector.includes("-afterend-") || s.selector.includes("-beforebegin-")) && s.values.initialHtml) {
                insertedElements.push(s);
              } else {
                let element;
                try {
                  element = document.querySelector(s.selector);
                } catch (_) {
                }
                if (element) {
                  raiseViewed();
                  processElement(element, s);
                } else {
                  tryFindingElement(s);
                }
              }
            });
          }
        });
        const addNewEl = (selector) => {
          const {
            pos,
            sibling
          } = findSiblingSelector(selector.selector);
          let count = 0;
          const intervalId = setInterval(() => {
            let element = null;
            try {
              const siblingEl = document.querySelector(sibling);
              const ctEl = document.querySelector('[ct-selector="'.concat(sibling, '"]'));
              element = ctEl || siblingEl;
            } catch (_) {
              element = document.querySelector('[ct-selector="'.concat(sibling, '"]'));
            }
            if (element) {
              const tempDiv = document.createElement("div");
              tempDiv.innerHTML = selector.values.initialHtml;
              const newElement = tempDiv.firstElementChild;
              element.insertAdjacentElement(pos, newElement);
              if (!element.getAttribute("ct-selector")) {
                element.setAttribute("ct-selector", sibling);
              }
              const insertedElement = document.querySelector('[ct-selector="'.concat(selector.selector, '"]'));
              raiseViewed();
              processElement(insertedElement, selector);
              clearInterval(intervalId);
            } else if (++count >= 20) {
              logger$1.debug("No element present on DOM with selector '".concat(sibling, "'."));
              clearInterval(intervalId);
            }
          }, 500);
        };
        if (insertedElements.length > 0) {
          const sortedArr = insertedElements.sort((a, b) => {
            const numA = parseInt(a.selector.split("-")[0], 10);
            const numB = parseInt(b.selector.split("-")[0], 10);
            return numA - numB;
          });
          sortedArr.forEach(addNewEl);
        }
      };
      function findSiblingSelector(input) {
        const regex = /^(\d+)-(afterend|beforebegin)-(.+)$/;
        const match = input.match(regex);
        if (match) {
          return {
            pos: match[2],
            sibling: match[3]
          };
        }
        return {
          pos: "beforebegin",
          sibling: ""
        };
      }
      function dispatchJsonData(targetingMsgJson, selector) {
        let isPreview = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        const inaObj = {};
        inaObj.msgId = targetingMsgJson.wzrk_id;
        if (targetingMsgJson.wzrk_pivot) {
          inaObj.pivotId = targetingMsgJson.wzrk_pivot;
        }
        if (selector.json != null) {
          if (isPreview) {
            inaObj.json = selector.json.text;
          } else {
            inaObj.json = selector.json;
          }
        }
        const kvPairsEvent = new CustomEvent("CT_web_native_display_buider", {
          detail: inaObj
        });
        document.dispatchEvent(kvPairsEvent);
      }
      function isValidUrl(string) {
        try {
          const url = new URL(string);
          return Boolean(url);
        } catch (_err) {
          return false;
        }
      }
      function addAntiFlicker(antiFlicker) {
        const {
          personalizedSelectors = [],
          delayTime = 2e3
        } = antiFlicker;
        const retryElements = {};
        let retryCount = 0;
        let retryInterval;
        function isInViewport(element) {
          const rect = element.getBoundingClientRect();
          const {
            innerHeight: windowHeight,
            innerWidth: windowWidth
          } = window;
          return rect.bottom > 0 && rect.right > 0 && rect.top < windowHeight && rect.left < windowWidth;
        }
        (function() {
          const styleContent = "\n      .wve-anti-flicker-hide {\n        opacity: 0 !important;\n      }\n      .wve-anti-flicker-show {\n        transition: opacity 0.5s, filter 0.5s !important;\n      }\n    ";
          const styleId = WVE_CLASS.FLICKER_ID;
          if (!document.getElementById(styleId)) {
            const styleElement = document.createElement("style");
            styleElement.id = styleId;
            styleElement.textContent = styleContent;
            document.head.appendChild(styleElement);
          }
        })();
        function applyAntiFlicker(selectors) {
          function processSelectors(selectorElements) {
            const elements = [];
            selectorElements.forEach((selector) => {
              const matchedElements = document.querySelectorAll(selector);
              if (matchedElements.length) {
                matchedElements.forEach((el) => {
                  if (isInViewport(el)) {
                    elements.push(el);
                  }
                });
                delete retryElements[selector];
              } else {
                retryElements[selector] = false;
              }
            });
            applyStyles(elements);
          }
          function retryProcessing() {
            processSelectors(Object.keys(retryElements));
            retryCount++;
            if (Object.keys(retryElements).length === 0 || retryCount > 20) {
              retryCount = 0;
              clearInterval(retryInterval);
            }
          }
          processSelectors(selectors);
          if (Object.keys(retryElements).length) {
            retryInterval = setInterval(retryProcessing, 100);
          }
        }
        function applyStyles(elements) {
          elements.forEach((el) => el.classList.add(WVE_CLASS.FLICKER_HIDE));
          setTimeout(() => {
            elements.forEach((el) => {
              el.classList.remove(WVE_CLASS.FLICKER_HIDE);
              el.classList.add(WVE_CLASS.FLICKER_SHOW);
            });
          }, delayTime);
        }
        function observeUrlChange() {
          let previousHref = document.location.href;
          const observer = new MutationObserver(() => {
            if (previousHref !== document.location.href) {
              previousHref = document.location.href;
              applyAntiFlicker(personalizedSelectors);
            }
          });
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
        }
        window.addEventListener("DOMContentLoaded", () => {
          observeUrlChange();
        });
        applyAntiFlicker(personalizedSelectors);
      }
      function executeScripts(selector) {
        try {
          let newElement;
          if (selector.includes("-afterend-") || selector.includes("-beforebegin-")) {
            newElement = document.querySelector('[ct-selector="'.concat(selector, '"]'));
          } else {
            newElement = document.querySelector(selector);
          }
          if (!newElement) return;
          const scripts = newElement.querySelectorAll("script");
          scripts.forEach((script) => {
            addScriptTo(script);
          });
        } catch (error) {
          logger$1.debug("Error loading script", error);
        }
      }
      class CTWebPersonalisationBanner extends HTMLElement {
        constructor() {
          super();
          this._details = null;
          this.shadow = null;
          this.shadow = this.attachShadow({
            mode: "open"
          });
        }
        get details() {
          return this._details || "";
        }
        set details(val) {
          if (this._details === null) {
            this._details = val;
            this.renderBanner();
          }
        }
        renderBanner() {
          this.shadow.innerHTML = this.getBannerContent();
          if (this.trackClick !== false) {
            this.addEventListener("click", () => {
              const onClickUrl = this.details.onClick;
              if (onClickUrl) {
                this.details.window ? window.open(onClickUrl, "_blank") : window.parent.location.href = onClickUrl;
              }
              window.clevertap.renderNotificationClicked({
                msgId: this.msgId,
                pivotId: this.pivotId
              });
            });
          }
          window.clevertap.renderNotificationViewed({
            msgId: this.msgId,
            pivotId: this.pivotId
          });
        }
        getBannerContent() {
          return '\n      <style type="text/css">\n        .banner {\n          position: relative;\n          cursor: '.concat(this.details.onClick ? "pointer" : "", "\n        }\n        img {\n          height: ").concat(this.divHeight ? this.divHeight : "auto", ";\n          width: 100%;\n        }\n        .wrapper:is(.left, .right, .center) {\n          display: flex;\n          justify-content: center;\n          flex-direction: column;\n          align-items: center;\n          position: absolute;\n          width: 100%;\n          height: 100%;\n          overflow: auto;\n          top: 0;\n        }\n        ").concat(this.details.css ? this.details.css : "", '\n      </style>\n      <div class="banner">\n        <picture>\n          <source media="(min-width:480px)" srcset="').concat(this.details.desktopImageURL, '">\n          <source srcset="').concat(this.details.mobileImageURL, '">\n          <img src="').concat(this.details.desktopImageURL, '" alt="Please upload a picture" style="width:100%;" part="banner__img">\n        </picture>\n        ').concat(this.details.html ? this.details.html : "", "\n      </div>\n    ");
        }
      }
      class CTWebPersonalisationCarousel extends HTMLElement {
        constructor() {
          super();
          this._target = null;
          this._carousel = null;
          this.shadow = null;
          this.slides = 0;
          this.previouslySelectedItem = -1;
          this.selectedItem = 1;
          this.autoSlide = null;
          this.stopAutoSlideTimeout = null;
          this.shadow = this.attachShadow({
            mode: "open"
          });
          if (customElements.get("ct-web-personalisation-banner") === void 0) {
            customElements.define("ct-web-personalisation-banner", CTWebPersonalisationBanner);
          }
        }
        get target() {
          return this._target || "";
        }
        set target(val) {
          if (this._target === null) {
            this._target = val;
            this.renderCarousel();
          }
        }
        get details() {
          return this.target.display.details;
        }
        get display() {
          return this.target.display;
        }
        renderCarousel() {
          this.slides = this.details.length;
          this.shadow.innerHTML = this.getStyles();
          const carousel = this.getCarouselContent();
          if (this.display.showNavBtns) {
            carousel.insertAdjacentHTML("beforeend", this.display.navBtnsHtml);
          }
          if (this.display.showNavArrows) {
            carousel.insertAdjacentHTML("beforeend", this.display.leftNavArrowHtml);
            carousel.insertAdjacentHTML("beforeend", this.display.rightNavArrowHtml);
          }
          this._carousel = carousel;
          this.shadow.appendChild(carousel);
          this.setupClick();
          this.updateSelectedItem();
          this.startAutoSlide();
          this.setupOnHover();
          window.clevertap.renderNotificationViewed({
            msgId: this.target.wzrk_id,
            pivotId: this.target.wzrk_pivot
          });
        }
        setupClick() {
          this._carousel.addEventListener("click", (event) => {
            const eventID = event.target.id;
            if (eventID.startsWith("carousel__button")) {
              const selected = +eventID.split("-")[1];
              if (selected !== this.selectedItem) {
                this.previouslySelectedItem = this.selectedItem;
                this.selectedItem = selected;
                this.updateSelectedItem();
                this.startAutoSlide();
              }
            } else if (eventID.startsWith("carousel__arrow")) {
              eventID.endsWith("right") ? this.goToNext() : this.goToPrev();
              this.startAutoSlide();
            } else if (eventID.indexOf("-") > -1) {
              const item = +eventID.split("-")[1];
              const index = item - 1;
              if (window.parent.clevertap) {
                window.clevertap.renderNotificationClicked({
                  msgId: this.target.wzrk_id,
                  pivotId: this.target.wzrk_pivot,
                  wzrk_slideNo: item
                });
              }
              const url = this.details[index].onClick;
              if (url !== "") {
                this.details[index].window ? window.open(url, "_blank") : window.location.href = url;
              }
            }
          });
        }
        setupOnHover() {
          this._carousel.addEventListener("mouseenter", (event) => {
            this.stopAutoSlideTimeout = setTimeout(() => {
              this.autoSlide = clearInterval(this.autoSlide);
            }, 500);
          });
          this._carousel.addEventListener("mouseleave", (event) => {
            clearTimeout(this.stopAutoSlideTimeout);
            if (this.autoSlide === void 0) {
              this.startAutoSlide();
            }
          });
        }
        getCarouselContent() {
          const carousel = document.createElement("div");
          carousel.setAttribute("class", "carousel");
          this.details.forEach((detail, i) => {
            const banner = document.createElement("ct-web-personalisation-banner");
            banner.classList.add("carousel__item");
            banner.trackClick = false;
            banner.setAttribute("id", "carousel__item-".concat(i + 1));
            banner.details = detail;
            carousel.appendChild(banner);
          });
          return carousel;
        }
        getStyles() {
          var _this$target, _this$target$display;
          return "\n      <style>\n      .carousel {\n        position: relative;\n      }\n\n      .carousel__item {\n        display: none;\n        background-repeat: no-repeat;\n        background-size: cover;\n      }\n\n      ct-web-personalisation-banner::part(banner__img) {\n        height: ".concat((this === null || this === void 0 ? void 0 : (_this$target = this.target) === null || _this$target === void 0 ? void 0 : (_this$target$display = _this$target.display) === null || _this$target$display === void 0 ? void 0 : _this$target$display.divHeight) ? this.target.display.divHeight : "auto", ";\n        width: 100%;\n        transition: 2s;\n      }\n\n      .carousel__item--selected {\n        display: block;\n      }\n      ").concat(this.display.navBtnsCss, "\n      ").concat(this.display.navArrowsCss, "\n      </style>\n  ");
        }
        updateSelectedItem() {
          if (this.previouslySelectedItem !== -1) {
            const prevItem = this.shadow.getElementById("carousel__item-".concat(this.previouslySelectedItem));
            const prevButton = this.shadow.getElementById("carousel__button-".concat(this.previouslySelectedItem));
            prevItem.classList.remove("carousel__item--selected");
            if (prevButton) {
              prevButton.classList.remove("carousel__button--selected");
            }
          }
          const item = this.shadow.getElementById("carousel__item-".concat(this.selectedItem));
          const button = this.shadow.getElementById("carousel__button-".concat(this.selectedItem));
          item.classList.add("carousel__item--selected");
          if (button) {
            button.classList.add("carousel__button--selected");
          }
        }
        startAutoSlide() {
          clearInterval(this.autoSlide);
          this.autoSlide = setInterval(() => {
            this.goToNext();
          }, this.display.sliderTime ? this.display.sliderTime * 1e3 : 3e3);
        }
        goToNext() {
          this.goTo(this.selectedItem, (this.selectedItem + 1) % this.slides);
        }
        goToPrev() {
          this.goTo(this.selectedItem, this.selectedItem - 1);
        }
        goTo(prev, cur) {
          this.previouslySelectedItem = prev;
          this.selectedItem = cur;
          if (cur === 0) {
            this.selectedItem = this.slides;
          }
          this.updateSelectedItem();
        }
      }
      const renderPersonalisationBanner = (targetingMsgJson) => {
        var _targetingMsgJson$dis;
        if (customElements.get("ct-web-personalisation-banner") === void 0) {
          customElements.define("ct-web-personalisation-banner", CTWebPersonalisationBanner);
        }
        const divId = (_targetingMsgJson$dis = targetingMsgJson.display.divId) !== null && _targetingMsgJson$dis !== void 0 ? _targetingMsgJson$dis : targetingMsgJson.display.divSelector;
        const bannerEl = document.createElement("ct-web-personalisation-banner");
        bannerEl.msgId = targetingMsgJson.wzrk_id;
        bannerEl.pivotId = targetingMsgJson.wzrk_pivot;
        bannerEl.divHeight = targetingMsgJson.display.divHeight;
        bannerEl.details = targetingMsgJson.display.details[0];
        const containerEl = targetingMsgJson.display.divId ? document.getElementById(divId) : document.querySelector(divId);
        containerEl.innerHTML = "";
        containerEl.appendChild(bannerEl);
      };
      const renderPersonalisationCarousel = (targetingMsgJson) => {
        var _targetingMsgJson$dis2;
        if (customElements.get("ct-web-personalisation-carousel") === void 0) {
          customElements.define("ct-web-personalisation-carousel", CTWebPersonalisationCarousel);
        }
        const divId = (_targetingMsgJson$dis2 = targetingMsgJson.display.divId) !== null && _targetingMsgJson$dis2 !== void 0 ? _targetingMsgJson$dis2 : targetingMsgJson.display.divSelector;
        const carousel = document.createElement("ct-web-personalisation-carousel");
        carousel.target = targetingMsgJson;
        const container2 = targetingMsgJson.display.divId ? document.getElementById(divId) : document.querySelector(divId);
        container2.innerHTML = "";
        container2.appendChild(carousel);
      };
      const handleKVpairCampaign = (targetingMsgJson) => {
        const inaObj = {};
        inaObj.msgId = targetingMsgJson.wzrk_id;
        if (targetingMsgJson.wzrk_pivot) {
          inaObj.pivotId = targetingMsgJson.wzrk_pivot;
        }
        if (targetingMsgJson.msgContent.kv != null) {
          inaObj.kv = targetingMsgJson.msgContent.kv;
        }
        const kvPairsEvent = new CustomEvent("CT_web_native_display", {
          detail: inaObj
        });
        document.dispatchEvent(kvPairsEvent);
      };
      const renderCustomHtml = (targetingMsgJson, logger2) => {
        const {
          display,
          wzrk_id: wzrkId,
          wzrk_pivot: wzrkPivot
        } = targetingMsgJson || {};
        const {
          divId
        } = display || {};
        const details = display.details[0];
        let html = details.html;
        if (!divId || !html) {
          logger2.error("No div Id or no html found");
          return;
        }
        if (display["custom-html-click-track"]) {
          html = appendScriptForCustomEvent(targetingMsgJson, html);
        }
        let notificationViewed = false;
        const payload = {
          msgId: wzrkId,
          pivotId: wzrkPivot
        };
        const raiseViewed = () => {
          if (!notificationViewed) {
            notificationViewed = true;
            window.clevertap.renderNotificationViewed(payload);
          }
        };
        const tryFindingElement = (divId2) => {
          let count = 0;
          const intervalId = setInterval(() => {
            const retryElement = document.querySelector(divId2);
            if (retryElement) {
              raiseViewed();
              retryElement.innerHTML = html;
              const wrapper = document.createElement("div");
              wrapper.innerHTML = html;
              const scripts = wrapper.querySelectorAll("script");
              scripts.forEach((script) => {
                addScriptTo(script);
              });
              clearInterval(intervalId);
            } else if (++count >= 20) {
              logger2.error("No element present on DOM with divId '".concat(divId2, "'."));
              clearInterval(intervalId);
            }
          }, 500);
        };
        tryFindingElement(divId);
      };
      const handleJson = (targetingMsgJson) => {
        const inaObj = {};
        inaObj.msgId = targetingMsgJson.wzrk_id;
        const details = targetingMsgJson.display.details[0];
        const json = details.json;
        if (targetingMsgJson.wzrk_pivot) {
          inaObj.pivotId = targetingMsgJson.wzrk_pivot;
        }
        if (targetingMsgJson.display.json != null) {
          inaObj.json = json;
        }
        const jsonEvent = new CustomEvent("CT_web_native_display_json", {
          detail: inaObj
        });
        document.dispatchEvent(jsonEvent);
      };
      function handleCustomHtmlPreviewPostMessageEvent(event, logger2) {
        if (!event.origin.endsWith(WVE_URL_ORIGIN.CLEVERTAP)) {
          return;
        }
        const eventData = JSON.parse(event.data);
        const inAppNotifs = eventData.inapp_notifs;
        const msgContent = inAppNotifs[0].msgContent;
        if (eventData && msgContent && msgContent.templateType === "custom-html" && msgContent.type === 5) {
          renderCustomHtml(inAppNotifs[0], logger2);
        }
      }
      const checkCustomHtmlNativeDisplayPreview = (logger2) => {
        const searchParams = new URLSearchParams(window.location.search);
        const ctType = searchParams.get("ctActionMode");
        if (ctType) {
          const parentWindow = window.opener;
          switch (ctType) {
            case CUSTOM_HTML_PREVIEW:
              if (parentWindow) {
                parentWindow.postMessage("ready", "*");
                const eventHandler = (event) => handleCustomHtmlPreviewPostMessageEvent(event, logger2);
                window.addEventListener("message", eventHandler, false);
              }
              break;
            default:
              logger2.debug("unknown query param ".concat(ctType));
              break;
          }
        }
      };
      const renderPopUpImageOnly = (targetingMsgJson, _session2) => {
        const divId = "wzrkImageOnlyDiv";
        const popupImageOnly = document.createElement("ct-web-popup-imageonly");
        popupImageOnly.session = _session2;
        popupImageOnly.target = targetingMsgJson;
        const containerEl = document.getElementById(divId);
        containerEl.innerHTML = "";
        containerEl.style.visibility = "hidden";
        containerEl.appendChild(popupImageOnly);
      };
      const getBoxPromptStyles = (style) => {
        const totalBorderWidth = style.card.borderEnabled ? style.card.border.borderWidth * 2 : 0;
        const cardPadding = 16 * 2;
        const cardContentWidth = 360 - cardPadding - totalBorderWidth;
        return "\n    #pnWrapper {\n      width: 360px;\n      font-family: proxima-nova, Arial, sans-serif;\n    }\n    \n    #pnWrapper * {\n       margin: 0px;\n       padding: 0px;\n       text-align: left;\n    }\n    ".concat(style.overlay.enabled ? "#pnOverlay {\n      background-color: ".concat(style.overlay.color || "rgba(0, 0, 0, .15)", ";\n      position: fixed;\n      left: 0;\n      right: 0;\n      top: 0;\n      bottom: 0;\n      z-index: 10000\n    }\n") : "", "\n    #pnCard {\n      background-color: ").concat(style.card.color, ";\n      border-radius: ").concat(style.card.borderRadius, "px;\n      padding: 16px;\n      width: ").concat(cardContentWidth, "px;\n      position: fixed;\n      z-index: 999999;\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n      ").concat(style.card.borderEnabled ? "\n        border-width: ".concat(style.card.border.borderWidth, "px;\n        border-color: ").concat(style.card.border.borderColor, ";\n        border-style: solid;\n      ") : "", "\n      height: fit-content;\n    }\n\n    #iconTitleDescWrapper {\n      display: flex;\n      align-items: center;\n      margin-bottom: 16px;\n      gap: 12px;\n    }\n\n    #iconContainer {\n      min-width: 64px;\n      max-width: 64px;\n      aspect-ratio: 1;\n      object-fit: cover;\n    }\n\n    #titleDescWrapper {\n      flex-grow: 1;\n      overflow: hidden;\n      overflow-wrap: break-word;\n    }\n\n    #title {\n      font-size: 16px;\n      font-weight: 700;\n      color: ").concat(style.text.titleColor, ";\n      margin-bottom: 4px;\n      line-height: 24px;\n    }\n\n    #description {\n      font-size: 14px;\n      font-weight: 500;\n      color: ").concat(style.text.descriptionColor, ";\n      line-height: 20px;\n    }\n\n    #buttonsContainer {\n      display: flex;\n      justify-content: space-between;\n      min-height: 32px;\n      gap: 8px;\n      align-items: center;\n    }\n\n    #primaryButton, #secondaryButton {\n      padding: 6px 24px;\n      flex: 1;\n      cursor: pointer;\n      font-weight: bold;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      height: max-content;\n      font-size: 14px;\n      font-weight: 500;\n      line-height: 20px;\n      text-align: center;\n    }\n\n    #primaryButton {\n      background-color: ").concat(style.buttons.primaryButton.buttonColor, ";\n      color: ").concat(style.buttons.primaryButton.textColor, ";\n      border-radius: ").concat(style.buttons.primaryButton.borderRadius, "px;\n      ").concat(style.buttons.primaryButton.borderEnabled ? "\n          border-width: ".concat(style.buttons.primaryButton.border.borderWidth, "px;\n          border-color: ").concat(style.buttons.primaryButton.border.borderColor, ";\n          border-style: solid;\n        ") : "border: none;", "\n    }\n\n    #secondaryButton {\n      background-color: ").concat(style.buttons.secondaryButton.buttonColor, ";\n      color: ").concat(style.buttons.secondaryButton.textColor, ";\n      border-radius: ").concat(style.buttons.secondaryButton.borderRadius, "px;\n      ").concat(style.buttons.secondaryButton.borderEnabled ? "\n          border-width: ".concat(style.buttons.secondaryButton.border.borderWidth, "px;\n          border-color: ").concat(style.buttons.secondaryButton.border.borderColor, ";\n          border-style: solid;\n        ") : "border: none;", "\n    }\n\n    #primaryButton:hover, #secondaryButton:hover {\n      opacity: 0.9;\n    }\n  ");
      };
      const getBellIconStyles = (style) => {
        return "\n    #bell_wrapper {\n      position: fixed;\n      cursor: pointer;\n      background-color: ".concat(style.card.backgroundColor, ";\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n      width: 48px;\n      height: 48px;\n      border-radius: 50%;\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n      z-index: 999999;\n    }\n\n    #bell_icon {\n      display: block;\n      width: 48px;\n      height: 48px;\n    }\n\n    #bell_wrapper:hover {\n      transform: scale(1.05);\n      transition: transform 0.2s ease-in-out;\n    }\n\n    #bell_tooltip {\n      display: none;\n      background-color: #2b2e3e;\n      color: #fff;\n      border-radius: 4px;\n      padding: 4px;\n      white-space: nowrap;\n      pointer-events: none;\n      font-size: 14px;\n      line-height: 1.4;\n    }\n\n    #gif_modal {\n      display: none;\n      background-color: #ffffff;\n      padding: 4px;\n      width: 400px;\n      height: 256px;\n      border-radius: 4px;\n      position: relative;\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n      cursor: default;\n    }\n\n    #gif_image {\n      object-fit: contain;\n      width: 100%;\n      height: 100%;\n    }\n\n    #close_modal {\n      position: absolute;\n      width: 24px;\n      height: 24px;\n      top: 8px;\n      right: 8px;\n      background: rgba(238, 238, 238, 0.8);\n      text-align: center;\n      line-height: 20px;\n      border-radius: 4px;\n      color: #000000;\n      font-size: 22px;\n      cursor: pointer;\n    }\n  ");
      };
      const isChrome = () => {
        const ua = navigator.userAgent;
        return ua.includes("Chrome") || ua.includes("CriOS");
      };
      const isFirefox = () => {
        const ua = navigator.userAgent;
        return ua.includes("Firefox") || ua.includes("FxiOS");
      };
      const isSafari = () => {
        const ua = navigator.userAgent;
        return ua.includes("Safari") && !ua.includes("CriOS") && !ua.includes("FxiOS") && !ua.includes("Chrome") && !ua.includes("Firefox");
      };
      const objectHasNestedArrayOrFunction = (obj) => {
        if (!obj || typeof obj !== "object") return false;
        if (Array.isArray(obj)) return true;
        return Object.values(obj).some((value) => typeof value === "function" || objectHasNestedArrayOrFunction(value));
      };
      const flattenObjectToDotNotation = function(obj) {
        let parentKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        const result = {};
        for (const key in obj) {
          if (Object.hasOwnProperty.call(obj, key)) {
            const value = obj[key];
            const newKey = parentKey ? "".concat(parentKey, ".").concat(key) : key;
            if (typeof value === "object" && value !== null && !Array.isArray(value)) {
              Object.assign(result, flattenObjectToDotNotation(value, newKey));
            } else if (!Array.isArray(value)) {
              result[newKey] = {
                defaultValue: value,
                type: typeof value
              };
            }
          }
        }
        return result;
      };
      const reconstructNestedObject = (payload) => {
        const result = {};
        for (const key in payload) {
          if (Object.hasOwnProperty.call(payload, key)) {
            const value = payload[key];
            const keys = key.split(".");
            let current = result;
            keys.forEach((part, index) => {
              if (index === keys.length - 1) {
                current[part] = value;
              } else {
                current = current[part] = current[part] || {};
              }
            });
          }
        }
        return result;
      };
      function validateCustomCleverTapID(id2) {
        if (typeof id2 !== "string") {
          return {
            isValid: false,
            error: "ID must be a string."
          };
        }
        const lowercaseId = id2.toLowerCase();
        const length = lowercaseId.length;
        if (length < 1 || length > 64) {
          return {
            isValid: false,
            error: "ID must be between 1 and 64 characters."
          };
        }
        const allowedPattern = /^[a-z0-9()!:@$_-]+$/;
        if (!allowedPattern.test(lowercaseId)) {
          return {
            isValid: false,
            error: "ID contains invalid characters. Only A-Z, a-z, 0-9, (, ), !, :, @, $, _, - are allowed."
          };
        }
        return {
          isValid: true,
          sanitizedId: addWebPrefix(lowercaseId)
        };
      }
      function addWebPrefix(id2) {
        if (typeof id2 !== "string") {
          throw new Error("ID must be a string");
        }
        return "".concat(CUSTOM_CT_ID_PREFIX).concat(id2.toLowerCase());
      }
      var _oldValues$1 = _classPrivateFieldLooseKey("oldValues");
      var _logger$5 = _classPrivateFieldLooseKey("logger");
      var _request$3 = _classPrivateFieldLooseKey("request");
      var _account$4 = _classPrivateFieldLooseKey("account");
      var _wizAlertJSPath = _classPrivateFieldLooseKey("wizAlertJSPath");
      var _fcmPublicKey = _classPrivateFieldLooseKey("fcmPublicKey");
      var _setUpWebPush = _classPrivateFieldLooseKey("setUpWebPush");
      var _isNativeWebPushSupported = _classPrivateFieldLooseKey("isNativeWebPushSupported");
      var _setUpSafariNotifications = _classPrivateFieldLooseKey("setUpSafariNotifications");
      var _setUpChromeFirefoxNotifications = _classPrivateFieldLooseKey("setUpChromeFirefoxNotifications");
      var _addWizAlertJS = _classPrivateFieldLooseKey("addWizAlertJS");
      var _removeWizAlertJS = _classPrivateFieldLooseKey("removeWizAlertJS");
      var _handleNotificationRegistration = _classPrivateFieldLooseKey("handleNotificationRegistration");
      class NotificationHandler extends Array {
        constructor(_ref, values) {
          let {
            logger: logger2,
            session,
            request: request2,
            account: account2
          } = _ref;
          super();
          Object.defineProperty(this, _handleNotificationRegistration, {
            value: _handleNotificationRegistration2
          });
          Object.defineProperty(this, _removeWizAlertJS, {
            value: _removeWizAlertJS2
          });
          Object.defineProperty(this, _addWizAlertJS, {
            value: _addWizAlertJS2
          });
          Object.defineProperty(this, _setUpChromeFirefoxNotifications, {
            value: _setUpChromeFirefoxNotifications2
          });
          Object.defineProperty(this, _setUpSafariNotifications, {
            value: _setUpSafariNotifications2
          });
          Object.defineProperty(this, _isNativeWebPushSupported, {
            value: _isNativeWebPushSupported2
          });
          Object.defineProperty(this, _setUpWebPush, {
            value: _setUpWebPush2
          });
          Object.defineProperty(this, _oldValues$1, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _logger$5, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _request$3, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _account$4, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _wizAlertJSPath, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _fcmPublicKey, {
            writable: true,
            value: void 0
          });
          _classPrivateFieldLooseBase(this, _wizAlertJSPath)[_wizAlertJSPath] = "https://d2r1yp2w7bby2u.cloudfront.net/js/wzrk_dialog.min.js";
          _classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey] = null;
          _classPrivateFieldLooseBase(this, _oldValues$1)[_oldValues$1] = values;
          _classPrivateFieldLooseBase(this, _logger$5)[_logger$5] = logger2;
          _classPrivateFieldLooseBase(this, _request$3)[_request$3] = request2;
          _classPrivateFieldLooseBase(this, _account$4)[_account$4] = account2;
        }
        setupWebPush(displayArgs2) {
          _classPrivateFieldLooseBase(this, _setUpWebPush)[_setUpWebPush](displayArgs2);
        }
        push() {
          if (StorageManager.readFromLSorCookie(ACCOUNT_ID)) {
            const isWebPushConfigPresent = StorageManager.readFromLSorCookie(WEBPUSH_CONFIG_RECEIVED);
            const isApplicationServerKeyReceived = StorageManager.readFromLSorCookie(APPLICATION_SERVER_KEY_RECEIVED);
            for (var _len = arguments.length, displayArgs2 = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
              displayArgs2[_key2] = arguments[_key2];
            }
            setNotificationHandlerValues({
              logger: _classPrivateFieldLooseBase(this, _logger$5)[_logger$5],
              account: _classPrivateFieldLooseBase(this, _account$4)[_account$4],
              request: _classPrivateFieldLooseBase(this, _request$3)[_request$3],
              displayArgs: displayArgs2,
              fcmPublicKey: _classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey]
            });
            if (isWebPushConfigPresent && isApplicationServerKeyReceived) {
              processSoftPrompt();
            } else {
              StorageManager.saveToLSorCookie(NOTIFICATION_PUSH_METHOD_DEFERRED, true);
            }
          } else {
            _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("Account ID is not set");
          }
        }
        _processOldValues() {
          if (_classPrivateFieldLooseBase(this, _oldValues$1)[_oldValues$1]) {
            if (Array.isArray(_classPrivateFieldLooseBase(this, _oldValues$1)[_oldValues$1]) && _classPrivateFieldLooseBase(this, _oldValues$1)[_oldValues$1].length > 0) {
              setNotificationHandlerValues({
                logger: _classPrivateFieldLooseBase(this, _logger$5)[_logger$5],
                account: _classPrivateFieldLooseBase(this, _account$4)[_account$4],
                request: _classPrivateFieldLooseBase(this, _request$3)[_request$3],
                displayArgs: _classPrivateFieldLooseBase(this, _oldValues$1)[_oldValues$1].slice(),
                fcmPublicKey: _classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey]
              });
              StorageManager.saveToLSorCookie(NOTIFICATION_PUSH_METHOD_DEFERRED, true);
            }
            _classPrivateFieldLooseBase(this, _setUpWebPush)[_setUpWebPush](_classPrivateFieldLooseBase(this, _oldValues$1)[_oldValues$1]);
          }
          _classPrivateFieldLooseBase(this, _oldValues$1)[_oldValues$1] = null;
        }
        setUpWebPushNotifications(subscriptionCallback, serviceWorkerPath, apnsWebPushId, apnsServiceUrl) {
          if (isChrome() || isFirefox()) {
            _classPrivateFieldLooseBase(this, _setUpChromeFirefoxNotifications)[_setUpChromeFirefoxNotifications](subscriptionCallback, serviceWorkerPath);
          } else if (isSafari()) {
            _classPrivateFieldLooseBase(this, _setUpSafariNotifications)[_setUpSafariNotifications](subscriptionCallback, apnsWebPushId, apnsServiceUrl, serviceWorkerPath);
          }
        }
        setApplicationServerKey(applicationServerKey) {
          _classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey] = applicationServerKey;
        }
        _enableWebPush(enabled, applicationServerKey) {
          $ct.webPushEnabled = enabled;
          if (applicationServerKey != null) {
            this.setApplicationServerKey(applicationServerKey);
          }
          const isNotificationPushCalled = StorageManager.readFromLSorCookie(NOTIFICATION_PUSH_METHOD_DEFERRED);
          if (isNotificationPushCalled) {
            return;
          }
          if ($ct.webPushEnabled && $ct.notifApi.notifEnabledFromApi) {
            _classPrivateFieldLooseBase(this, _handleNotificationRegistration)[_handleNotificationRegistration]($ct.notifApi.displayArgs);
          } else if (!$ct.webPushEnabled && $ct.notifApi.notifEnabledFromApi) ;
        }
      }
      var _setUpWebPush2 = function _setUpWebPush22(displayArgs2) {
        if ($ct.webPushEnabled && displayArgs2.length > 0) {
          _classPrivateFieldLooseBase(this, _handleNotificationRegistration)[_handleNotificationRegistration](displayArgs2);
        } else if ($ct.webPushEnabled == null && displayArgs2.length > 0) {
          $ct.notifApi.notifEnabledFromApi = true;
          $ct.notifApi.displayArgs = displayArgs2.slice();
        } else if ($ct.webPushEnabled === false && displayArgs2.length > 0) {
          _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("Make sure push notifications are fully enabled and integrated");
        }
      };
      var _isNativeWebPushSupported2 = function _isNativeWebPushSupported22() {
        return "PushManager" in window;
      };
      var _setUpSafariNotifications2 = function _setUpSafariNotifications22(subscriptionCallback, apnsWebPushId, apnsServiceUrl, serviceWorkerPath) {
        const softPromptCard = document.getElementById("pnWrapper");
        const oldSoftPromptCard = document.getElementById("wzrk_wrapper");
        if (_classPrivateFieldLooseBase(this, _isNativeWebPushSupported)[_isNativeWebPushSupported]() && _classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey] != null) {
          StorageManager.setMetaProp(VAPID_MIGRATION_PROMPT_SHOWN, true);
          navigator.serviceWorker.register(serviceWorkerPath).then((registration) => {
            window.Notification.requestPermission().then((permission) => {
              if (permission === "granted") {
                const subscribeObj = {
                  applicationServerKey: _classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey],
                  userVisibleOnly: true
                };
                _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Sub Obj" + JSON.stringify(subscribeObj));
                const subscribeForPush = () => {
                  registration.pushManager.subscribe(subscribeObj).then((subscription) => {
                    _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Service Worker registered. Endpoint: " + subscription.endpoint);
                    _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Service Data Sent: " + JSON.stringify({
                      applicationServerKey: _classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey],
                      userVisibleOnly: true
                    }));
                    _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Subscription Data Received: " + JSON.stringify(subscription));
                    const subscriptionData = JSON.parse(JSON.stringify(subscription));
                    subscriptionData.endpoint = subscriptionData.endpoint.split("/").pop();
                    StorageManager.saveToLSorCookie(PUSH_SUBSCRIPTION_DATA, subscriptionData);
                    _classPrivateFieldLooseBase(this, _request$3)[_request$3].registerToken(subscriptionData);
                    if (typeof subscriptionCallback !== "undefined" && typeof subscriptionCallback === "function") {
                      subscriptionCallback();
                    }
                    const existingBellWrapper = document.getElementById("bell_wrapper");
                    if (existingBellWrapper) {
                      existingBellWrapper.parentNode.removeChild(existingBellWrapper);
                    }
                    if (softPromptCard) {
                      softPromptCard.parentNode.removeChild(softPromptCard);
                    }
                    if (oldSoftPromptCard) {
                      oldSoftPromptCard.parentNode.removeChild(oldSoftPromptCard);
                    }
                  });
                };
                const serviceWorker = registration.installing || registration.waiting || registration.active;
                if (serviceWorker && serviceWorker.state === "activated") {
                  subscribeForPush();
                } else if (serviceWorker) {
                  serviceWorker.addEventListener("statechange", (event) => {
                    if (event.target.state === "activated") {
                      _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Service Worker activated. Proceeding with subscription.");
                      subscribeForPush();
                    }
                  });
                }
              } else if (permission === "denied") {
                _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Error subscribing to Safari web push");
                if (softPromptCard) {
                  softPromptCard.parentNode.removeChild(softPromptCard);
                }
                if (oldSoftPromptCard) {
                  oldSoftPromptCard.parentNode.removeChild(oldSoftPromptCard);
                }
              }
            });
          });
        } else {
          if (typeof apnsWebPushId === "undefined") {
            _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("Ensure that APNS Web Push ID is supplied");
          }
          if (typeof apnsServiceUrl === "undefined") {
            _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("Ensure that APNS Web Push service path is supplied");
          }
          if ("safari" in window && "pushNotification" in window.safari) {
            window.safari.pushNotification.requestPermission(apnsServiceUrl, apnsWebPushId, {}, (subscription) => {
              if (subscription.permission === "granted") {
                const subscriptionData = JSON.parse(JSON.stringify(subscription));
                subscriptionData.endpoint = subscription.deviceToken;
                subscriptionData.browser = "Safari";
                _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Service Data Sent: " + JSON.stringify({
                  apnsServiceUrl,
                  apnsWebPushId
                }));
                _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Subscription Data Received: " + JSON.stringify(subscription));
                const existingBellWrapper = document.getElementById("bell_wrapper");
                if (existingBellWrapper) {
                  existingBellWrapper.parentNode.removeChild(existingBellWrapper);
                }
                if (softPromptCard) {
                  softPromptCard.parentNode.removeChild(softPromptCard);
                }
                if (oldSoftPromptCard) {
                  oldSoftPromptCard.parentNode.removeChild(oldSoftPromptCard);
                }
                StorageManager.saveToLSorCookie(PUSH_SUBSCRIPTION_DATA, subscriptionData);
                _classPrivateFieldLooseBase(this, _request$3)[_request$3].registerToken(subscriptionData);
                _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Safari Web Push registered. Device Token: " + subscription.deviceToken);
              } else if (subscription.permission === "denied") {
                _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Error subscribing to Safari web push");
                if (softPromptCard) {
                  softPromptCard.parentNode.removeChild(softPromptCard);
                }
                if (oldSoftPromptCard) {
                  oldSoftPromptCard.parentNode.removeChild(oldSoftPromptCard);
                }
              }
            });
          }
        }
      };
      var _setUpChromeFirefoxNotifications2 = function _setUpChromeFirefoxNotifications22(subscriptionCallback, serviceWorkerPath) {
        let registrationScope = "";
        if ("serviceWorker" in navigator) {
          navigator.serviceWorker.register(serviceWorkerPath).then((registration) => {
            if (typeof __wzrk_account_id !== "undefined") {
              return new Promise((resolve) => setTimeout(() => resolve(registration), 5e3));
            }
            registrationScope = registration.scope;
            const rootDirRegex = /^(\.?)(\/?)([^/]*).js$/;
            const isServiceWorkerAtRoot = rootDirRegex.test(serviceWorkerPath);
            if (isServiceWorkerAtRoot) {
              return navigator.serviceWorker.ready;
            } else {
              if (isChrome()) {
                return new Promise((resolve) => setTimeout(() => resolve(registration), 5e3));
              } else {
                return navigator.serviceWorker.getRegistrations();
              }
            }
          }).then((serviceWorkerRegistration) => {
            if (isFirefox() && Array.isArray(serviceWorkerRegistration)) {
              serviceWorkerRegistration = serviceWorkerRegistration.filter((i) => i.scope === registrationScope)[0];
            }
            const subscribeObj = {
              userVisibleOnly: true
            };
            if (_classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey] != null) {
              subscribeObj.applicationServerKey = urlBase64ToUint8Array(_classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey]);
            }
            const softPromptCard = document.getElementById("pnWrapper");
            const oldSoftPromptCard = document.getElementById("wzrk_wrapper");
            serviceWorkerRegistration.pushManager.subscribe(subscribeObj).then((subscription) => {
              _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Service Worker registered. Endpoint: " + subscription.endpoint);
              _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].debug("Service Data Sent: " + JSON.stringify(subscribeObj));
              _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].debug("Subscription Data Received: " + JSON.stringify(subscription));
              const subscriptionData = JSON.parse(JSON.stringify(subscription));
              if (isChrome()) {
                subscriptionData.endpoint = subscriptionData.endpoint.split("/").pop();
                subscriptionData.browser = "Chrome";
              } else if (isFirefox()) {
                subscriptionData.endpoint = subscriptionData.endpoint.split("/").pop();
                subscriptionData.browser = "Firefox";
              }
              StorageManager.saveToLSorCookie(PUSH_SUBSCRIPTION_DATA, subscriptionData);
              _classPrivateFieldLooseBase(this, _request$3)[_request$3].registerToken(subscriptionData);
              if (typeof subscriptionCallback !== "undefined" && typeof subscriptionCallback === "function") {
                subscriptionCallback();
              }
              const existingBellWrapper = document.getElementById("bell_wrapper");
              if (existingBellWrapper) {
                existingBellWrapper.parentNode.removeChild(existingBellWrapper);
              }
              if (softPromptCard) {
                softPromptCard.parentNode.removeChild(softPromptCard);
              }
              if (oldSoftPromptCard) {
                oldSoftPromptCard.parentNode.removeChild(oldSoftPromptCard);
              }
            }).catch((error) => {
              serviceWorkerRegistration.pushManager.getSubscription().then((subscription) => {
                if (subscription !== null) {
                  subscription.unsubscribe().then((successful) => {
                    _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].info("Unsubscription successful");
                    window.clevertap.notifications.push({
                      skipDialog: true
                    });
                  }).catch((e) => {
                    _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("Error unsubscribing: " + e);
                  });
                }
              });
              _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("Error subscribing: " + error);
              if (softPromptCard) {
                softPromptCard.parentNode.removeChild(softPromptCard);
              }
              if (oldSoftPromptCard) {
                oldSoftPromptCard.parentNode.removeChild(oldSoftPromptCard);
              }
            });
          }).catch((err) => {
            _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("error registering service worker: " + err);
          });
        }
      };
      var _addWizAlertJS2 = function _addWizAlertJS22() {
        const scriptTag = document.createElement("script");
        scriptTag.setAttribute("type", "text/javascript");
        scriptTag.setAttribute("id", "wzrk-alert-js");
        scriptTag.setAttribute("src", _classPrivateFieldLooseBase(this, _wizAlertJSPath)[_wizAlertJSPath]);
        document.getElementsByTagName("body")[0].appendChild(scriptTag);
        return scriptTag;
      };
      var _removeWizAlertJS2 = function _removeWizAlertJS22() {
        const scriptTag = document.getElementById("wzrk-alert-js");
        scriptTag.parentNode.removeChild(scriptTag);
      };
      var _handleNotificationRegistration2 = function _handleNotificationRegistration22(displayArgs2) {
        let titleText;
        let bodyText;
        let okButtonText;
        let rejectButtonText;
        let okButtonColor;
        let skipDialog;
        let askAgainTimeInSeconds;
        let okCallback;
        let rejectCallback;
        let subscriptionCallback;
        let serviceWorkerPath;
        let httpsPopupPath;
        let httpsIframePath;
        let apnsWebPushId;
        let apnsWebPushServiceUrl;
        const vapidSupportedAndMigrated = isSafari() && "PushManager" in window && StorageManager.getMetaProp(VAPID_MIGRATION_PROMPT_SHOWN) && _classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey] !== null;
        if (displayArgs2.length === 1) {
          if (isObject(displayArgs2[0])) {
            const notifObj = displayArgs2[0];
            titleText = notifObj.titleText;
            bodyText = notifObj.bodyText;
            okButtonText = notifObj.okButtonText;
            rejectButtonText = notifObj.rejectButtonText;
            okButtonColor = notifObj.okButtonColor;
            skipDialog = notifObj.skipDialog;
            askAgainTimeInSeconds = notifObj.askAgainTimeInSeconds;
            okCallback = notifObj.okCallback;
            rejectCallback = notifObj.rejectCallback;
            subscriptionCallback = notifObj.subscriptionCallback;
            serviceWorkerPath = notifObj.serviceWorkerPath;
            httpsPopupPath = notifObj.httpsPopupPath;
            httpsIframePath = notifObj.httpsIframePath;
            apnsWebPushId = notifObj.apnsWebPushId;
            apnsWebPushServiceUrl = notifObj.apnsWebPushServiceUrl;
          }
        } else {
          titleText = displayArgs2[0];
          bodyText = displayArgs2[1];
          okButtonText = displayArgs2[2];
          rejectButtonText = displayArgs2[3];
          okButtonColor = displayArgs2[4];
          skipDialog = displayArgs2[5];
          askAgainTimeInSeconds = displayArgs2[6];
        }
        if (skipDialog == null) {
          skipDialog = false;
        }
        if (serviceWorkerPath == null) {
          serviceWorkerPath = "/clevertap_sw.js";
        }
        if (typeof navigator.serviceWorker === "undefined") {
          return;
        }
        const isHTTP = httpsPopupPath != null && httpsIframePath != null;
        if (window.location.protocol !== "https:" && document.location.hostname !== "localhost" && !isHTTP) {
          _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("Make sure you are https or localhost to register for notifications");
          return;
        }
        if (isChrome() || isFirefox()) {
          if (!_classPrivateFieldLooseBase(this, _isNativeWebPushSupported)[_isNativeWebPushSupported]()) {
            _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("Web Push Notification is not supported on this browser");
            return;
          }
        }
        if (!isHTTP) {
          const hasNotification = "Notification" in window;
          if (!hasNotification || Notification == null) {
            _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("Notification not supported on this Device or Browser");
            return;
          }
          if (Notification.permission === "granted" && (vapidSupportedAndMigrated || isChrome() || isFirefox())) {
            this.setUpWebPushNotifications(subscriptionCallback, serviceWorkerPath, apnsWebPushId, apnsWebPushServiceUrl);
            return;
          } else if (Notification.permission === "denied") {
            return;
          }
          if (skipDialog) {
            this.setUpWebPushNotifications(subscriptionCallback, serviceWorkerPath, apnsWebPushId, apnsWebPushServiceUrl);
            return;
          }
        }
        if (!titleText || !bodyText || !okButtonText || !rejectButtonText) {
          _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].error("Missing input parameters; please specify title, body, ok button and cancel button text");
          return;
        }
        if (okButtonColor == null || !okButtonColor.match(/^#[a-f\d]{6}$/i)) {
          okButtonColor = "#f28046";
        }
        const now = (/* @__PURE__ */ new Date()).getTime() / 1e3;
        if (StorageManager.getMetaProp(NOTIF_LAST_TIME) == null) {
          StorageManager.setMetaProp(NOTIF_LAST_TIME, now);
        } else {
          if (askAgainTimeInSeconds == null) {
            askAgainTimeInSeconds = 7 * 24 * 60 * 60;
          }
          const notifLastTime = StorageManager.getMetaProp(NOTIF_LAST_TIME);
          if (now - notifLastTime < askAgainTimeInSeconds) {
            if (!isSafari()) {
              return;
            }
            if (vapidSupportedAndMigrated || _classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey] === null) {
              return;
            }
          } else {
            StorageManager.setMetaProp(NOTIF_LAST_TIME, now);
          }
        }
        if (isSafari() && _classPrivateFieldLooseBase(this, _isNativeWebPushSupported)[_isNativeWebPushSupported]() && _classPrivateFieldLooseBase(this, _fcmPublicKey)[_fcmPublicKey] !== null) {
          StorageManager.setMetaProp(VAPID_MIGRATION_PROMPT_SHOWN, true);
        }
        if (StorageManager.readFromLSorCookie(POPUP_LOADING) || document.getElementById(OLD_SOFT_PROMPT_SELCTOR_ID)) {
          _classPrivateFieldLooseBase(this, _logger$5)[_logger$5].debug("Soft prompt wrapper is already loading or loaded");
          return;
        }
        StorageManager.saveToLSorCookie(POPUP_LOADING, true);
        _classPrivateFieldLooseBase(this, _addWizAlertJS)[_addWizAlertJS]().onload = () => {
          StorageManager.saveToLSorCookie(POPUP_LOADING, false);
          window.wzrkPermissionPopup.wizAlert({
            title: titleText,
            body: bodyText,
            confirmButtonText: okButtonText,
            confirmButtonColor: okButtonColor,
            rejectButtonText
          }, (enabled) => {
            if (enabled) {
              if (typeof okCallback === "function") {
                okCallback();
              }
              this.setUpWebPushNotifications(subscriptionCallback, serviceWorkerPath, apnsWebPushId, apnsWebPushServiceUrl);
            } else {
              if (typeof rejectCallback === "function") {
                rejectCallback();
              }
            }
            _classPrivateFieldLooseBase(this, _removeWizAlertJS)[_removeWizAlertJS]();
          });
        };
      };
      const BELL_BASE64 = "PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi40OTYyIDUuMjQzOTVDMTIuODM5MSA1LjAzMzE3IDEzLjI4NDcgNS4xNDY4OSAxMy40OTczIDUuNDg4NjdDMTMuNzIyMyA1Ljg1MDE4IDEzLjYwMDIgNi4zMjUxOCAxMy4yMzggNi41NDkwMkM3LjM5Mzk5IDEwLjE2MDYgMy41IDE2LjYyNTcgMy41IDI0LjAwMDNDMy41IDM1LjMyMjEgMTIuNjc4MiA0NC41MDAzIDI0IDQ0LjUwMDNDMjguMDA1NSA0NC41MDAzIDMxLjc0MjYgNDMuMzUxNSAzNC45IDQxLjM2NTVDMzUuMjYwOCA0MS4xMzg1IDM1Ljc0MTYgNDEuMjM4NiAzNS45NjY4IDQxLjYwMDZDMzYuMTc5MiA0MS45NDE5IDM2LjA4NSA0Mi4zOTExIDM1Ljc0NTIgNDIuNjA2QzMyLjM0NjggNDQuNzU1OSAyOC4zMTg3IDQ2LjAwMDMgMjQgNDYuMDAwM0MxMS44NDk3IDQ2LjAwMDMgMiAzNi4xNTA1IDIgMjQuMDAwM0MyIDE2LjA2NjkgNi4xOTkyMSA5LjExNDMyIDEyLjQ5NjIgNS4yNDM5NVpNMzguOCAzOS45MDAzQzM4LjggNDAuMzk3MyAzOC4zOTcxIDQwLjgwMDMgMzcuOSA0MC44MDAzQzM3LjQwMjkgNDAuODAwMyAzNyA0MC4zOTczIDM3IDM5LjkwMDNDMzcgMzkuNDAzMiAzNy40MDI5IDM5LjAwMDMgMzcuOSAzOS4wMDAzQzM4LjM5NzEgMzkuMDAwMyAzOC44IDM5LjQwMzIgMzguOCAzOS45MDAzWiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0yNCAxMkMyMi44OTU0IDEyIDIyIDEyLjg5NTQgMjIgMTRWMTQuMjUyQzE4LjU0OTUgMTUuMTQwMSAxNiAxOC4yNzIzIDE2IDIyVjI5LjVIMTUuNDc2OUMxNC42NjEyIDI5LjUgMTQgMzAuMTYxMiAxNCAzMC45NzY5VjMxLjAyMzFDMTQgMzEuODM4OCAxNC42NjEyIDMyLjUgMTUuNDc2OSAzMi41SDMyLjUyMzFDMzMuMzM4OCAzMi41IDM0IDMxLjgzODggMzQgMzEuMDIzMVYzMC45NzY5QzM0IDMwLjE2MTIgMzMuMzM4OCAyOS41IDMyLjUyMzEgMjkuNUgzMlYyMkMzMiAxOC4yNzIzIDI5LjQ1MDUgMTUuMTQwMSAyNiAxNC4yNTJWMTRDMjYgMTIuODk1NCAyNS4xMDQ2IDEyIDI0IDEyWk0yNiAzNFYzMy41SDIyVjM0QzIyIDM1LjEwNDYgMjIuODk1NCAzNiAyNCAzNkMyNS4xMDQ2IDM2IDI2IDM1LjEwNDYgMjYgMzRaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K";
      const PROMPT_BELL_BASE64 = "PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiByeD0iMzIiIGZpbGw9IiMwMEFFQjkiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zMS45OTg2IDIwQzMwLjkxOTggMjAgMzAuMDQyOCAyMC44NzQ2IDMwLjA0MjggMjEuOTUzNEwzMC4wNDI5IDIxLjk3MzRDMjYuNTQzNCAyMi41NTM1IDIzLjg3NSAyNS41OTQzIDIzLjg3NSAyOS4yNTgyVjM4LjA5OTVIMjMuODczNUMyMy4wNTg5IDM4LjA5OTUgMjIuMzk4NCAzOC43NiAyMi4zOTg0IDM5LjU3NDZDMjIuMzk4NCA0MC4zODkzIDIzLjA1ODkgNDEuMDQ5NyAyMy44NzM1IDQxLjA0OTdIMjkuNzgxMlY0MS43ODQyQzI5Ljc4MTIgNDMuMDA3NyAzMC43NzMxIDQzLjk5OTYgMzEuOTk2NiA0My45OTk2QzMzLjIyMDIgNDMuOTk5NiAzNC4yMTIgNDMuMDA3NyAzNC4yMTIgNDEuNzg0MlY0MS4wNDk3SDQwLjEyMzNDNDAuOTM4IDQxLjA0OTcgNDEuNTk4NCA0MC4zODkzIDQxLjU5ODQgMzkuNTc0NkM0MS41OTg0IDM4Ljc2IDQwLjkzOCAzOC4wOTk1IDQwLjEyMzMgMzguMDk5NUg0MC4xMjEyVjI5LjI1ODJDNDAuMTIxMiAyNS41OTQ2IDM3LjQ1MzMgMjIuNTU0MiAzMy45NTQzIDIxLjk3MzZMMzMuOTU0NCAyMS45NTM0QzMzLjk1NDQgMjAuODc0NiAzMy4wNzc1IDIwIDMxLjk5ODYgMjBaIiBmaWxsPSJ3aGl0ZSIvPgo8cmVjdCBvcGFjaXR5PSIwLjUiIHg9IjcuNSIgeT0iNy41IiB3aWR0aD0iNDkiIGhlaWdodD0iNDkiIHJ4PSIyNC41IiBzdHJva2U9IndoaXRlIi8+CjxyZWN0IG9wYWNpdHk9IjAuMyIgeD0iNC41IiB5PSI0LjUiIHdpZHRoPSI1NSIgaGVpZ2h0PSI1NSIgcng9IjI3LjUiIHN0cm9rZT0id2hpdGUiLz4KPHJlY3Qgb3BhY2l0eT0iMC44IiB4PSIxMC41IiB5PSIxMC41IiB3aWR0aD0iNDMiIGhlaWdodD0iNDMiIHJ4PSIyMS41IiBzdHJva2U9IndoaXRlIi8+Cjwvc3ZnPgo=";
      let appServerKey = null;
      let swPath = "/clevertap_sw.js";
      let notificationHandler = null;
      let logger = null;
      let account = null;
      let request = null;
      let displayArgs = null;
      let fcmPublicKey = null;
      const setNotificationHandlerValues = function() {
        let notificationValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        logger = notificationValues.logger;
        account = notificationValues.account;
        request = notificationValues.request;
        displayArgs = notificationValues.displayArgs;
        fcmPublicKey = notificationValues.fcmPublicKey;
      };
      const processWebPushConfig = (webPushConfig, logger2, request2) => {
        StorageManager.saveToLSorCookie(WEBPUSH_CONFIG_RECEIVED, true);
        const updatePushConfig = () => {
          $ct.pushConfig = webPushConfig;
          StorageManager.saveToLSorCookie(WEBPUSH_CONFIG, webPushConfig);
        };
        updatePushConfig();
        if (webPushConfig.isPreview) {
          enablePush({
            logger: logger2,
            request: request2
          });
        }
        try {
          const isNotificationPushCalled = StorageManager.readFromLSorCookie(NOTIFICATION_PUSH_METHOD_DEFERRED);
          if (isNotificationPushCalled) {
            try {
              processSoftPrompt();
            } catch (error) {
              logger2.error("processs soft prompt" + error);
            }
            return;
          }
        } catch (error) {
          logger2.error("Failed to process web push config:", error);
          processSoftPrompt();
        }
      };
      const processSoftPrompt = () => {
        const webPushConfig = StorageManager.readFromLSorCookie(WEBPUSH_CONFIG) || {};
        notificationHandler = new NotificationHandler({
          logger,
          session: {},
          request,
          account
        });
        if (webPushConfig && !(Object.keys(webPushConfig).length > 0)) {
          notificationHandler.setApplicationServerKey(appServerKey);
          notificationHandler.setupWebPush(displayArgs);
          return;
        }
        const {
          showBox,
          showBellIcon,
          boxType
        } = webPushConfig;
        const {
          serviceWorkerPath,
          skipDialog,
          okCallback,
          subscriptionCallback,
          rejectCallback,
          apnsWebPushId,
          apnsWebPushServiceUrl
        } = parseDisplayArgs(displayArgs);
        const isSoftPromptNew = showBellIcon || showBox && boxType === "new";
        if (isSoftPromptNew) {
          const enablePushParams = {
            serviceWorkerPath,
            skipDialog,
            okCallback,
            subscriptionCallback,
            rejectCallback,
            logger,
            request,
            account,
            fcmPublicKey,
            apnsWebPushId,
            apnsWebPushServiceUrl
          };
          enablePush(enablePushParams);
        }
        if (showBox && boxType === "old") {
          notificationHandler.setApplicationServerKey(appServerKey);
          notificationHandler.setupWebPush(displayArgs);
        }
        StorageManager.saveToLSorCookie(NOTIFICATION_PUSH_METHOD_DEFERRED, false);
        StorageManager.saveToLSorCookie(APPLICATION_SERVER_KEY_RECEIVED, false);
      };
      const parseDisplayArgs = (displayArgs2) => {
        if (displayArgs2 && displayArgs2.length === 1 && isObject(displayArgs2[0])) {
          const {
            serviceWorkerPath,
            skipDialog,
            okCallback,
            subscriptionCallback,
            rejectCallback,
            apnsWebPushServiceUrl,
            apnsWebPushId
          } = displayArgs2[0];
          return {
            serviceWorkerPath,
            skipDialog,
            okCallback,
            subscriptionCallback,
            rejectCallback,
            apnsWebPushServiceUrl,
            apnsWebPushId
          };
        }
        return {
          serviceWorkerPath: void 0,
          skipDialog: displayArgs2[5],
          okCallback: void 0,
          subscriptionCallback: void 0,
          rejectCallback: void 0,
          apnsWebPushServiceUrl: void 0,
          apnsWebPushId: void 0
        };
      };
      const enablePush = (enablePushParams) => {
        const {
          serviceWorkerPath: customSwPath,
          okCallback,
          subscriptionCallback,
          rejectCallback,
          logger: logger2,
          fcmPublicKey: fcmPublicKey2,
          apnsWebPushId,
          apnsWebPushServiceUrl
        } = enablePushParams;
        let {
          skipDialog
        } = enablePushParams;
        const _pushConfig = StorageManager.readFromLSorCookie(WEBPUSH_CONFIG) || {};
        $ct.pushConfig = _pushConfig;
        if (!$ct.pushConfig) {
          logger2.error("Web Push config data not present");
          return;
        }
        if (customSwPath) {
          swPath = customSwPath;
        }
        if (skipDialog === null) {
          skipDialog = false;
        }
        if (skipDialog) {
          notificationHandler.setApplicationServerKey(appServerKey);
          notificationHandler.setUpWebPushNotifications(subscriptionCallback, swPath, apnsWebPushId, apnsWebPushServiceUrl);
          return;
        }
        const {
          showBox,
          boxType,
          showBellIcon,
          isPreview
        } = $ct.pushConfig;
        if (isPreview) {
          if ($ct.pushConfig.boxConfig) createNotificationBox($ct.pushConfig, fcmPublicKey2);
          if ($ct.pushConfig.bellIconConfig) createBellIcon($ct.pushConfig);
        } else {
          if (showBox && boxType === "new") createNotificationBox($ct.pushConfig, fcmPublicKey2, okCallback, subscriptionCallback, rejectCallback, apnsWebPushId, apnsWebPushServiceUrl);
          if (showBellIcon) createBellIcon($ct.pushConfig, subscriptionCallback, apnsWebPushId, apnsWebPushServiceUrl);
        }
      };
      const createElementWithAttributes = function(tag) {
        let attributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const element = document.createElement(tag);
        Object.entries(attributes).forEach((_ref) => {
          let [key, value] = _ref;
          element[key] = value;
        });
        return element;
      };
      const createNotificationBox = (configData, fcmPublicKey2, okCallback, subscriptionCallback, rejectCallback, apnsWebPushId, apnsWebPushServiceUrl) => {
        if (document.getElementById(NEW_SOFT_PROMPT_SELCTOR_ID)) return;
        const {
          boxConfig: {
            content,
            style
          }
        } = configData;
        const wrapper = createElementWithAttributes("div", {
          id: NEW_SOFT_PROMPT_SELCTOR_ID
        });
        const overlayDiv = style.overlay.enabled ? createElementWithAttributes("div", {
          id: "pnOverlay"
        }) : "";
        const pnCard = createElementWithAttributes("div", {
          id: "pnCard"
        });
        const iconTitleDescWrapper = createElementWithAttributes("div", {
          id: "iconTitleDescWrapper"
        });
        const iconContainer = createElementWithAttributes("img", {
          id: "iconContainer",
          src: content.icon.type === "default" ? "data:image/svg+xml;base64,".concat(PROMPT_BELL_BASE64) : content.icon.url
        });
        iconTitleDescWrapper.appendChild(iconContainer);
        const titleDescWrapper = createElementWithAttributes("div", {
          id: "titleDescWrapper"
        });
        titleDescWrapper.appendChild(createElementWithAttributes("div", {
          id: "title",
          textContent: content.title
        }));
        titleDescWrapper.appendChild(createElementWithAttributes("div", {
          id: "description",
          textContent: content.description
        }));
        iconTitleDescWrapper.appendChild(titleDescWrapper);
        const buttonsContainer = createElementWithAttributes("div", {
          id: "buttonsContainer"
        });
        const primaryButton = createElementWithAttributes("button", {
          id: "primaryButton",
          textContent: content.buttons.primaryButtonText
        });
        const secondaryButton = createElementWithAttributes("button", {
          id: "secondaryButton",
          textContent: content.buttons.secondaryButtonText
        });
        buttonsContainer.appendChild(secondaryButton);
        buttonsContainer.appendChild(primaryButton);
        pnCard.appendChild(iconTitleDescWrapper);
        pnCard.appendChild(buttonsContainer);
        const styleElement = createElementWithAttributes("style", {
          textContent: getBoxPromptStyles(style)
        });
        wrapper.appendChild(styleElement);
        wrapper.appendChild(pnCard);
        if (overlayDiv) {
          wrapper.appendChild(overlayDiv);
        }
        setElementPosition(pnCard, style.card.position);
        const vapidSupportedAndMigrated = isSafari() && "PushManager" in window && StorageManager.getMetaProp(VAPID_MIGRATION_PROMPT_SHOWN) && fcmPublicKey2 !== null;
        if (!configData.isPreview) {
          if ("Notification" in window && Notification !== null) {
            if (Notification.permission === "granted" && (vapidSupportedAndMigrated || isChrome() || isFirefox())) {
              notificationHandler.setApplicationServerKey(appServerKey);
              notificationHandler.setUpWebPushNotifications(subscriptionCallback, swPath, apnsWebPushId, apnsWebPushServiceUrl);
              return;
            } else if (Notification.permission === "denied") {
              return;
            }
          }
        }
        const now = (/* @__PURE__ */ new Date()).getTime() / 1e3;
        const lastNotifTime = StorageManager.getMetaProp("webpush_last_notif_time");
        const popupFrequency = content.popupFrequency || 7;
        const shouldShowNotification = !lastNotifTime || now - lastNotifTime >= popupFrequency * 24 * 60 * 60;
        if (shouldShowNotification) {
          document.body.appendChild(wrapper);
          if (!configData.isPreview) {
            StorageManager.setMetaProp("webpush_last_notif_time", now);
            addEventListeners(wrapper, okCallback, subscriptionCallback, rejectCallback, apnsWebPushId, apnsWebPushServiceUrl);
            if (isSafari() && "PushManager" in window && fcmPublicKey2 != null) {
              StorageManager.setMetaProp(VAPID_MIGRATION_PROMPT_SHOWN, true);
            }
          }
        } else {
          if (isSafari()) {
            if (vapidSupportedAndMigrated || fcmPublicKey2 === null) {
              return;
            }
            if (!configData.isPreview) {
              document.body.appendChild(wrapper);
              addEventListeners(wrapper, okCallback, subscriptionCallback, rejectCallback, apnsWebPushId, apnsWebPushServiceUrl);
              StorageManager.setMetaProp("webpush_last_notif_time", now);
              StorageManager.setMetaProp(VAPID_MIGRATION_PROMPT_SHOWN, true);
            }
          }
        }
      };
      const createBellIcon = (configData, subscriptionCallback, apnsWebPushId, apnsWebPushServiceUrl) => {
        if (document.getElementById("bell_wrapper") || Notification.permission === "granted") return;
        const {
          bellIconConfig: {
            content,
            style
          }
        } = configData;
        const bellWrapper = createElementWithAttributes("div", {
          id: "bell_wrapper"
        });
        const bellIcon = createElementWithAttributes("img", {
          id: "bell_icon",
          src: content.icon.type === "default" ? "data:image/svg+xml;base64,".concat(BELL_BASE64) : content.icon.url
        });
        const gifModal = createElementWithAttributes("div", {
          id: "gif_modal",
          style: "display: none;"
        });
        const gifImage = createElementWithAttributes("img", {
          id: "gif_image",
          src: "https://d2r1yp2w7bby2u.cloudfront.net/js/permission_grant.gif"
        });
        const closeModal = createElementWithAttributes("div", {
          id: "close_modal",
          innerHTML: "&times;"
        });
        gifModal.appendChild(gifImage);
        gifModal.appendChild(closeModal);
        bellWrapper.appendChild(bellIcon);
        bellWrapper.appendChild(gifModal);
        if (content.hoverText.enabled) {
          const tooltip = createElementWithAttributes("div", {
            id: "bell_tooltip",
            textContent: content.hoverText.text
          });
          bellWrapper.appendChild(tooltip);
        }
        setElementPosition(bellWrapper, style.card.position);
        const styleElement = createElementWithAttributes("style", {
          textContent: getBellIconStyles(style)
        });
        document.head.appendChild(styleElement);
        document.body.appendChild(bellWrapper);
        if (!configData.isPreview) {
          addBellEventListeners(bellWrapper, subscriptionCallback, apnsWebPushId, apnsWebPushServiceUrl);
        }
        return bellWrapper;
      };
      const setServerKey = (serverKey) => {
        appServerKey = serverKey;
        fcmPublicKey = serverKey;
      };
      const addEventListeners = (wrapper, okCallback, subscriptionCallback, rejectCallback, apnsWebPushId, apnsWebPushServiceUrl) => {
        const primaryButton = wrapper.querySelector("#primaryButton");
        const secondaryButton = wrapper.querySelector("#secondaryButton");
        const removeWrapper = () => {
          var _wrapper$parentNode;
          return (_wrapper$parentNode = wrapper.parentNode) === null || _wrapper$parentNode === void 0 ? void 0 : _wrapper$parentNode.removeChild(wrapper);
        };
        primaryButton.addEventListener("click", () => {
          removeWrapper();
          notificationHandler.setApplicationServerKey(appServerKey);
          notificationHandler.setUpWebPushNotifications(subscriptionCallback, swPath, apnsWebPushId, apnsWebPushServiceUrl);
          if (typeof okCallback === "function") {
            okCallback();
          }
        });
        secondaryButton.addEventListener("click", () => {
          removeWrapper();
          if (typeof rejectCallback === "function") {
            rejectCallback();
          }
        });
      };
      const addBellEventListeners = (bellWrapper, subscriptionCallback, apnsWebPushId, apnsWebPushServiceUrl) => {
        const bellIcon = bellWrapper.querySelector("#bell_icon");
        bellIcon.addEventListener("click", () => {
          if (Notification.permission === "denied") {
            toggleGifModal(bellWrapper);
          } else {
            notificationHandler.setApplicationServerKey(appServerKey);
            notificationHandler.setUpWebPushNotifications(subscriptionCallback, swPath, apnsWebPushId, apnsWebPushServiceUrl);
            if (Notification.permission === "granted") {
              bellWrapper.remove();
            }
          }
        });
        bellIcon.addEventListener("mouseenter", () => displayTooltip(bellWrapper));
        bellIcon.addEventListener("mouseleave", () => clearTooltip(bellWrapper));
        bellWrapper.querySelector("#close_modal").addEventListener("click", () => toggleGifModal(bellWrapper));
      };
      const setElementPosition = (element, position) => {
        Object.assign(element.style, {
          inset: "auto",
          transform: "none"
        });
        const positions = {
          "Top Right": {
            inset: "16px 16px auto auto"
          },
          "Top Left": {
            inset: "16px auto auto 16px"
          },
          "Bottom Right": {
            inset: "auto 16px 16px auto"
          },
          "Bottom Left": {
            inset: "auto auto 16px 16px"
          },
          Center: {
            inset: "50%",
            transform: "translate(-50%, -50%)"
          },
          Top: {
            inset: "16px auto auto 50%",
            transform: "translateX(-50%)"
          },
          Bottom: {
            inset: "auto auto 16px 50%",
            transform: "translateX(-50%)"
          }
        };
        Object.assign(element.style, positions[position] || positions["top-right"]);
      };
      const displayTooltip = (bellWrapper) => {
        const gifModal = bellWrapper.querySelector("#gif_modal");
        if (gifModal.style.display === "flex") {
          return;
        }
        const tooltip = bellWrapper.querySelector("#bell_tooltip");
        if (tooltip) {
          tooltip.style.display = "flex";
        }
        const bellIcon = bellWrapper.querySelector("#bell_icon");
        const bellRect = bellIcon.getBoundingClientRect();
        var midX = window.innerWidth / 2;
        var midY = window.innerHeight / 2;
        bellWrapper.style["flex-direction"] = bellRect.y > midY ? "column-reverse" : "column";
        bellWrapper.style["align-items"] = bellRect.x > midX ? "flex-end" : "flex-start";
      };
      const clearTooltip = (bellWrapper) => {
        const tooltip = bellWrapper.querySelector("#bell_tooltip");
        if (tooltip) {
          tooltip.style.display = "none";
        }
      };
      const toggleGifModal = (bellWrapper) => {
        clearTooltip(bellWrapper);
        const gifModal = bellWrapper.querySelector("#gif_modal");
        gifModal.style.display = gifModal.style.display === "none" ? "flex" : "none";
      };
      const _tr = (msg, _ref) => {
        let {
          device,
          session,
          request: request2,
          logger: logger2,
          region
        } = _ref;
        const _device2 = device;
        const _session2 = session;
        const _request2 = request2;
        const _logger2 = logger2;
        const _region2 = region;
        let _wizCounter = 0;
        const doCampHouseKeeping = (targetingMsgJson) => {
          const campaignId = targetingMsgJson.wzrk_id.split("_")[0];
          const today = getToday();
          const incrCount = (obj, campaignId2, excludeFromFreqCaps2) => {
            let currentCount = 0;
            let totalCount = 0;
            if (obj[campaignId2] != null) {
              currentCount = obj[campaignId2];
            }
            currentCount++;
            if (obj.tc != null) {
              totalCount = obj.tc;
            }
            if (excludeFromFreqCaps2 < 0) {
              totalCount++;
            }
            obj.tc = totalCount;
            obj[campaignId2] = currentCount;
          };
          if (StorageManager._isLocalStorageSupported()) {
            delete sessionStorage[CAMP_COOKIE_NAME];
            var campTypeObj = {};
            const campObj = getCampaignObject();
            if (targetingMsgJson.display.wtarget_type === 3 && campObj.hasOwnProperty("wi")) {
              campTypeObj = campObj.wi;
            } else if ((targetingMsgJson.display.wtarget_type === 0 || targetingMsgJson.display.wtarget_type === 1) && campObj.hasOwnProperty("wp")) {
              campTypeObj = campObj.wp;
            } else {
              campTypeObj = {};
            }
            if (campObj.hasOwnProperty("global")) {
              campTypeObj.wp = campObj;
            }
            if (targetingMsgJson[DISPLAY].wmc == null) {
              targetingMsgJson[DISPLAY].wmc = 1;
            }
            if (targetingMsgJson[DISPLAY].wimc == null) {
              targetingMsgJson[DISPLAY].wimc = 1;
            }
            var excludeFromFreqCaps = -1;
            let campaignSessionLimit = -1;
            let campaignDailyLimit = -1;
            let campaignTotalLimit = -1;
            let totalDailyLimit = -1;
            let totalSessionLimit = -1;
            let totalInboxSessionLimit = -1;
            if (targetingMsgJson[DISPLAY].efc != null) {
              excludeFromFreqCaps = parseInt(targetingMsgJson[DISPLAY].efc, 10);
            }
            if (targetingMsgJson[DISPLAY].mdc != null) {
              campaignSessionLimit = parseInt(targetingMsgJson[DISPLAY].mdc, 10);
            }
            if (targetingMsgJson[DISPLAY].tdc != null) {
              campaignDailyLimit = parseInt(targetingMsgJson[DISPLAY].tdc, 10);
            }
            if (targetingMsgJson[DISPLAY].tlc != null) {
              campaignTotalLimit = parseInt(targetingMsgJson[DISPLAY].tlc, 10);
            }
            if (targetingMsgJson[DISPLAY].wmp != null) {
              totalDailyLimit = parseInt(targetingMsgJson[DISPLAY].wmp, 10);
            }
            if (targetingMsgJson[DISPLAY].wmc != null) {
              totalSessionLimit = parseInt(targetingMsgJson[DISPLAY].wmc, 10);
            }
            if (targetingMsgJson[DISPLAY].wimc != null) {
              totalInboxSessionLimit = parseInt(targetingMsgJson[DISPLAY].wimc, 10);
            }
            var sessionObj = campTypeObj[_session2.sessionId];
            if (sessionObj) {
              const campaignSessionCount = sessionObj[campaignId];
              const totalSessionCount = sessionObj.tc;
              if (campaignSessionCount === "dnd" && !$ct.dismissSpamControl) {
                return false;
              }
              if (targetingMsgJson[DISPLAY].wtarget_type === 3) {
                if (totalInboxSessionLimit > 0 && totalSessionCount >= totalInboxSessionLimit && excludeFromFreqCaps < 0) {
                  return false;
                }
              } else {
                if (totalSessionLimit > 0 && totalSessionCount >= totalSessionLimit && excludeFromFreqCaps < 0) {
                  return false;
                }
              }
              if (campaignSessionLimit > 0 && campaignSessionCount >= campaignSessionLimit) {
                return false;
              }
            } else {
              sessionObj = {};
              campTypeObj[_session2.sessionId] = sessionObj;
            }
            var dailyObj = campTypeObj[today];
            if (dailyObj != null) {
              const campaignDailyCount = dailyObj[campaignId];
              const totalDailyCount = dailyObj.tc;
              if (totalDailyLimit > 0 && totalDailyCount >= totalDailyLimit && excludeFromFreqCaps < 0) {
                return false;
              }
              if (campaignDailyLimit > 0 && campaignDailyCount >= campaignDailyLimit) {
                return false;
              }
            } else {
              dailyObj = {};
              campTypeObj[today] = dailyObj;
            }
            var globalObj = campTypeObj[GLOBAL];
            if (globalObj != null) {
              const campaignTotalCount = globalObj[campaignId];
              if (campaignTotalLimit > 0 && campaignTotalCount >= campaignTotalLimit) {
                return false;
              }
            } else {
              globalObj = {};
              campTypeObj[GLOBAL] = globalObj;
            }
          }
          const displayObj = targetingMsgJson.display;
          if (displayObj.delay != null && displayObj.delay > 0) {
            const delay = displayObj.delay;
            displayObj.delay = 0;
            setTimeout(_tr, delay * 1e3, msg, {
              device: _device2,
              session: _session2,
              request: _request2,
              logger: _logger2
            });
            return false;
          }
          incrCount(sessionObj, campaignId, excludeFromFreqCaps);
          incrCount(dailyObj, campaignId, excludeFromFreqCaps);
          incrCount(globalObj, campaignId, excludeFromFreqCaps);
          let campKey = "wp";
          if (targetingMsgJson[DISPLAY].wtarget_type === 3) {
            campKey = "wi";
          }
          const newCampObj = {};
          newCampObj[_session2.sessionId] = sessionObj;
          newCampObj[today] = dailyObj;
          newCampObj[GLOBAL] = globalObj;
          saveCampaignObject({
            [campKey]: newCampObj
          });
        };
        const setupClickUrl = (onClick, targetingMsgJson, contentDiv, divId, isLegacy) => {
          incrementImpression(targetingMsgJson, _request2);
          setupClickEvent(onClick, targetingMsgJson, contentDiv, divId, isLegacy, _device2, _session2);
        };
        const handleImageOnlyPopup = (targetingMsgJson) => {
          const divId = "wzrkImageOnlyDiv";
          if (doCampHouseKeeping(targetingMsgJson) === false) {
            return;
          }
          if ($ct.dismissSpamControl && document.getElementById(divId) != null) {
            const element = document.getElementById(divId);
            element.remove();
          }
          if (document.getElementById(divId) != null || document.getElementById("intentPreview") != null) {
            return;
          }
          const msgDiv = document.createElement("div");
          msgDiv.id = divId;
          document.body.appendChild(msgDiv);
          if (customElements.get("ct-web-popup-imageonly") === void 0) {
            customElements.define("ct-web-popup-imageonly", CTWebPopupImageOnly);
          }
          return renderPopUpImageOnly(targetingMsgJson, _session2);
        };
        const isExistingCampaign = (campaignId) => {
          const testIframe = document.getElementById("wiz-iframe-intent") || document.getElementById("wiz-iframe");
          if (testIframe) {
            const iframeDocument = testIframe.contentDocument || testIframe.contentWindow.document;
            return iframeDocument.documentElement.innerHTML.includes(campaignId);
          }
          return false;
        };
        const createTemplate = (targetingMsgJson, isExitIntent) => {
          const campaignId = targetingMsgJson.wzrk_id.split("_")[0];
          const displayObj = targetingMsgJson.display;
          if (displayObj.layout === 1) {
            return showExitIntent(void 0, targetingMsgJson);
          }
          if (displayObj.layout === 3) {
            handleImageOnlyPopup(targetingMsgJson);
            return;
          }
          if (doCampHouseKeeping(targetingMsgJson) === false) {
            return;
          }
          const divId = "wizParDiv" + displayObj.layout;
          const opacityDivId = "intentOpacityDiv" + displayObj.layout;
          if ($ct.dismissSpamControl && document.getElementById(divId) != null) {
            const element = document.getElementById(divId);
            const opacityElement = document.getElementById(opacityDivId);
            if (element) {
              element.remove();
            }
            if (opacityElement) {
              opacityElement.remove();
            }
          }
          if (isExistingCampaign(campaignId)) return;
          if (document.getElementById(divId) != null) {
            return;
          }
          $ct.campaignDivMap[campaignId] = divId;
          const isBanner = displayObj.layout === 2;
          if (isExitIntent) {
            const opacityDiv = document.createElement("div");
            opacityDiv.id = opacityDivId;
            const opacity = targetingMsgJson.display.opacity || 0.7;
            const rgbaColor = "rgba(0,0,0,".concat(opacity, ")");
            opacityDiv.setAttribute("style", "position: fixed;top: 0;bottom: 0;left: 0;width: 100%;height: 100%;z-index: 2147483646;background: ".concat(rgbaColor, ";"));
            document.body.appendChild(opacityDiv);
          }
          const msgDiv = document.createElement("div");
          msgDiv.id = divId;
          const viewHeight = window.innerHeight;
          const viewWidth = window.innerWidth;
          let legacy = false;
          if (!isBanner) {
            const marginBottom = viewHeight * 5 / 100;
            var contentHeight = 10;
            let right = viewWidth * 5 / 100;
            let bottomPosition = contentHeight + marginBottom;
            let width = viewWidth * 30 / 100 + 20;
            let widthPerct = "width:30%;";
            if ((/mobile/i.test(navigator.userAgent) || /mini/i.test(navigator.userAgent)) && /iPad/i.test(navigator.userAgent) === false) {
              width = viewWidth * 85 / 100 + 20;
              right = viewWidth * 5 / 100;
              bottomPosition = viewHeight * 5 / 100;
              widthPerct = "width:80%;";
            } else if ("ontouchstart" in window || /tablet/i.test(navigator.userAgent)) {
              width = viewWidth * 50 / 100 + 20;
              right = viewWidth * 5 / 100;
              bottomPosition = viewHeight * 5 / 100;
              widthPerct = "width:50%;";
            }
            if (displayObj.proto == null) {
              legacy = true;
              msgDiv.setAttribute("style", "display:block;overflow:hidden; bottom:" + bottomPosition + "px !important;width:" + width + "px !important;right:" + right + "px !important;position:fixed;z-index:2147483647;");
            } else {
              msgDiv.setAttribute("style", widthPerct + displayObj.iFrameStyle);
            }
          } else {
            msgDiv.setAttribute("style", displayObj.iFrameStyle);
          }
          document.body.appendChild(msgDiv);
          const iframe = document.createElement("iframe");
          const borderRadius = displayObj.br === false ? "0" : "8";
          iframe.frameborder = "0px";
          iframe.marginheight = "0px";
          iframe.marginwidth = "0px";
          iframe.scrolling = "no";
          iframe.id = "wiz-iframe";
          const onClick = targetingMsgJson.display.onClick;
          let pointerCss = "";
          if (onClick !== "" && onClick != null) {
            pointerCss = "cursor:pointer;";
          }
          if (displayObj.preview) {
            iframe.sandbox = "allow-scripts allow-popups allow-popups-to-escape-sandbox allow-same-origin";
          }
          let html;
          if (targetingMsgJson.msgContent.type === 1) {
            html = targetingMsgJson.msgContent.html;
            html = html.replace(/##campaignId##/g, campaignId);
            html = html.replace(/##campaignId_batchId##/g, targetingMsgJson.wzrk_id);
          } else {
            const css = '<style type="text/css">body{margin:0;padding:0;}#contentDiv.wzrk{overflow:hidden;padding:0;text-align:center;' + pointerCss + "}#contentDiv.wzrk td{padding:15px 10px;}.wzrkPPtitle{font-weight: bold;font-size: 16px;font-family:arial;padding-bottom:10px;word-break: break-word;}.wzrkPPdscr{font-size: 14px;font-family:arial;line-height:16px;word-break: break-word;display:inline-block;}.PL15{padding-left:15px;}.wzrkPPwarp{margin:20px 20px 0 5px;padding:0px;border-radius: " + borderRadius + "px;box-shadow: 1px 1px 5px #888888;}a.wzrkClose{cursor:pointer;position: absolute;top: 11px;right: 11px;z-index: 2147483647;font-size:19px;font-family:arial;font-weight:bold;text-decoration: none;width: 25px;/*height: 25px;*/text-align: center; -webkit-appearance: none; line-height: 25px;background: #353535;border: #fff 2px solid;border-radius: 100%;box-shadow: #777 2px 2px 2px;color:#fff;}a:hover.wzrkClose{background-color:#d1914a !important;color:#fff !important; -webkit-appearance: none;}td{vertical-align:top;}td.imgTd{border-top-left-radius:8px;border-bottom-left-radius:8px;}</style>";
            let bgColor, textColor, btnBg, leftTd, btColor;
            if (targetingMsgJson.display.theme === "dark") {
              bgColor = "#2d2d2e";
              textColor = "#eaeaea";
              btnBg = "#353535";
              leftTd = "#353535";
              btColor = "#ffffff";
            } else {
              bgColor = "#ffffff";
              textColor = "#000000";
              leftTd = "#f4f4f4";
              btnBg = "#a5a6a6";
              btColor = "#ffffff";
            }
            const titleText = targetingMsgJson.msgContent.title;
            const descriptionText = targetingMsgJson.msgContent.description;
            let imageTd = "";
            if (targetingMsgJson.msgContent.imageUrl != null && targetingMsgJson.msgContent.imageUrl !== "") {
              imageTd = "<td class='imgTd' style='background-color:" + leftTd + "'><img src='" + targetingMsgJson.msgContent.imageUrl + "' height='60' width='60'></td>";
            }
            const onClickStr = "parent.$WZRK_WR.closeIframe(" + campaignId + ",'" + divId + "');";
            const title = "<div class='wzrkPPwarp' style='color:" + textColor + ";background-color:" + bgColor + ";'><a href='javascript:void(0);' onclick=" + onClickStr + " class='wzrkClose' style='background-color:" + btnBg + ";color:" + btColor + "'>&times;</a><div id='contentDiv' class='wzrk'><table cellpadding='0' cellspacing='0' border='0'><tr>" + imageTd + "<td style='vertical-align:top;'><div class='wzrkPPtitle' style='color:" + textColor + "'>" + titleText + "</div>";
            const body = "<div class='wzrkPPdscr' style='color:" + textColor + "'>" + descriptionText + "<div></td></tr></table></div>";
            html = css + title + body;
          }
          iframe.setAttribute("style", "color-scheme: none; z-index: 2147483647; display:block; width: 100% !important; border:0px !important; border-color:none !important;");
          msgDiv.appendChild(iframe);
          const closeCampaign = new Event("CT_campaign_rendered");
          document.dispatchEvent(closeCampaign);
          if (displayObj["custom-editor"]) {
            html = appendScriptForCustomEvent(targetingMsgJson, html);
          }
          iframe.srcdoc = html;
          const adjustIFrameHeight = () => {
            contentHeight = document.getElementById("wiz-iframe").contentDocument.getElementById("contentDiv").scrollHeight;
            if (displayObj["custom-editor"] !== true && !isBanner) {
              contentHeight += 25;
            }
            document.getElementById("wiz-iframe").contentDocument.body.style.margin = "0px";
            document.getElementById("wiz-iframe").style.height = contentHeight + "px";
          };
          const ua = navigator.userAgent.toLowerCase();
          if (ua.indexOf("safari") !== -1) {
            if (ua.indexOf("chrome") > -1) {
              iframe.onload = () => {
                adjustIFrameHeight();
                const contentDiv = document.getElementById("wiz-iframe").contentDocument.getElementById("contentDiv");
                setupClickUrl(onClick, targetingMsgJson, contentDiv, divId, legacy);
              };
            } else {
              let inDoc = iframe.contentDocument || iframe.contentWindow;
              if (inDoc.document) inDoc = inDoc.document;
              const _timer = setInterval(() => {
                if (inDoc.readyState === "complete") {
                  clearInterval(_timer);
                  adjustIFrameHeight();
                  const contentDiv = document.getElementById("wiz-iframe").contentDocument.getElementById("contentDiv");
                  setupClickUrl(onClick, targetingMsgJson, contentDiv, divId, legacy);
                }
              }, 300);
            }
          } else {
            iframe.onload = () => {
              adjustIFrameHeight();
              const contentDiv = document.getElementById("wiz-iframe").contentDocument.getElementById("contentDiv");
              setupClickUrl(onClick, targetingMsgJson, contentDiv, divId, legacy);
            };
          }
        };
        const renderFooterNotification = (targetingMsgJson) => {
          createTemplate(targetingMsgJson, false);
        };
        let _callBackCalled = false;
        const showFooterNotification = (targetingMsgJson) => {
          let onClick = targetingMsgJson.display.onClick;
          const displayObj = targetingMsgJson.display;
          if (window.clevertap.hasOwnProperty("notificationCallback") && typeof window.clevertap.notificationCallback !== "undefined" && typeof window.clevertap.notificationCallback === "function") {
            const notificationCallback = window.clevertap.notificationCallback;
            if (!_callBackCalled) {
              const inaObj = {};
              inaObj.msgContent = targetingMsgJson.msgContent;
              inaObj.msgId = targetingMsgJson.wzrk_id;
              if (targetingMsgJson.wzrk_pivot) {
                inaObj.pivotId = targetingMsgJson.wzrk_pivot;
              }
              if (targetingMsgJson.display.kv != null) {
                inaObj.kv = targetingMsgJson.display.kv;
              }
              window.clevertap.raiseNotificationClicked = () => {
                if (onClick !== "" && onClick != null) {
                  const jsFunc = targetingMsgJson.display.jsFunc;
                  onClick += getCookieParams(_device2, _session2);
                  if (jsFunc != null) {
                    RequestDispatcher.fireRequest(onClick);
                    invokeExternalJs(jsFunc, targetingMsgJson);
                    return;
                  }
                  if (targetingMsgJson.display.window === 1) {
                    window.open(onClick, "_blank");
                  } else {
                    window.location = onClick;
                  }
                }
              };
              window.clevertap.raiseNotificationViewed = () => {
                incrementImpression(targetingMsgJson);
              };
              notificationCallback(inaObj);
              _callBackCalled = true;
            }
          } else {
            window.clevertap.popupCurrentWzrkId = targetingMsgJson.wzrk_id;
            if (displayObj.deliveryTrigger) {
              if (displayObj.deliveryTrigger.inactive) {
                triggerByInactivity(targetingMsgJson);
              }
              if (displayObj.deliveryTrigger.scroll) {
                triggerByScroll(targetingMsgJson);
              }
              if (displayObj.deliveryTrigger.isExitIntent) {
                exitintentObj = targetingMsgJson;
                window.document.body.onmouseleave = showExitIntent;
              }
              const delay = displayObj.delay || displayObj.deliveryTrigger.deliveryDelayed;
              if (delay != null && delay > 0) {
                setTimeout(() => {
                  renderFooterNotification(targetingMsgJson);
                }, delay * 1e3);
              }
            } else {
              renderFooterNotification(targetingMsgJson);
            }
            if (window.clevertap.hasOwnProperty("popupCallbacks") && typeof window.clevertap.popupCallbacks !== "undefined" && typeof window.clevertap.popupCallbacks[targetingMsgJson.wzrk_id] === "function") {
              const popupCallback = window.clevertap.popupCallbacks[targetingMsgJson.wzrk_id];
              const inaObj = {};
              inaObj.msgContent = targetingMsgJson.msgContent;
              inaObj.msgId = targetingMsgJson.wzrk_id;
              if (targetingMsgJson.wzrk_pivot) {
                inaObj.pivotId = targetingMsgJson.wzrk_pivot;
              }
              var msgCTkv = [];
              for (var wzrkPrefixKey in targetingMsgJson) {
                if (wzrkPrefixKey.startsWith(WZRK_PREFIX) && wzrkPrefixKey !== WZRK_ID) {
                  const wzrkJson = {
                    [wzrkPrefixKey]: targetingMsgJson[wzrkPrefixKey]
                  };
                  msgCTkv.push(wzrkJson);
                }
              }
              if (msgCTkv.length > 0) {
                inaObj.msgCTkv = msgCTkv;
              }
              if (targetingMsgJson.display.kv != null) {
                inaObj.kv = targetingMsgJson.display.kv;
              }
              window.clevertap.raisePopupNotificationClicked = (notificationData) => {
                if (!notificationData || !notificationData.msgId) {
                  return;
                }
                const eventData = {};
                eventData.type = "event";
                eventData.evtName = NOTIFICATION_CLICKED;
                eventData.evtData = {
                  [WZRK_ID]: notificationData.msgId
                };
                if (targetingMsgJson.wzrk_pivot) {
                  eventData.evtData = {
                    ...eventData.evtData,
                    wzrk_pivot: notificationData.pivotId
                  };
                }
                if (notificationData.msgCTkv) {
                  for (var wzrkPrefixObj of notificationData.msgCTkv) {
                    eventData.evtData = {
                      ...eventData.evtData,
                      ...wzrkPrefixObj
                    };
                  }
                }
                _request2.processEvent(eventData);
              };
              popupCallback(inaObj);
            }
          }
        };
        const triggerByInactivity = (targetNotif) => {
          const IDLE_TIME_THRESHOLD = targetNotif.display.deliveryTrigger.inactive * 1e3;
          let idleTimer;
          const events = ["mousemove", "keypress", "scroll", "mousedown", "touchmove", "click"];
          const resetIdleTimer = () => {
            clearTimeout(idleTimer);
            idleTimer = setTimeout(() => {
              renderFooterNotification(targetNotif);
              removeEventListeners();
            }, IDLE_TIME_THRESHOLD);
          };
          const eventHandler = () => {
            resetIdleTimer();
          };
          const setupEventListeners = () => {
            events.forEach((eventType) => window.addEventListener(eventType, eventHandler, {
              passive: true
            }));
          };
          const removeEventListeners = () => {
            events.forEach((eventType) => window.removeEventListener(eventType, eventHandler));
          };
          setupEventListeners();
          resetIdleTimer();
          return removeEventListeners;
        };
        const triggerByScroll = (targetNotif) => {
          const calculateScrollPercentage = () => {
            const {
              scrollHeight,
              clientHeight,
              scrollTop
            } = document.documentElement;
            return scrollTop / (scrollHeight - clientHeight) * 100;
          };
          const scrollListener = () => {
            const scrollPercentage = calculateScrollPercentage();
            if (scrollPercentage >= targetNotif.display.deliveryTrigger.scroll) {
              renderFooterNotification(targetNotif);
              window.removeEventListener("scroll", throttledScrollListener);
            }
          };
          const throttle = (func, limit) => {
            let inThrottle = false;
            return function() {
              const context = this;
              if (!inThrottle) {
                for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => {
                  inThrottle = false;
                }, limit);
              }
            };
          };
          const throttledScrollListener = throttle(scrollListener, 200);
          window.addEventListener("scroll", throttledScrollListener, {
            passive: true
          });
          return () => window.removeEventListener("scroll", throttledScrollListener);
        };
        let exitintentObj;
        const showExitIntent = (event, targetObj) => {
          if ((event === null || event === void 0 ? void 0 : event.clientY) > 0) return;
          const targetingMsgJson = targetObj || exitintentObj;
          const campaignId = targetingMsgJson.wzrk_id.split("_")[0];
          const layout = targetingMsgJson.display.layout;
          if (isExistingCampaign(campaignId)) return;
          if (targetingMsgJson.display.wtarget_type === 0 && (layout === 0 || layout === 2 || layout === 3)) {
            createTemplate(targetingMsgJson, true);
            return;
          }
          if (doCampHouseKeeping(targetingMsgJson) === false) {
            return;
          }
          if ($ct.dismissSpamControl && targetingMsgJson.display.wtarget_type === 0) {
            const intentPreview = document.getElementById("intentPreview");
            const intentOpacityDiv = document.getElementById("intentOpacityDiv");
            if (intentPreview && intentOpacityDiv) {
              intentPreview.remove();
              intentOpacityDiv.remove();
            }
          }
          if (document.getElementById("intentPreview") != null || document.getElementById("wzrkImageOnlyDiv") != null) {
            return;
          }
          if (targetingMsgJson.display.layout == null && (/mobile/i.test(navigator.userAgent) || /mini/i.test(navigator.userAgent) || /iPad/i.test(navigator.userAgent) || "ontouchstart" in window || /tablet/i.test(navigator.userAgent))) {
            return;
          }
          $ct.campaignDivMap[campaignId] = "intentPreview";
          let legacy = false;
          const opacityDiv = document.createElement("div");
          opacityDiv.id = "intentOpacityDiv";
          const opacity = targetingMsgJson.display.opacity || 0.7;
          const rgbaColor = "rgba(0,0,0,".concat(opacity, ")");
          opacityDiv.setAttribute("style", "position: fixed;top: 0;bottom: 0;left: 0;width: 100%;height: 100%;z-index: 2147483646;background: ".concat(rgbaColor, ";"));
          document.body.appendChild(opacityDiv);
          const msgDiv = document.createElement("div");
          msgDiv.id = "intentPreview";
          if (targetingMsgJson.display.proto == null) {
            legacy = true;
            msgDiv.setAttribute("style", "display:block;overflow:hidden;top:55% !important;left:50% !important;position:fixed;z-index:2147483647;width:600px !important;height:600px !important;margin:-300px 0 0 -300px !important;");
          } else {
            msgDiv.setAttribute("style", targetingMsgJson.display.iFrameStyle);
          }
          document.body.appendChild(msgDiv);
          const iframe = document.createElement("iframe");
          const borderRadius = targetingMsgJson.display.br === false ? "0" : "8";
          iframe.frameborder = "0px";
          iframe.marginheight = "0px";
          iframe.marginwidth = "0px";
          iframe.scrolling = "no";
          iframe.id = "wiz-iframe-intent";
          const onClick = targetingMsgJson.display.onClick;
          let pointerCss = "";
          if (onClick !== "" && onClick != null) {
            pointerCss = "cursor:pointer;";
          }
          if (targetingMsgJson.display.preview && targetingMsgJson.display["custom-editor"]) {
            iframe.sandbox = "allow-scripts allow-popups allow-popups-to-escape-sandbox";
          }
          let html;
          if (targetingMsgJson.msgContent.type === 1) {
            html = targetingMsgJson.msgContent.html;
            html = html.replace(/##campaignId##/g, campaignId);
            html = html.replace(/##campaignId_batchId##/g, targetingMsgJson.wzrk_id);
          } else {
            const css = '<style type="text/css">body{margin:0;padding:0;}#contentDiv.wzrk{overflow:hidden;padding:0 0 20px 0;text-align:center;' + pointerCss + "}#contentDiv.wzrk td{padding:15px 10px;}.wzrkPPtitle{font-weight: bold;font-size: 24px;font-family:arial;word-break: break-word;padding-top:20px;}.wzrkPPdscr{font-size: 14px;font-family:arial;line-height:16px;word-break: break-word;display:inline-block;padding:20px 20px 0 20px;line-height:20px;}.PL15{padding-left:15px;}.wzrkPPwarp{margin:20px 20px 0 5px;padding:0px;border-radius: " + borderRadius + "px;box-shadow: 1px 1px 5px #888888;}a.wzrkClose{cursor:pointer;position: absolute;top: 11px;right: 11px;z-index: 2147483647;font-size:19px;font-family:arial;font-weight:bold;text-decoration: none;width: 25px;/*height: 25px;*/text-align: center; -webkit-appearance: none; line-height: 25px;background: #353535;border: #fff 2px solid;border-radius: 100%;box-shadow: #777 2px 2px 2px;color:#fff;}a:hover.wzrkClose{background-color:#d1914a !important;color:#fff !important; -webkit-appearance: none;}#contentDiv .button{padding-top:20px;}#contentDiv .button a{font-size: 14px;font-weight:bold;font-family:arial;text-align:center;display:inline-block;text-decoration:none;padding:0 30px;height:40px;line-height:40px;background:#ea693b;color:#fff;border-radius:4px;-webkit-border-radius:4px;-moz-border-radius:4px;}</style>";
            let bgColor, textColor, btnBg, btColor;
            if (targetingMsgJson.display.theme === "dark") {
              bgColor = "#2d2d2e";
              textColor = "#eaeaea";
              btnBg = "#353535";
              btColor = "#ffffff";
            } else {
              bgColor = "#ffffff";
              textColor = "#000000";
              btnBg = "#a5a6a6";
              btColor = "#ffffff";
            }
            const titleText = targetingMsgJson.msgContent.title;
            const descriptionText = targetingMsgJson.msgContent.description;
            let ctaText = "";
            if (targetingMsgJson.msgContent.ctaText != null && targetingMsgJson.msgContent.ctaText !== "") {
              ctaText = "<div class='button'><a href='#'>" + targetingMsgJson.msgContent.ctaText + "</a></div>";
            }
            let imageTd = "";
            if (targetingMsgJson.msgContent.imageUrl != null && targetingMsgJson.msgContent.imageUrl !== "") {
              imageTd = "<div style='padding-top:20px;'><img src='" + targetingMsgJson.msgContent.imageUrl + "' width='500' alt=" + titleText + " /></div>";
            }
            const onClickStr = "parent.$WZRK_WR.closeIframe(" + campaignId + ",'intentPreview');";
            const title = "<div class='wzrkPPwarp' style='color:" + textColor + ";background-color:" + bgColor + ";'><a href='javascript:void(0);' onclick=" + onClickStr + " class='wzrkClose' style='background-color:" + btnBg + ";color:" + btColor + "'>&times;</a><div id='contentDiv' class='wzrk'><div class='wzrkPPtitle' style='color:" + textColor + "'>" + titleText + "</div>";
            const body = "<div class='wzrkPPdscr' style='color:" + textColor + "'>" + descriptionText + "</div>" + imageTd + ctaText + "</div></div>";
            html = css + title + body;
          }
          iframe.setAttribute("style", "color-scheme: none; z-index: 2147483647; display:block; height: 100% !important; width: 100% !important;min-height:80px !important;border:0px !important; border-color:none !important;");
          msgDiv.appendChild(iframe);
          const closeCampaign = new Event("CT_campaign_rendered");
          document.dispatchEvent(closeCampaign);
          if (targetingMsgJson.display["custom-editor"]) {
            html = appendScriptForCustomEvent(targetingMsgJson, html);
          }
          iframe.srcdoc = html;
          iframe.onload = () => {
            const contentDiv = document.getElementById("wiz-iframe-intent").contentDocument.getElementById("contentDiv");
            setupClickUrl(onClick, targetingMsgJson, contentDiv, "intentPreview", legacy);
          };
        };
        if (!document.body) {
          if (_wizCounter < 6) {
            _wizCounter++;
            setTimeout(_tr, 1e3, msg, {
              device: _device2,
              session: _session2,
              request: _request2,
              logger: _logger2
            });
          }
          return;
        }
        const processNativeDisplayArr = (arrInAppNotifs) => {
          Object.keys(arrInAppNotifs).map((key) => {
            var elementId, id2;
            if (arrInAppNotifs[key].display.divId) {
              elementId = arrInAppNotifs[key].display.divId;
              id2 = document.getElementById(elementId);
            } else {
              elementId = arrInAppNotifs[key].display.divSelector;
              id2 = document.querySelector(elementId);
            }
            if (id2 !== null) {
              arrInAppNotifs[key].msgContent.type === 2 ? renderPersonalisationBanner(arrInAppNotifs[key]) : renderPersonalisationCarousel(arrInAppNotifs[key]);
              delete arrInAppNotifs[key];
            }
          });
        };
        const addLoadListener = (arrInAppNotifs) => {
          window.addEventListener("load", () => {
            let count = 0;
            if (count < 20) {
              const t = setInterval(() => {
                processNativeDisplayArr(arrInAppNotifs);
                if (Object.keys(arrInAppNotifs).length === 0 || count === 20) {
                  clearInterval(t);
                  arrInAppNotifs = {};
                }
                count++;
              }, 500);
            }
          });
        };
        if (msg.inapp_notifs != null) {
          const arrInAppNotifs = {};
          const sortedCampaigns = webNativeDisplayCampaignUtils.sortCampaignsByPriority(msg.inapp_notifs);
          const executedTargets = {
            nodes: [],
            customEvents: []
          };
          for (let index = 0; index < sortedCampaigns.length; index++) {
            var _msg$arp;
            addCampaignToLocalStorage(sortedCampaigns[index], _region2, msg === null || msg === void 0 ? void 0 : (_msg$arp = msg.arp) === null || _msg$arp === void 0 ? void 0 : _msg$arp.id);
            const targetNotif = sortedCampaigns[index];
            if (targetNotif.display.wtarget_type === CAMPAIGN_TYPES.FOOTER_NOTIFICATION || targetNotif.display.wtarget_type === CAMPAIGN_TYPES.FOOTER_NOTIFICATION_2) {
              showFooterNotification(targetNotif);
            } else if (targetNotif.display.wtarget_type === CAMPAIGN_TYPES.EXIT_INTENT) {
              exitintentObj = targetNotif;
              window.document.body.onmouseleave = showExitIntent;
            } else if (targetNotif.display.wtarget_type === CAMPAIGN_TYPES.WEB_NATIVE_DISPLAY) {
              if (webNativeDisplayCampaignUtils.doesCampaignPushCustomEvent(targetNotif) && executedTargets.customEvents.length > 0 && webNativeDisplayCampaignUtils.shouldCurrentCustomEventCampaignBeSkipped(targetNotif, executedTargets)) {
                _logger2.debug("Custom Event Campaign Skipped with id :: " + (targetNotif === null || targetNotif === void 0 ? void 0 : targetNotif.wzrk_id));
                continue;
              }
              if (webNativeDisplayCampaignUtils.doesCampaignMutateDOMNode(targetNotif) && executedTargets.nodes.some((node) => {
                var _webNativeDisplayCamp;
                return (_webNativeDisplayCamp = webNativeDisplayCampaignUtils.getCampaignNodes(targetNotif)) === null || _webNativeDisplayCamp === void 0 ? void 0 : _webNativeDisplayCamp.includes(node);
              })) {
                _logger2.debug("DOM Campaign Skipped with id :: " + (targetNotif === null || targetNotif === void 0 ? void 0 : targetNotif.wzrk_id));
                continue;
              }
              if (webNativeDisplayCampaignUtils.doesCampaignPushCustomEvent(targetNotif)) {
                const eventTopic = targetNotif.msgContent.type === WEB_NATIVE_TEMPLATES.KV_PAIR ? targetNotif.display.kv.topic : null;
                executedTargets.customEvents.push({
                  customEventType: targetNotif.msgContent.type,
                  eventTopic
                });
              } else if (webNativeDisplayCampaignUtils.doesCampaignMutateDOMNode(targetNotif)) {
                const nodes = webNativeDisplayCampaignUtils.getCampaignNodes(targetNotif);
                executedTargets.nodes.push(...nodes);
              }
              if (targetNotif.msgContent.type === WEB_NATIVE_TEMPLATES.KV_PAIR) {
                handleKVpairCampaign(targetNotif);
              } else if (targetNotif.msgContent.type === WEB_NATIVE_TEMPLATES.BANNER || targetNotif.msgContent.type === WEB_NATIVE_TEMPLATES.CAROUSEL) {
                const element = targetNotif.display.divId ? document.getElementById(targetNotif.display.divId) : document.querySelector(targetNotif.display.divSelector);
                if (element !== null) {
                  targetNotif.msgContent.type === WEB_NATIVE_TEMPLATES.BANNER ? renderPersonalisationBanner(targetNotif) : renderPersonalisationCarousel(targetNotif);
                } else {
                  arrInAppNotifs[targetNotif.wzrk_id.split("_")[0]] = targetNotif;
                }
              } else if (targetNotif.msgContent.type === WEB_NATIVE_TEMPLATES.VISUAL_BUILDER) {
                renderVisualBuilder(targetNotif, false, _logger2);
              } else if (targetNotif.msgContent.type === WEB_NATIVE_TEMPLATES.CUSTOM_HTML) {
                renderCustomHtml(targetNotif, _logger2);
              } else if (targetNotif.msgContent.type === WEB_NATIVE_TEMPLATES.JSON) {
                handleJson(targetNotif);
              } else {
                showFooterNotification(targetNotif);
              }
            }
          }
          if (Object.keys(arrInAppNotifs).length) {
            if (document.readyState === "complete") {
              processNativeDisplayArr(arrInAppNotifs);
            } else {
              addLoadListener(arrInAppNotifs);
            }
          }
        }
        const handleInboxNotifications = () => {
          if (msg.inbox_preview) {
            processInboxNotifs(msg);
            return;
          }
          if (msg.inbox_notifs) {
            const msgArr = [];
            for (let index = 0; index < msg.inbox_notifs.length; index++) {
              var _msg$arp2;
              addCampaignToLocalStorage(msg.inbox_notifs[index], _region2, msg === null || msg === void 0 ? void 0 : (_msg$arp2 = msg.arp) === null || _msg$arp2 === void 0 ? void 0 : _msg$arp2.id);
              if (doCampHouseKeeping(msg.inbox_notifs[index]) !== false) {
                msgArr.push(msg.inbox_notifs[index]);
              }
            }
            processInboxNotifs(msgArr);
          }
        };
        if (msg.webInboxSetting || msg.inbox_notifs != null) {
          if (hasWebInboxSettingsInLS()) {
            checkAndRegisterWebInboxElements();
          }
          if ($ct.inbox === null) {
            msg.webInboxSetting && processWebInboxSettings(msg.webInboxSetting);
            initializeWebInbox(_logger2).then(() => {
              handleInboxNotifications();
            }).catch((e) => {
            });
          } else {
            handleInboxNotifications();
          }
        }
        if (msg.webPushConfig) {
          processWebPushConfig(msg.webPushConfig, logger2, request2);
        }
        if (msg.vars) {
          $ct.variableStore.mergeVariables(msg.vars);
          return;
        }
        if (StorageManager._isLocalStorageSupported()) {
          try {
            if (msg.evpr != null) {
              const eventsMap = msg.evpr.events;
              const profileMap = msg.evpr.profile;
              const syncExpiry = msg.evpr.expires_in;
              const now = getNow();
              StorageManager.setMetaProp("lsTime", now);
              StorageManager.setMetaProp("exTs", syncExpiry);
              mergeEventMap(eventsMap);
              StorageManager.saveToLSorCookie(EV_COOKIE, $ct.globalEventsMap);
              if ($ct.globalProfileMap == null) {
                addToLocalProfileMap(profileMap, true);
              } else {
                addToLocalProfileMap(profileMap, false);
              }
            }
            if (msg.arp != null) {
              arp(msg.arp);
            }
            if (msg.inapp_stale != null && msg.inapp_stale.length > 0) {
              staleDataUpdate(msg.inapp_stale, "wp");
            }
            if (msg.inbox_stale != null && msg.inbox_stale.length > 0) {
              staleDataUpdate(msg.inbox_stale, "wi");
            }
          } catch (e) {
            _logger2.error("Unable to persist evrp/arp: " + e);
          }
        }
      };
      var _isPersonalisationActive$2 = _classPrivateFieldLooseKey("isPersonalisationActive");
      class User {
        constructor(_ref) {
          let {
            isPersonalisationActive
          } = _ref;
          Object.defineProperty(this, _isPersonalisationActive$2, {
            writable: true,
            value: void 0
          });
          _classPrivateFieldLooseBase(this, _isPersonalisationActive$2)[_isPersonalisationActive$2] = isPersonalisationActive;
        }
        getTotalVisits() {
          if (!_classPrivateFieldLooseBase(this, _isPersonalisationActive$2)[_isPersonalisationActive$2]()) {
            return;
          }
          let visitCount = StorageManager.getMetaProp("sc");
          if (visitCount == null) {
            visitCount = 1;
          }
          return visitCount;
        }
        getLastVisit() {
          if (!_classPrivateFieldLooseBase(this, _isPersonalisationActive$2)[_isPersonalisationActive$2]()) {
            return;
          }
          const prevSession = StorageManager.getMetaProp("ps");
          if (prevSession != null) {
            return new Date(prevSession * 1e3);
          }
        }
      }
      const logLevels = {
        DISABLE: 0,
        ERROR: 1,
        INFO: 2,
        DEBUG: 3,
        DEBUG_PE: 4
      };
      var _logLevel = _classPrivateFieldLooseKey("logLevel");
      var _log = _classPrivateFieldLooseKey("log");
      var _isLegacyDebug = _classPrivateFieldLooseKey("isLegacyDebug");
      class Logger {
        constructor(logLevel) {
          Object.defineProperty(this, _isLegacyDebug, {
            get: _get_isLegacyDebug,
            set: void 0
          });
          Object.defineProperty(this, _log, {
            value: _log2
          });
          Object.defineProperty(this, _logLevel, {
            writable: true,
            value: void 0
          });
          this.wzrkError = {};
          _classPrivateFieldLooseBase(this, _logLevel)[_logLevel] = logLevel == null ? logLevel : logLevels.INFO;
          this.wzrkError = {};
        }
        get logLevel() {
          return _classPrivateFieldLooseBase(this, _logLevel)[_logLevel];
        }
        set logLevel(logLevel) {
          _classPrivateFieldLooseBase(this, _logLevel)[_logLevel] = logLevel;
        }
        error(message) {
          if (_classPrivateFieldLooseBase(this, _logLevel)[_logLevel] >= logLevels.ERROR) {
            _classPrivateFieldLooseBase(this, _log)[_log]("error", message);
          }
        }
        info(message) {
          if (_classPrivateFieldLooseBase(this, _logLevel)[_logLevel] >= logLevels.INFO) {
            _classPrivateFieldLooseBase(this, _log)[_log]("log", message);
          }
        }
        debug(message) {
          if (_classPrivateFieldLooseBase(this, _logLevel)[_logLevel] >= logLevels.DEBUG || _classPrivateFieldLooseBase(this, _isLegacyDebug)[_isLegacyDebug]) {
            _classPrivateFieldLooseBase(this, _log)[_log]("debug", message);
          }
        }
        debugPE(message) {
          if (_classPrivateFieldLooseBase(this, _logLevel)[_logLevel] >= logLevels.DEBUG_PE) {
            _classPrivateFieldLooseBase(this, _log)[_log]("debug_pe", message);
          }
        }
        reportError(code, description) {
          this.wzrkError.c = code;
          this.wzrkError.d = description;
          this.error("".concat(CLEVERTAP_ERROR_PREFIX, " ").concat(code, ": ").concat(description));
        }
      }
      var _log2 = function _log22(level, message) {
        if (window.console) {
          try {
            const ts = (/* @__PURE__ */ new Date()).getTime();
            console[level]("CleverTap [".concat(ts, "]: ").concat(message));
          } catch (e) {
          }
        }
      };
      var _get_isLegacyDebug = function() {
        return typeof sessionStorage !== "undefined" && sessionStorage.WZRK_D === "";
      };
      var _logger$4 = _classPrivateFieldLooseKey("logger");
      var _sessionId = _classPrivateFieldLooseKey("sessionId");
      var _isPersonalisationActive$1 = _classPrivateFieldLooseKey("isPersonalisationActive");
      class SessionManager {
        // SCOOKIE_NAME
        constructor(_ref) {
          let {
            logger: logger2,
            isPersonalisationActive
          } = _ref;
          Object.defineProperty(this, _logger$4, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _sessionId, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _isPersonalisationActive$1, {
            writable: true,
            value: void 0
          });
          this.cookieName = void 0;
          this.scookieObj = void 0;
          this.sessionId = StorageManager.getMetaProp("cs");
          _classPrivateFieldLooseBase(this, _logger$4)[_logger$4] = logger2;
          _classPrivateFieldLooseBase(this, _isPersonalisationActive$1)[_isPersonalisationActive$1] = isPersonalisationActive;
        }
        get sessionId() {
          return _classPrivateFieldLooseBase(this, _sessionId)[_sessionId];
        }
        set sessionId(sessionId) {
          _classPrivateFieldLooseBase(this, _sessionId)[_sessionId] = sessionId;
        }
        getSessionCookieObject() {
          let scookieStr = StorageManager.readCookie(this.cookieName);
          let obj = {};
          if (scookieStr != null) {
            scookieStr = scookieStr.replace(singleQuoteRegex, '"');
            obj = JSON.parse(scookieStr);
            if (!isObject(obj)) {
              obj = {};
            } else {
              if (typeof obj.t !== "undefined") {
                const lastTime = obj.t;
                const now = getNow();
                if (now - lastTime > SCOOKIE_EXP_TIME_IN_SECS + 60) {
                  obj = {};
                }
              }
            }
          }
          this.scookieObj = obj;
          return obj;
        }
        setSessionCookieObject(obj) {
          const objStr = JSON.stringify(obj);
          StorageManager.createBroadCookie(this.cookieName, objStr, SCOOKIE_EXP_TIME_IN_SECS, getHostName());
        }
        manageSession(session) {
          if (typeof this.sessionId === "undefined" || this.sessionId !== session) {
            const currentSessionInLS = StorageManager.getMetaProp("cs");
            if (typeof currentSessionInLS === "undefined") {
              StorageManager.setMetaProp("ps", session);
              StorageManager.setMetaProp("cs", session);
              StorageManager.setMetaProp("sc", 1);
            } else if (currentSessionInLS !== session) {
              StorageManager.setMetaProp("ps", currentSessionInLS);
              StorageManager.setMetaProp("cs", session);
              let sessionCount = StorageManager.getMetaProp("sc");
              if (typeof sessionCount === "undefined") {
                sessionCount = 0;
              }
              StorageManager.setMetaProp("sc", sessionCount + 1);
            }
            this.sessionId = session;
          }
        }
        getTimeElapsed() {
          if (!_classPrivateFieldLooseBase(this, _isPersonalisationActive$1)[_isPersonalisationActive$1]()) {
            return;
          }
          if (this.scookieObj != null) {
            this.scookieObj = this.getSessionCookieObject();
          }
          const sessionStart = this.scookieObj.s;
          if (sessionStart != null) {
            const ts = getNow();
            return Math.floor(ts - sessionStart);
          }
        }
        getPageCount() {
          if (!_classPrivateFieldLooseBase(this, _isPersonalisationActive$1)[_isPersonalisationActive$1]()) {
            return;
          }
          if (this.scookieObj != null) {
            this.scookieObj = this.getSessionCookieObject();
          }
          return this.scookieObj.p;
        }
      }
      let seqNo = 0;
      let requestTime = 0;
      var _logger$3 = _classPrivateFieldLooseKey("logger");
      var _account$3 = _classPrivateFieldLooseKey("account");
      var _device$1 = _classPrivateFieldLooseKey("device");
      var _session$1 = _classPrivateFieldLooseKey("session");
      var _isPersonalisationActive = _classPrivateFieldLooseKey("isPersonalisationActive");
      var _clearCookie = _classPrivateFieldLooseKey("clearCookie");
      var _addToLocalEventMap = _classPrivateFieldLooseKey("addToLocalEventMap");
      class RequestManager {
        constructor(_ref) {
          let {
            logger: logger2,
            account: account2,
            device,
            session,
            isPersonalisationActive
          } = _ref;
          Object.defineProperty(this, _addToLocalEventMap, {
            value: _addToLocalEventMap2
          });
          Object.defineProperty(this, _logger$3, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _account$3, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _device$1, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _session$1, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _isPersonalisationActive, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _clearCookie, {
            writable: true,
            value: false
          });
          this.processingBackup = false;
          _classPrivateFieldLooseBase(this, _logger$3)[_logger$3] = logger2;
          _classPrivateFieldLooseBase(this, _account$3)[_account$3] = account2;
          _classPrivateFieldLooseBase(this, _device$1)[_device$1] = device;
          _classPrivateFieldLooseBase(this, _session$1)[_session$1] = session;
          _classPrivateFieldLooseBase(this, _isPersonalisationActive)[_isPersonalisationActive] = isPersonalisationActive;
          RequestDispatcher.logger = logger2;
          RequestDispatcher.device = device;
          RequestDispatcher.account = account2;
        }
        processBackupEvents() {
          const backupMap = StorageManager.readFromLSorCookie(LCOOKIE_NAME);
          if (typeof backupMap === "undefined" || backupMap === null) {
            return;
          }
          this.processingBackup = true;
          for (const idx in backupMap) {
            if (backupMap.hasOwnProperty(idx)) {
              const backupEvent = backupMap[idx];
              if (typeof backupEvent.fired === "undefined") {
                _classPrivateFieldLooseBase(this, _logger$3)[_logger$3].debug("Processing backup event : " + backupEvent.q);
                if (typeof backupEvent.q !== "undefined") {
                  const session = JSON.parse(StorageManager.readCookie(SCOOKIE_PREFIX + "_" + _classPrivateFieldLooseBase(this, _account$3)[_account$3].id));
                  if (session === null || session === void 0 ? void 0 : session.s) {
                    backupEvent.q = backupEvent.q + "&s=" + session.s;
                  }
                  RequestDispatcher.fireRequest(backupEvent.q);
                }
                backupEvent.fired = true;
              }
            }
          }
          StorageManager.saveToLSorCookie(LCOOKIE_NAME, backupMap);
          this.processingBackup = false;
        }
        addSystemDataToObject(dataObject, ignoreTrim) {
          if (typeof ignoreTrim === "undefined") {
            dataObject = removeUnsupportedChars(dataObject, _classPrivateFieldLooseBase(this, _logger$3)[_logger$3]);
          }
          if (!isObjectEmpty(_classPrivateFieldLooseBase(this, _logger$3)[_logger$3].wzrkError)) {
            dataObject.wzrk_error = _classPrivateFieldLooseBase(this, _logger$3)[_logger$3].wzrkError;
            _classPrivateFieldLooseBase(this, _logger$3)[_logger$3].wzrkError = {};
          }
          dataObject.id = _classPrivateFieldLooseBase(this, _account$3)[_account$3].id;
          if (isValueValid(_classPrivateFieldLooseBase(this, _device$1)[_device$1].gcookie)) {
            dataObject.g = _classPrivateFieldLooseBase(this, _device$1)[_device$1].gcookie;
          }
          const obj = _classPrivateFieldLooseBase(this, _session$1)[_session$1].getSessionCookieObject();
          dataObject.s = obj.s;
          dataObject.pg = typeof obj.p === "undefined" ? 1 : obj.p;
          let proto = document.location.protocol;
          proto = proto.replace(":", "");
          dataObject.af = {
            ...dataObject.af,
            lib: "web-sdk-v1.15.3",
            protocol: proto,
            ...$ct.flutterVersion
          };
          try {
            if (sessionStorage.hasOwnProperty("WZRK_D") || sessionStorage.getItem("WZRK_D")) {
              dataObject.debug = true;
            }
          } catch (e) {
            _classPrivateFieldLooseBase(this, _logger$3)[_logger$3].debug("Error in reading WZRK_D from session storage");
          }
          return dataObject;
        }
        addFlags(data) {
          _classPrivateFieldLooseBase(this, _clearCookie)[_clearCookie] = StorageManager.getAndClearMetaProp(CLEAR);
          if (_classPrivateFieldLooseBase(this, _clearCookie)[_clearCookie] !== void 0 && _classPrivateFieldLooseBase(this, _clearCookie)[_clearCookie]) {
            data.rc = true;
            _classPrivateFieldLooseBase(this, _logger$3)[_logger$3].debug("reset cookie sent in request and cleared from meta for future requests.");
          }
          if (_classPrivateFieldLooseBase(this, _isPersonalisationActive)[_isPersonalisationActive]()) {
            const lastSyncTime = StorageManager.getMetaProp("lsTime");
            const expirySeconds = StorageManager.getMetaProp("exTs");
            if (typeof lastSyncTime === "undefined" || typeof expirySeconds === "undefined") {
              data.dsync = true;
              return;
            }
            const now = getNow();
            if (lastSyncTime + expirySeconds < now) {
              data.dsync = true;
            }
          }
        }
        // saves url to backup cache and fires the request
        /**
         *
         * @param {string} url
         * @param {boolean} override whether the request can go through or not
         * @param {Boolean} sendOULFlag - true in case of a On User Login request
         */
        saveAndFireRequest(url, override, sendOULFlag, evtName) {
          const now = getNow();
          url = addToURL(url, "rn", ++$ct.globalCache.REQ_N);
          const data = url + "&i=" + now + "&sn=" + seqNo;
          StorageManager.backupEvent(data, $ct.globalCache.REQ_N, _classPrivateFieldLooseBase(this, _logger$3)[_logger$3]);
          if ($ct.offline) return;
          if ((!override || _classPrivateFieldLooseBase(this, _clearCookie)[_clearCookie] !== void 0 && _classPrivateFieldLooseBase(this, _clearCookie)[_clearCookie]) && !window.isOULInProgress) {
            if (now === requestTime) {
              seqNo++;
            } else {
              requestTime = now;
              seqNo = 0;
            }
            window.oulReqN = $ct.globalCache.REQ_N;
            RequestDispatcher.fireRequest(data, false, sendOULFlag, evtName);
          } else {
            _classPrivateFieldLooseBase(this, _logger$3)[_logger$3].debug("Not fired due to override - ".concat($ct.blockRequest, " or clearCookie - ").concat(_classPrivateFieldLooseBase(this, _clearCookie)[_clearCookie], " or OUL request in progress - ").concat(window.isOULInProgress));
          }
        }
        unregisterTokenForGuid(givenGUID) {
          const payload = StorageManager.readFromLSorCookie(PUSH_SUBSCRIPTION_DATA);
          if (payload) {
            const data = {};
            data.type = "data";
            if (isValueValid(givenGUID)) {
              data.g = givenGUID;
            }
            data.action = "unregister";
            data.id = _classPrivateFieldLooseBase(this, _account$3)[_account$3].id;
            const obj = _classPrivateFieldLooseBase(this, _session$1)[_session$1].getSessionCookieObject();
            data.s = obj.s;
            const compressedData = compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger$3)[_logger$3]);
            let pageLoadUrl = _classPrivateFieldLooseBase(this, _account$3)[_account$3].dataPostURL;
            pageLoadUrl = addToURL(pageLoadUrl, "type", "data");
            pageLoadUrl = addToURL(pageLoadUrl, "d", compressedData);
            RequestDispatcher.fireRequest(pageLoadUrl, true);
            StorageManager.saveToLSorCookie(FIRE_PUSH_UNREGISTERED, false);
          }
          this.registerToken(payload);
        }
        registerToken(payload) {
          if (!payload) return;
          payload = this.addSystemDataToObject(payload, true);
          payload = JSON.stringify(payload);
          let pageLoadUrl = _classPrivateFieldLooseBase(this, _account$3)[_account$3].dataPostURL;
          pageLoadUrl = addToURL(pageLoadUrl, "type", "data");
          pageLoadUrl = addToURL(pageLoadUrl, "d", compressData(payload, _classPrivateFieldLooseBase(this, _logger$3)[_logger$3]));
          RequestDispatcher.fireRequest(pageLoadUrl);
          StorageManager.save(WEBPUSH_LS_KEY, "ok");
        }
        processEvent(data) {
          _classPrivateFieldLooseBase(this, _addToLocalEventMap)[_addToLocalEventMap](data.evtName);
          data = this.addSystemDataToObject(data, void 0);
          this.addFlags(data);
          data[CAMP_COOKIE_NAME] = getCampaignObjForLc();
          const compressedData = compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger$3)[_logger$3]);
          let pageLoadUrl = _classPrivateFieldLooseBase(this, _account$3)[_account$3].dataPostURL;
          pageLoadUrl = addToURL(pageLoadUrl, "type", EVT_PUSH);
          pageLoadUrl = addToURL(pageLoadUrl, "d", compressedData);
          this.saveAndFireRequest(pageLoadUrl, $ct.blockRequest, false, data.evtName);
        }
        post(url, body) {
          return fetch(url, {
            method: "post",
            headers: {
              "Content-Type": "application/json"
            },
            body
          }).then((response) => {
            if (response.ok) {
              return response.json();
            }
            throw response;
          }).then((data) => {
            _classPrivateFieldLooseBase(this, _logger$3)[_logger$3].debug("Sync data successful", data);
            return data;
          }).catch((e) => {
            _classPrivateFieldLooseBase(this, _logger$3)[_logger$3].debug("Error in syncing variables", e);
            throw e;
          });
        }
      }
      var _addToLocalEventMap2 = function _addToLocalEventMap22(evtName) {
        if (StorageManager._isLocalStorageSupported()) {
          if (typeof $ct.globalEventsMap === "undefined") {
            $ct.globalEventsMap = StorageManager.readFromLSorCookie(EV_COOKIE);
            if (typeof $ct.globalEventsMap === "undefined") {
              $ct.globalEventsMap = {};
            }
          }
          const nowTs = getNow();
          let evtDetail = $ct.globalEventsMap[evtName];
          if (typeof evtDetail !== "undefined") {
            evtDetail[2] = nowTs;
            evtDetail[0]++;
          } else {
            evtDetail = [];
            evtDetail.push(1);
            evtDetail.push(nowTs);
            evtDetail.push(nowTs);
          }
          $ct.globalEventsMap[evtName] = evtDetail;
          StorageManager.saveToLSorCookie(EV_COOKIE, $ct.globalEventsMap);
        }
      };
      var _request$2 = _classPrivateFieldLooseKey("request");
      var _account$2 = _classPrivateFieldLooseKey("account");
      var _oldValues = _classPrivateFieldLooseKey("oldValues");
      var _logger$2 = _classPrivateFieldLooseKey("logger");
      var _processPrivacyArray = _classPrivateFieldLooseKey("processPrivacyArray");
      class Privacy extends Array {
        constructor(_ref, values) {
          let {
            request: request2,
            account: account2,
            logger: logger2
          } = _ref;
          super();
          Object.defineProperty(this, _processPrivacyArray, {
            value: _processPrivacyArray2
          });
          Object.defineProperty(this, _request$2, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _account$2, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _oldValues, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _logger$2, {
            writable: true,
            value: void 0
          });
          _classPrivateFieldLooseBase(this, _logger$2)[_logger$2] = logger2;
          _classPrivateFieldLooseBase(this, _request$2)[_request$2] = request2;
          _classPrivateFieldLooseBase(this, _account$2)[_account$2] = account2;
          _classPrivateFieldLooseBase(this, _oldValues)[_oldValues] = values;
        }
        // TODO : Do we need to check if account id is set or not here?
        push() {
          for (var _len = arguments.length, privacyArr = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            privacyArr[_key2] = arguments[_key2];
          }
          if ($ct.isPrivacyArrPushed) {
            _classPrivateFieldLooseBase(this, _processPrivacyArray)[_processPrivacyArray]($ct.privacyArray.length > 0 ? $ct.privacyArray : privacyArr);
          } else {
            $ct.privacyArray.push(...privacyArr);
          }
          return 0;
        }
        _processOldValues() {
          if (_classPrivateFieldLooseBase(this, _oldValues)[_oldValues]) {
            _classPrivateFieldLooseBase(this, _processPrivacyArray)[_processPrivacyArray](_classPrivateFieldLooseBase(this, _oldValues)[_oldValues]);
          }
          _classPrivateFieldLooseBase(this, _oldValues)[_oldValues] = null;
        }
      }
      var _processPrivacyArray2 = function _processPrivacyArray22(privacyArr) {
        if (Array.isArray(privacyArr) && privacyArr.length > 0) {
          const privacyObj = privacyArr.reduce((prev, curr) => ({
            ...prev,
            ...curr
          }), {});
          let data = {};
          const profileObj = {};
          var optOut = false;
          if (privacyObj.hasOwnProperty(OPTOUT_KEY)) {
            optOut = privacyObj[OPTOUT_KEY];
            if (typeof optOut === "boolean") {
              profileObj[CT_OPTOUT_KEY] = optOut;
              $ct.isOptInRequest = !optOut;
            }
          }
          if (privacyObj.hasOwnProperty(USEIP_KEY)) {
            const useIP = privacyObj[USEIP_KEY];
            const shouldUseIP = typeof useIP === "boolean" ? useIP : false;
            StorageManager.setMetaProp(USEIP_KEY, shouldUseIP);
          }
          if (!isObjectEmpty(profileObj)) {
            data.type = "profile";
            data.profile = profileObj;
            data = _classPrivateFieldLooseBase(this, _request$2)[_request$2].addSystemDataToObject(data, void 0);
            const compressedData = compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger$2)[_logger$2]);
            let pageLoadUrl = _classPrivateFieldLooseBase(this, _account$2)[_account$2].dataPostURL;
            pageLoadUrl = addToURL(pageLoadUrl, "type", EVT_PUSH);
            pageLoadUrl = addToURL(pageLoadUrl, "d", compressedData);
            pageLoadUrl = addToURL(pageLoadUrl, OPTOUT_KEY, optOut ? "true" : "false");
            _classPrivateFieldLooseBase(this, _request$2)[_request$2].saveAndFireRequest(pageLoadUrl, $ct.blockRequest);
            privacyArr.splice(0, privacyArr.length);
          }
        }
      };
      var _variableStore$1 = _classPrivateFieldLooseKey("variableStore");
      class Variable {
        /**
         * Creates an instance of the Variable class.
         *
         * @constructor
         * @param {VariableStore} options.variableStore - The VariableStore instance for registration.
         * @param {string|null} options.name - The name of the variable.
         * @param {*} options.defaultValue - The default value of the variable.
         * @param {*} options.value - The current value of the variable.
         * @param {string|null} options.type - The type of the variable (string, number, boolean).
         * @param {boolean} options.hadStarted - A flag indicating whether the variable has started (used internally).
         * @param {Function[]} options.valueChangedCallbacks - Array to store callbacks to be executed when the variable value changes.
         */
        constructor(_ref) {
          let {
            variableStore
          } = _ref;
          Object.defineProperty(this, _variableStore$1, {
            writable: true,
            value: void 0
          });
          this.name = null;
          this.defaultValue = null;
          this.value = null;
          this.type = null;
          this.hadStarted = false;
          this.valueChangedCallbacks = [];
          _classPrivateFieldLooseBase(this, _variableStore$1)[_variableStore$1] = variableStore;
        }
        getValue() {
          return this.value;
        }
        getdefaultValue() {
          return this.defaultValue;
        }
        /**
         * Defines a new variable with the provided name, default value, and variable store.
         * @static
         * @param {string} name - The name of the variable.
         * @param {*} defaultValue - The default value of the variable.
         * @param {VariableStore} variableStore - The VariableStore instance for registration.
         * @returns {Variable|null} - The created Variable instance or null if invalid parameters are provided.
         */
        static define(name, defaultValue, variableStore, logger2) {
          if (!name || typeof name !== "string") {
            logger2.error("Empty or invalid name parameter provided.");
            return null;
          }
          if (name.startsWith(".") || name.endsWith(".")) {
            logger2.error("Variable name starts or ends with a `.` which is not allowed: " + name);
            return null;
          }
          const typeOfDefaultValue = typeof defaultValue;
          if (typeOfDefaultValue !== "string" && typeOfDefaultValue !== "number" && typeOfDefaultValue !== "boolean" && typeOfDefaultValue !== "object") {
            logger2.error("Only (string, number, boolean, objects) are accepted as value");
            return null;
          }
          if (typeOfDefaultValue === "object" && objectHasNestedArrayOrFunction(defaultValue)) {
            logger2.error("Nested arrays/functions are not supported in JSON variables");
            return null;
          }
          const existing = variableStore.getVariable(name);
          if (existing) {
            return existing;
          }
          const varInstance = new Variable({
            variableStore
          });
          try {
            varInstance.name = name;
            varInstance.defaultValue = defaultValue;
            varInstance.value = defaultValue;
            varInstance.type = typeOfDefaultValue;
            variableStore.registerVariable(varInstance);
            varInstance.update(defaultValue);
          } catch (error) {
            logger2.error(error);
          }
          return varInstance;
        }
        static defineFileVar(name, variableStore, logger2) {
          if (!name || typeof name !== "string" || name.startsWith(".") || name.endsWith(".")) {
            logger2.error("Empty or invalid name parameter provided.");
            return null;
          }
          const varInstance = new Variable({
            variableStore
          });
          try {
            varInstance.name = name;
            varInstance.defaultValue = "";
            varInstance.type = "file";
            variableStore.registerVariable(varInstance);
            varInstance.update(varInstance.defaultValue);
          } catch (error) {
            logger2.error(error);
          }
          return varInstance;
        }
        /**
         * Updates the variable's value, triggering callbacks if hasVarsRequestCompleted is returned true.
         * @param {*} newValue - The new value to be assigned to the variable.
         */
        update(newValue) {
          const oldValue = this.value;
          this.value = newValue;
          if (newValue === null && oldValue === null) {
            return;
          }
          if (newValue !== null && newValue === oldValue && this.hadStarted) {
            return;
          }
          if (_classPrivateFieldLooseBase(this, _variableStore$1)[_variableStore$1].hasVarsRequestCompleted()) {
            this.hadStarted = true;
            this.triggerValueChanged();
          }
        }
        /**
         * Invokes all registered callbacks when the variable value changes.
         */
        triggerValueChanged() {
          this.valueChangedCallbacks.forEach((onValueChanged) => {
            onValueChanged(this);
          });
        }
        /**
         * Adds a callback function to the array and triggers it immediately if variable requests have completed.
         * @param {Function} onValueChanged - The callback function to be added.
         */
        addValueChangedCallback(onValueChanged, logger2) {
          if (!onValueChanged) {
            logger2.log("Invalid callback parameter provided.");
            return;
          }
          this.valueChangedCallbacks.push(onValueChanged);
          if (_classPrivateFieldLooseBase(this, _variableStore$1)[_variableStore$1].hasVarsRequestCompleted()) {
            onValueChanged(this);
          }
        }
        /**
         * Removes a callback function from the array.
         * @param {Function} onValueChanged - The callback function to be removed.
         */
        removeValueChangedCallback(onValueChanged) {
          const index = this.valueChangedCallbacks.indexOf(onValueChanged);
          if (index !== -1) {
            this.valueChangedCallbacks.splice(index, 1);
          }
        }
        /**
         * Resets the `hadStarted` flag to false.
         */
        clearStartFlag() {
          this.hadStarted = false;
        }
      }
      var _logger$1 = _classPrivateFieldLooseKey("logger");
      var _account$1 = _classPrivateFieldLooseKey("account");
      var _request$1 = _classPrivateFieldLooseKey("request");
      var _event = _classPrivateFieldLooseKey("event");
      var _variables = _classPrivateFieldLooseKey("variables");
      var _remoteVariables = _classPrivateFieldLooseKey("remoteVariables");
      var _fetchCallback = _classPrivateFieldLooseKey("fetchCallback");
      var _variablesChangedCallbacks = _classPrivateFieldLooseKey("variablesChangedCallbacks");
      var _oneTimeVariablesChangedCallbacks = _classPrivateFieldLooseKey("oneTimeVariablesChangedCallbacks");
      var _hasVarsRequestCompleted = _classPrivateFieldLooseKey("hasVarsRequestCompleted");
      var _runVariablesChangedCallback = _classPrivateFieldLooseKey("runVariablesChangedCallback");
      class VariableStore {
        constructor(_ref) {
          let {
            logger: logger2,
            request: request2,
            account: account2,
            event
          } = _ref;
          Object.defineProperty(this, _runVariablesChangedCallback, {
            value: _runVariablesChangedCallback2
          });
          Object.defineProperty(this, _logger$1, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _account$1, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _request$1, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _event, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _variables, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _remoteVariables, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _fetchCallback, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _variablesChangedCallbacks, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _oneTimeVariablesChangedCallbacks, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _hasVarsRequestCompleted, {
            writable: true,
            value: false
          });
          _classPrivateFieldLooseBase(this, _logger$1)[_logger$1] = logger2;
          _classPrivateFieldLooseBase(this, _account$1)[_account$1] = account2;
          _classPrivateFieldLooseBase(this, _request$1)[_request$1] = request2;
          _classPrivateFieldLooseBase(this, _event)[_event] = event;
          _classPrivateFieldLooseBase(this, _variables)[_variables] = {};
          _classPrivateFieldLooseBase(this, _remoteVariables)[_remoteVariables] = {};
          _classPrivateFieldLooseBase(this, _variablesChangedCallbacks)[_variablesChangedCallbacks] = [];
          _classPrivateFieldLooseBase(this, _oneTimeVariablesChangedCallbacks)[_oneTimeVariablesChangedCallbacks] = [];
          $ct.variableStore = this;
        }
        /**
         * Registers a variable instance in the store.
         * @param {Object} varInstance - The variable instance to be registered.
         */
        registerVariable(varInstance) {
          const {
            name
          } = varInstance;
          _classPrivateFieldLooseBase(this, _variables)[_variables][name] = varInstance;
          console.log("registerVariable", _classPrivateFieldLooseBase(this, _variables)[_variables]);
        }
        /**
         * Retrieves a variable by its name.
         * @param {string} name - The name of the variable to retrieve.
         * @returns {Object} - The variable instance.
         */
        getVariable(name) {
          return _classPrivateFieldLooseBase(this, _variables)[_variables][name];
        }
        hasVarsRequestCompleted() {
          return _classPrivateFieldLooseBase(this, _hasVarsRequestCompleted)[_hasVarsRequestCompleted];
        }
        /**
         * Synchronizes variables with the server.
         * @param {Function} onSyncSuccess - Callback function on successful synchronization.
         * @param {Function} onSyncFailure - Callback function on synchronization failure.
         * @throws Will throw an error if the account token is missing.
         * @returns {Promise} - The result of the synchronization request.
         */
        syncVariables(onSyncSuccess, onSyncFailure) {
          if (!_classPrivateFieldLooseBase(this, _account$1)[_account$1].token) {
            const m = "Account token is missing.";
            _classPrivateFieldLooseBase(this, _logger$1)[_logger$1].error(m);
            return Promise.reject(new Error(m));
          }
          const payload = {
            type: "varsPayload",
            vars: {}
          };
          for (const name in _classPrivateFieldLooseBase(this, _variables)[_variables]) {
            if (typeof _classPrivateFieldLooseBase(this, _variables)[_variables][name].defaultValue === "object") {
              var _classPrivateFieldLoo;
              const flattenedPayload = flattenObjectToDotNotation({
                [(_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _variables)[_variables][name]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.name]: _classPrivateFieldLooseBase(this, _variables)[_variables][name].defaultValue
              });
              for (const key in flattenedPayload) {
                payload.vars[key] = {
                  defaultValue: flattenedPayload[key].defaultValue,
                  type: flattenedPayload[key].type
                };
              }
            } else if (_classPrivateFieldLooseBase(this, _variables)[_variables][name].type === "file") {
              payload.vars[name] = {
                type: _classPrivateFieldLooseBase(this, _variables)[_variables][name].type
              };
            } else {
              payload.vars[name] = {
                defaultValue: _classPrivateFieldLooseBase(this, _variables)[_variables][name].defaultValue,
                type: _classPrivateFieldLooseBase(this, _variables)[_variables][name].type
              };
            }
          }
          if (Object.keys(payload.vars).length === 0) {
            const m = "No variables are defined.";
            _classPrivateFieldLooseBase(this, _logger$1)[_logger$1].error(m);
            return Promise.reject(new Error(m));
          }
          let meta = {};
          meta = _classPrivateFieldLooseBase(this, _request$1)[_request$1].addSystemDataToObject(meta, void 0);
          meta.tk = _classPrivateFieldLooseBase(this, _account$1)[_account$1].token;
          meta.type = "meta";
          const body = JSON.stringify([meta, payload]);
          const url = _classPrivateFieldLooseBase(this, _account$1)[_account$1].dataPostPEURL;
          return _classPrivateFieldLooseBase(this, _request$1)[_request$1].post(url, body).then((r) => {
            if (onSyncSuccess && typeof onSyncSuccess === "function") {
              onSyncSuccess(r);
            }
            return r;
          }).catch((e) => {
            if (onSyncFailure && typeof onSyncFailure === "function") {
              onSyncFailure(e);
            }
            if (e.status === 400) {
              _classPrivateFieldLooseBase(this, _logger$1)[_logger$1].error("Invalid sync payload or clear the existing draft");
            } else if (e.status === 401) {
              _classPrivateFieldLooseBase(this, _logger$1)[_logger$1].error("This is not a test profile");
            } else {
              _classPrivateFieldLooseBase(this, _logger$1)[_logger$1].error("Sync variable failed");
            }
            throw e;
          });
        }
        /**
         * Fetches variables from the server.
         * @param {Function} onFetchCallback - Callback function on fetch completion.
         */
        fetchVariables(onFetchCallback) {
          _classPrivateFieldLooseBase(this, _event)[_event].push(WZRK_FETCH, {
            t: 4
          });
          if (onFetchCallback && typeof onFetchCallback === "function") {
            _classPrivateFieldLooseBase(this, _fetchCallback)[_fetchCallback] = onFetchCallback;
          }
        }
        mergeVariables(vars) {
          console.log("msg vars is ", vars);
          _classPrivateFieldLooseBase(this, _hasVarsRequestCompleted)[_hasVarsRequestCompleted] = true;
          StorageManager.saveToLSorCookie(VARIABLES, vars);
          _classPrivateFieldLooseBase(this, _remoteVariables)[_remoteVariables] = vars;
          for (const name in _classPrivateFieldLooseBase(this, _variables)[_variables]) {
            if (vars.hasOwnProperty(name)) {
              _classPrivateFieldLooseBase(this, _variables)[_variables][name].update(vars[name]);
            }
          }
          if (_classPrivateFieldLooseBase(this, _fetchCallback)[_fetchCallback]) {
            _classPrivateFieldLooseBase(this, _fetchCallback)[_fetchCallback]();
          }
          _classPrivateFieldLooseBase(this, _runVariablesChangedCallback)[_runVariablesChangedCallback]();
        }
        addVariablesChangedCallback(callback) {
          if (callback && typeof callback === "function") {
            _classPrivateFieldLooseBase(this, _variablesChangedCallbacks)[_variablesChangedCallbacks].push(callback);
            if (this.hasVarsRequestCompleted()) {
              callback();
            }
          } else {
            _classPrivateFieldLooseBase(this, _logger$1)[_logger$1].error("callback is not a function");
          }
        }
        addOneTimeVariablesChangedCallback(callback) {
          if (callback && typeof callback === "function") {
            if (this.hasVarsRequestCompleted()) {
              callback();
            } else {
              _classPrivateFieldLooseBase(this, _oneTimeVariablesChangedCallbacks)[_oneTimeVariablesChangedCallbacks].push(callback);
            }
          }
        }
        removeVariablesChangedCallback(callback) {
          const index = _classPrivateFieldLooseBase(this, _variablesChangedCallbacks)[_variablesChangedCallbacks].indexOf(callback);
          if (index !== -1) {
            _classPrivateFieldLooseBase(this, _variablesChangedCallbacks)[_variablesChangedCallbacks].splice(index, 1);
          }
        }
        removeOneTimeVariablesChangedCallback(callback) {
          const index = _classPrivateFieldLooseBase(this, _oneTimeVariablesChangedCallbacks)[_oneTimeVariablesChangedCallbacks].indexOf(callback);
          if (index !== -1) {
            _classPrivateFieldLooseBase(this, _oneTimeVariablesChangedCallbacks)[_oneTimeVariablesChangedCallbacks].splice(index, 1);
          }
        }
      }
      var _runVariablesChangedCallback2 = function _runVariablesChangedCallback22() {
        for (var callback of _classPrivateFieldLooseBase(this, _variablesChangedCallbacks)[_variablesChangedCallbacks]) {
          callback();
        }
        for (var callBack of _classPrivateFieldLooseBase(this, _oneTimeVariablesChangedCallbacks)[_oneTimeVariablesChangedCallbacks]) {
          callBack();
        }
        _classPrivateFieldLooseBase(this, _oneTimeVariablesChangedCallbacks)[_oneTimeVariablesChangedCallbacks].length = 0;
      };
      var _logger = _classPrivateFieldLooseKey("logger");
      var _api = _classPrivateFieldLooseKey("api");
      var _onloadcalled = _classPrivateFieldLooseKey("onloadcalled");
      var _device = _classPrivateFieldLooseKey("device");
      var _session = _classPrivateFieldLooseKey("session");
      var _account = _classPrivateFieldLooseKey("account");
      var _request = _classPrivateFieldLooseKey("request");
      var _variableStore = _classPrivateFieldLooseKey("variableStore");
      var _isSpa = _classPrivateFieldLooseKey("isSpa");
      var _previousUrl = _classPrivateFieldLooseKey("previousUrl");
      var _boundCheckPageChanged = _classPrivateFieldLooseKey("boundCheckPageChanged");
      var _dismissSpamControl = _classPrivateFieldLooseKey("dismissSpamControl");
      var _pageChangeTimeoutId = _classPrivateFieldLooseKey("pageChangeTimeoutId");
      var _processOldValues = _classPrivateFieldLooseKey("processOldValues");
      var _debounce = _classPrivateFieldLooseKey("debounce");
      var _checkPageChanged = _classPrivateFieldLooseKey("checkPageChanged");
      var _updateUnviewedBadgePosition = _classPrivateFieldLooseKey("updateUnviewedBadgePosition");
      var _pingRequest = _classPrivateFieldLooseKey("pingRequest");
      var _isPingContinuous = _classPrivateFieldLooseKey("isPingContinuous");
      var _overrideDSyncFlag = _classPrivateFieldLooseKey("overrideDSyncFlag");
      var _sendLocationData = _classPrivateFieldLooseKey("sendLocationData");
      class CleverTap {
        get spa() {
          return _classPrivateFieldLooseBase(this, _isSpa)[_isSpa];
        }
        set spa(value) {
          const isSpa = value === true;
          if (_classPrivateFieldLooseBase(this, _isSpa)[_isSpa] !== isSpa && _classPrivateFieldLooseBase(this, _onloadcalled)[_onloadcalled] === 1) {
            if (isSpa) {
              document.addEventListener("click", _classPrivateFieldLooseBase(this, _boundCheckPageChanged)[_boundCheckPageChanged]);
            } else {
              document.removeEventListener("click", _classPrivateFieldLooseBase(this, _boundCheckPageChanged)[_boundCheckPageChanged]);
            }
          }
          _classPrivateFieldLooseBase(this, _isSpa)[_isSpa] = isSpa;
        }
        get dismissSpamControl() {
          return _classPrivateFieldLooseBase(this, _dismissSpamControl)[_dismissSpamControl];
        }
        set dismissSpamControl(value) {
          const dismissSpamControl = value === true;
          _classPrivateFieldLooseBase(this, _dismissSpamControl)[_dismissSpamControl] = dismissSpamControl;
          $ct.dismissSpamControl = dismissSpamControl;
        }
        constructor() {
          var _clevertap$account, _clevertap$account2, _clevertap$account3, _clevertap$account4, _clevertap$account5, _clevertap$config, _clevertap$config2, _clevertap$account6;
          let clevertap2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          Object.defineProperty(this, _sendLocationData, {
            value: _sendLocationData2
          });
          Object.defineProperty(this, _overrideDSyncFlag, {
            value: _overrideDSyncFlag2
          });
          Object.defineProperty(this, _isPingContinuous, {
            value: _isPingContinuous2
          });
          Object.defineProperty(this, _pingRequest, {
            value: _pingRequest2
          });
          Object.defineProperty(this, _updateUnviewedBadgePosition, {
            value: _updateUnviewedBadgePosition2
          });
          Object.defineProperty(this, _checkPageChanged, {
            value: _checkPageChanged2
          });
          Object.defineProperty(this, _debounce, {
            value: _debounce2
          });
          Object.defineProperty(this, _processOldValues, {
            value: _processOldValues2
          });
          Object.defineProperty(this, _logger, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _api, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _onloadcalled, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _device, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _session, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _account, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _request, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _variableStore, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _isSpa, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _previousUrl, {
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, _boundCheckPageChanged, {
            writable: true,
            value: _classPrivateFieldLooseBase(this, _checkPageChanged)[_checkPageChanged].bind(this)
          });
          Object.defineProperty(this, _dismissSpamControl, {
            writable: true,
            value: void 0
          });
          this.enablePersonalization = void 0;
          Object.defineProperty(this, _pageChangeTimeoutId, {
            writable: true,
            value: void 0
          });
          this.popupCallbacks = {};
          this.popupCurrentWzrkId = "";
          _classPrivateFieldLooseBase(this, _onloadcalled)[_onloadcalled] = 0;
          this._isPersonalisationActive = this._isPersonalisationActive.bind(this);
          this.raiseNotificationClicked = () => {
          };
          _classPrivateFieldLooseBase(this, _logger)[_logger] = new Logger(logLevels.INFO);
          _classPrivateFieldLooseBase(this, _account)[_account] = new Account((_clevertap$account = clevertap2.account) === null || _clevertap$account === void 0 ? void 0 : _clevertap$account[0], clevertap2.region || ((_clevertap$account2 = clevertap2.account) === null || _clevertap$account2 === void 0 ? void 0 : _clevertap$account2[1]), clevertap2.targetDomain || ((_clevertap$account3 = clevertap2.account) === null || _clevertap$account3 === void 0 ? void 0 : _clevertap$account3[2]), clevertap2.token || ((_clevertap$account4 = clevertap2.account) === null || _clevertap$account4 === void 0 ? void 0 : _clevertap$account4[3]));
          encryption.key = (_clevertap$account5 = clevertap2.account) === null || _clevertap$account5 === void 0 ? void 0 : _clevertap$account5[0].id;
          const result = validateCustomCleverTapID(clevertap2 === null || clevertap2 === void 0 ? void 0 : (_clevertap$config = clevertap2.config) === null || _clevertap$config === void 0 ? void 0 : _clevertap$config.customId);
          if (!result.isValid && (clevertap2 === null || clevertap2 === void 0 ? void 0 : (_clevertap$config2 = clevertap2.config) === null || _clevertap$config2 === void 0 ? void 0 : _clevertap$config2.customId)) {
            _classPrivateFieldLooseBase(this, _logger)[_logger].error(result.error);
          }
          _classPrivateFieldLooseBase(this, _device)[_device] = new DeviceManager({
            logger: _classPrivateFieldLooseBase(this, _logger)[_logger],
            customId: (result === null || result === void 0 ? void 0 : result.isValid) ? result === null || result === void 0 ? void 0 : result.sanitizedId : null
          });
          _classPrivateFieldLooseBase(this, _dismissSpamControl)[_dismissSpamControl] = clevertap2.dismissSpamControl || false;
          this.shpfyProxyPath = clevertap2.shpfyProxyPath || "";
          _classPrivateFieldLooseBase(this, _session)[_session] = new SessionManager({
            logger: _classPrivateFieldLooseBase(this, _logger)[_logger],
            isPersonalisationActive: this._isPersonalisationActive
          });
          _classPrivateFieldLooseBase(this, _request)[_request] = new RequestManager({
            logger: _classPrivateFieldLooseBase(this, _logger)[_logger],
            account: _classPrivateFieldLooseBase(this, _account)[_account],
            device: _classPrivateFieldLooseBase(this, _device)[_device],
            session: _classPrivateFieldLooseBase(this, _session)[_session],
            isPersonalisationActive: this._isPersonalisationActive
          });
          this.enablePersonalization = clevertap2.enablePersonalization || false;
          this.event = new EventHandler({
            logger: _classPrivateFieldLooseBase(this, _logger)[_logger],
            request: _classPrivateFieldLooseBase(this, _request)[_request],
            isPersonalisationActive: this._isPersonalisationActive
          }, clevertap2.event);
          this.profile = new ProfileHandler({
            logger: _classPrivateFieldLooseBase(this, _logger)[_logger],
            request: _classPrivateFieldLooseBase(this, _request)[_request],
            account: _classPrivateFieldLooseBase(this, _account)[_account],
            isPersonalisationActive: this._isPersonalisationActive
          }, clevertap2.profile);
          this.onUserLogin = new UserLoginHandler({
            request: _classPrivateFieldLooseBase(this, _request)[_request],
            account: _classPrivateFieldLooseBase(this, _account)[_account],
            session: _classPrivateFieldLooseBase(this, _session)[_session],
            logger: _classPrivateFieldLooseBase(this, _logger)[_logger],
            device: _classPrivateFieldLooseBase(this, _device)[_device]
          }, clevertap2.onUserLogin);
          this.privacy = new Privacy({
            request: _classPrivateFieldLooseBase(this, _request)[_request],
            account: _classPrivateFieldLooseBase(this, _account)[_account],
            logger: _classPrivateFieldLooseBase(this, _logger)[_logger]
          }, clevertap2.privacy);
          this.notifications = new NotificationHandler({
            logger: _classPrivateFieldLooseBase(this, _logger)[_logger],
            request: _classPrivateFieldLooseBase(this, _request)[_request],
            account: _classPrivateFieldLooseBase(this, _account)[_account]
          }, clevertap2.notifications);
          _classPrivateFieldLooseBase(this, _variableStore)[_variableStore] = new VariableStore({
            logger: _classPrivateFieldLooseBase(this, _logger)[_logger],
            request: _classPrivateFieldLooseBase(this, _request)[_request],
            account: _classPrivateFieldLooseBase(this, _account)[_account],
            event: this.event
          });
          _classPrivateFieldLooseBase(this, _api)[_api] = new CleverTapAPI({
            logger: _classPrivateFieldLooseBase(this, _logger)[_logger],
            request: _classPrivateFieldLooseBase(this, _request)[_request],
            device: _classPrivateFieldLooseBase(this, _device)[_device],
            session: _classPrivateFieldLooseBase(this, _session)[_session]
          });
          this.spa = clevertap2.spa;
          this.dismissSpamControl = clevertap2.dismissSpamControl;
          this.user = new User({
            isPersonalisationActive: this._isPersonalisationActive
          });
          encryption.logger = _classPrivateFieldLooseBase(this, _logger)[_logger];
          this.session = {
            getTimeElapsed: () => {
              return _classPrivateFieldLooseBase(this, _session)[_session].getTimeElapsed();
            },
            getPageCount: () => {
              return _classPrivateFieldLooseBase(this, _session)[_session].getPageCount();
            }
          };
          this.logout = () => {
            _classPrivateFieldLooseBase(this, _logger)[_logger].debug("logout called");
            StorageManager.setInstantDeleteFlagInK();
          };
          this.clear = () => {
            this.onUserLogin.clear();
          };
          this.getCleverTapID = () => {
            return _classPrivateFieldLooseBase(this, _device)[_device].getGuid();
          };
          this.getAccountID = () => {
            return _classPrivateFieldLooseBase(this, _account)[_account].id;
          };
          this.getSCDomain = () => {
            return _classPrivateFieldLooseBase(this, _account)[_account].finalTargetDomain;
          };
          this.setLibrary = (libName, libVersion) => {
            $ct.flutterVersion = {
              [libName]: libVersion
            };
          };
          this.setSCSDKVersion = (ver) => {
            _classPrivateFieldLooseBase(this, _account)[_account].scSDKVersion = ver;
            const data = {};
            data.af = {
              scv: "sc-sdk-v" + _classPrivateFieldLooseBase(this, _account)[_account].scSDKVersion
            };
            let pageLoadUrl = _classPrivateFieldLooseBase(this, _account)[_account].dataPostURL;
            pageLoadUrl = addToURL(pageLoadUrl, "type", "page");
            pageLoadUrl = addToURL(pageLoadUrl, "d", compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger)[_logger]));
            _classPrivateFieldLooseBase(this, _request)[_request].saveAndFireRequest(pageLoadUrl, $ct.blockRequest);
          };
          if (hasWebInboxSettingsInLS()) {
            checkAndRegisterWebInboxElements();
            initializeWebInbox(_classPrivateFieldLooseBase(this, _logger)[_logger]);
          }
          this.getInboxMessageCount = () => {
            const msgCount = getInboxMessages();
            return Object.keys(msgCount).length;
          };
          this.getInboxMessageUnreadCount = () => {
            try {
              const unreadMessages = this.getUnreadInboxMessages();
              const result2 = Object.keys(unreadMessages).length;
              return result2;
            } catch (e) {
              _classPrivateFieldLooseBase(this, _logger)[_logger].error("Error in getInboxMessageUnreadCount" + e);
            }
          };
          this.getAllInboxMessages = () => {
            return getInboxMessages();
          };
          this.getUnreadInboxMessages = () => {
            try {
              const messages = getInboxMessages();
              const result2 = {};
              if (Object.keys(messages).length > 0) {
                for (const message in messages) {
                  if (messages[message].viewed === 0) {
                    result2[message] = messages[message];
                  }
                }
              }
              return result2;
            } catch (e) {
              _classPrivateFieldLooseBase(this, _logger)[_logger].error("Error in getUnreadInboxMessages" + e);
            }
          };
          this.getInboxMessageForId = (messageId) => {
            const messages = getInboxMessages();
            if ((messageId !== null || messageId !== "") && messages.hasOwnProperty(messageId)) {
              return messages[messageId];
            } else {
              _classPrivateFieldLooseBase(this, _logger)[_logger].error("No message available for message Id " + messageId);
            }
          };
          this.deleteInboxMessage = (messageId) => {
            const messages = getInboxMessages();
            if ((messageId !== null || messageId !== "") && messages.hasOwnProperty(messageId)) {
              if (messages[messageId].viewed === 0) {
                if ($ct.inbox) {
                  $ct.inbox.unviewedCounter--;
                  delete $ct.inbox.unviewedMessages[messageId];
                }
                const unViewedBadge = document.getElementById("unviewedBadge");
                if (unViewedBadge) {
                  unViewedBadge.innerText = $ct.inbox.unviewedCounter;
                  unViewedBadge.style.display = $ct.inbox.unviewedCounter > 0 ? "flex" : "none";
                }
              }
              const ctInbox = document.querySelector("ct-web-inbox");
              if (ctInbox) {
                const el = ctInbox.shadowRoot.getElementById(messageId);
                el && el.remove();
              }
              delete messages[messageId];
              saveInboxMessages(messages);
            } else {
              _classPrivateFieldLooseBase(this, _logger)[_logger].error("No message available for message Id " + messageId);
            }
          };
          this.markReadInboxMessage = (messageId) => {
            const messages = getInboxMessages();
            if ((messageId !== null || messageId !== "") && messages.hasOwnProperty(messageId)) {
              if (messages[messageId].viewed === 1) {
                return _classPrivateFieldLooseBase(this, _logger)[_logger].error("Message already viewed" + messageId);
              }
              const ctInbox = document.querySelector("ct-web-inbox");
              if (ctInbox) {
                const el = ctInbox.shadowRoot.getElementById(messageId);
                if (el !== null) {
                  el.shadowRoot.getElementById("unreadMarker").style.display = "none";
                }
              }
              messages[messageId].viewed = 1;
              const unViewedBadge = document.getElementById("unviewedBadge");
              if (unViewedBadge) {
                var counter = parseInt(unViewedBadge.innerText) - 1;
                unViewedBadge.innerText = counter;
                unViewedBadge.style.display = counter > 0 ? "flex" : "none";
              }
              window.clevertap.renderNotificationViewed({
                msgId: messages[messageId].wzrk_id,
                pivotId: messages[messageId].pivotId
              });
              if ($ct.inbox) {
                $ct.inbox.unviewedCounter--;
                delete $ct.inbox.unviewedMessages[messageId];
              }
              saveInboxMessages(messages);
            } else {
              _classPrivateFieldLooseBase(this, _logger)[_logger].error("No message available for message Id " + messageId);
            }
          };
          this.markReadInboxMessagesForIds = (messageIds) => {
            if (Array.isArray(messageIds)) {
              for (var id2 = 0; id2 < messageIds.length; id2++) {
                this.markReadInboxMessage(messageIds[id2]);
              }
            }
          };
          this.markReadAllInboxMessage = () => {
            const messages = getInboxMessages();
            const unreadMsg = this.getUnreadInboxMessages();
            if (Object.keys(unreadMsg).length > 0) {
              const msgIds = Object.keys(unreadMsg);
              msgIds.forEach((key) => {
                const ctInbox = document.querySelector("ct-web-inbox");
                if (ctInbox) {
                  const el = ctInbox.shadowRoot.getElementById(key);
                  if (el !== null) {
                    el.shadowRoot.getElementById("unreadMarker").style.display = "none";
                  }
                }
                messages[key].viewed = 1;
                window.clevertap.renderNotificationViewed({
                  msgId: messages[key].wzrk_id,
                  pivotId: messages[key].wzrk_pivot
                });
              });
              const unViewedBadge = document.getElementById("unviewedBadge");
              if (unViewedBadge) {
                unViewedBadge.innerText = 0;
                unViewedBadge.style.display = "none";
              }
              saveInboxMessages(messages);
              $ct.inbox.unviewedCounter = 0;
              $ct.inbox.unviewedMessages = {};
            } else {
              _classPrivateFieldLooseBase(this, _logger)[_logger].debug("All messages are already read");
            }
          };
          this.toggleInbox = (e) => {
            var _$ct$inbox;
            return (_$ct$inbox = $ct.inbox) === null || _$ct$inbox === void 0 ? void 0 : _$ct$inbox.toggleInbox(e);
          };
          this.renderNotificationViewed = (detail) => {
            processNotificationEvent(NOTIFICATION_VIEWED, detail);
          };
          this.renderNotificationClicked = (detail) => {
            processNotificationEvent(NOTIFICATION_CLICKED, detail);
          };
          const processNotificationEvent = (eventName, eventDetail) => {
            if (!eventDetail || !eventDetail.msgId) {
              return;
            }
            const data = {};
            data.type = "event";
            data.evtName = eventName;
            data.evtData = {
              [WZRK_ID]: eventDetail.msgId
            };
            if (eventDetail.pivotId) {
              data.evtData = {
                ...data.evtData,
                wzrk_pivot: eventDetail.pivotId
              };
            }
            if (eventDetail.wzrk_slideNo) {
              data.evtData = {
                ...data.evtData,
                wzrk_slideNo: eventDetail.wzrk_slideNo
              };
            }
            if (eventDetail.kv && eventDetail.kv !== null && eventDetail.kv !== void 0) {
              for (const key in eventDetail.kv) {
                if (key.startsWith(WZRK_PREFIX)) {
                  data.evtData = {
                    ...data.evtData,
                    [key]: eventDetail.kv[key]
                  };
                }
              }
            }
            if (eventDetail.msgCTkv && eventDetail.msgCTkv !== null && eventDetail.msgCTkv !== void 0) {
              for (const key in eventDetail.msgCTkv) {
                if (key.startsWith(WZRK_PREFIX)) {
                  data.evtData = {
                    ...data.evtData,
                    [key]: eventDetail.msgCTkv[key]
                  };
                }
              }
            }
            _classPrivateFieldLooseBase(this, _request)[_request].processEvent(data);
          };
          this.setLogLevel = (l) => {
            _classPrivateFieldLooseBase(this, _logger)[_logger].logLevel = Number(l);
            if (l === 3) {
              sessionStorage.WZRK_D = "";
            } else {
              delete sessionStorage.WZRK_D;
            }
          };
          this.handleIncrementValue = (key, value) => {
            this.profile._handleIncrementDecrementValue(key, value, COMMAND_INCREMENT);
          };
          this.handleDecrementValue = (key, value) => {
            this.profile._handleIncrementDecrementValue(key, value, COMMAND_DECREMENT);
          };
          this.setMultiValuesForKey = (key, value) => {
            if (Array.isArray(value)) {
              this.profile._handleMultiValueSet(key, value, COMMAND_SET);
            } else {
              console.error("setMultiValuesForKey should be called with a value of type array");
            }
          };
          this.addMultiValueForKey = (key, value) => {
            if (typeof value === "string" || typeof value === "number") {
              this.profile._handleMultiValueAdd(key, value, COMMAND_ADD);
            } else {
              console.error("addMultiValueForKey should be called with a value of type string or number.");
            }
          };
          this.addMultiValuesForKey = (key, value) => {
            if (Array.isArray(value)) {
              this.profile._handleMultiValueAdd(key, value, COMMAND_ADD);
            } else {
              console.error("addMultiValuesForKey should be called with a value of type array.");
            }
          };
          this.removeMultiValueForKey = (key, value) => {
            if (typeof value === "string" || typeof value === "number") {
              this.profile._handleMultiValueRemove(key, value, COMMAND_REMOVE);
            } else {
              console.error("removeMultiValueForKey should be called with a value of type string or number.");
            }
          };
          this.removeMultiValuesForKey = (key, value) => {
            if (Array.isArray(value)) {
              this.profile._handleMultiValueRemove(key, value, COMMAND_REMOVE);
            } else {
              console.error("removeMultiValuesForKey should be called with a value of type array.");
            }
          };
          this.removeValueForKey = (key) => {
            this.profile._handleMultiValueDelete(key, COMMAND_DELETE);
          };
          this.enableLocalStorageEncryption = (value) => {
            encryption.enableLocalStorageEncryption = value;
          };
          this.isLocalStorageEncryptionEnabled = () => {
            return encryption.enableLocalStorageEncryption;
          };
          const _handleEmailSubscription = (subscription, reEncoded, fetchGroups) => {
            handleEmailSubscription(subscription, reEncoded, fetchGroups, _classPrivateFieldLooseBase(this, _account)[_account], _classPrivateFieldLooseBase(this, _logger)[_logger]);
          };
          this.getLocation = function(lat, lng) {
            if (lat && typeof lat !== "number" || lng && typeof lng !== "number") {
              console.log("Latitude and Longitude must be of number type");
              return;
            }
            if (lat && lng) {
              if (lat <= -90 || lat > 90) {
                console.log("A vaid latitude must range between -90 and 90");
                return;
              }
              if (lng <= -180 || lng > 180) {
                console.log("A valid longitude must range between -180 and 180");
                return;
              }
              $ct.location = {
                Latitude: lat,
                Longitude: lng
              };
              _classPrivateFieldLooseBase(this, _sendLocationData)[_sendLocationData]({
                Latitude: lat,
                Longitude: lng
              });
            } else {
              if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(showPosition.bind(this), showError);
              } else {
                console.log("Geolocation is not supported by this browser.");
              }
            }
          };
          function showPosition(position) {
            var lat = position.coords.latitude;
            var lng = position.coords.longitude;
            $ct.location = {
              Latitude: lat,
              Longitude: lng
            };
            _classPrivateFieldLooseBase(this, _sendLocationData)[_sendLocationData]({
              Latitude: lat,
              Longitude: lng
            });
          }
          function showError(error) {
            switch (error.code) {
              case error.PERMISSION_DENIED:
                console.log("User denied the request for Geolocation.");
                break;
              case error.POSITION_UNAVAILABLE:
                console.log("Location information is unavailable.");
                break;
              case error.TIMEOUT:
                console.log("The request to get user location timed out.");
                break;
              case error.UNKNOWN_ERROR:
                console.log("An unknown error occurred.");
                break;
            }
          }
          const api = _classPrivateFieldLooseBase(this, _api)[_api];
          api.logout = this.logout;
          api.clear = this.clear;
          api.closeIframe = (campaignId, divIdIgnored) => {
            closeIframe(campaignId, divIdIgnored, _classPrivateFieldLooseBase(this, _session)[_session].sessionId);
          };
          api.enableWebPush = (enabled, applicationServerKey) => {
            setServerKey(applicationServerKey);
            this.notifications._enableWebPush(enabled, applicationServerKey);
            try {
              StorageManager.saveToLSorCookie(APPLICATION_SERVER_KEY_RECEIVED, true);
            } catch (error) {
              _classPrivateFieldLooseBase(this, _logger)[_logger].error("Could not read value from local storage", error);
            }
          };
          api.tr = (msg) => {
            _tr(msg, {
              device: _classPrivateFieldLooseBase(this, _device)[_device],
              session: _classPrivateFieldLooseBase(this, _session)[_session],
              request: _classPrivateFieldLooseBase(this, _request)[_request],
              logger: _classPrivateFieldLooseBase(this, _logger)[_logger],
              region: _classPrivateFieldLooseBase(this, _account)[_account].region
            });
          };
          api.setEnum = (enumVal) => {
            setEnum(enumVal, _classPrivateFieldLooseBase(this, _logger)[_logger]);
          };
          api.is_onloadcalled = () => {
            return _classPrivateFieldLooseBase(this, _onloadcalled)[_onloadcalled] === 1;
          };
          api.subEmail = (reEncoded) => {
            _handleEmailSubscription("1", reEncoded);
          };
          api.getEmail = (reEncoded, withGroups) => {
            _handleEmailSubscription("-1", reEncoded, withGroups);
          };
          api.unSubEmail = (reEncoded) => {
            _handleEmailSubscription("0", reEncoded);
          };
          api.unsubEmailGroups = (reEncoded) => {
            $ct.unsubGroups = [];
            const elements = document.getElementsByClassName("ct-unsub-group-input-item");
            for (let i = 0; i < elements.length; i++) {
              const element = elements[i];
              if (element.name) {
                const data = {
                  name: element.name,
                  isUnsubscribed: element.checked
                };
                $ct.unsubGroups.push(data);
              }
            }
            _handleEmailSubscription(GROUP_SUBSCRIPTION_REQUEST_ID, reEncoded);
          };
          api.setSubscriptionGroups = (value) => {
            $ct.unsubGroups = value;
          };
          api.getSubscriptionGroups = () => {
            return $ct.unsubGroups;
          };
          api.changeSubscriptionGroups = (reEncoded, updatedGroups) => {
            api.setSubscriptionGroups(updatedGroups);
            _handleEmailSubscription(GROUP_SUBSCRIPTION_REQUEST_ID, reEncoded);
          };
          api.isGlobalUnsubscribe = () => {
            return $ct.globalUnsubscribe;
          };
          api.setIsGlobalUnsubscribe = (value) => {
            $ct.globalUnsubscribe = value;
          };
          api.setUpdatedCategoryLong = (profile) => {
            if (profile[categoryLongKey]) {
              $ct.updatedCategoryLong = profile[categoryLongKey];
            }
          };
          window.$CLTP_WR = window.$WZRK_WR = api;
          if ((_clevertap$account6 = clevertap2.account) === null || _clevertap$account6 === void 0 ? void 0 : _clevertap$account6[0].id) {
            var _clevertap$account7;
            StorageManager.saveToLSorCookie(ACCOUNT_ID, (_clevertap$account7 = clevertap2.account) === null || _clevertap$account7 === void 0 ? void 0 : _clevertap$account7[0].id);
            this.init();
          }
        }
        createCustomIdIfValid(customId) {
          const result = validateCustomCleverTapID(customId);
          if (!result.isValid) {
            _classPrivateFieldLooseBase(this, _logger)[_logger].error(result.error);
          }
          if (_classPrivateFieldLooseBase(this, _device)[_device].gcookie) {
            return;
          }
          if (result.isValid) {
            _classPrivateFieldLooseBase(this, _device)[_device].gcookie = result === null || result === void 0 ? void 0 : result.sanitizedId;
            StorageManager.saveToLSorCookie(GCOOKIE_NAME, result === null || result === void 0 ? void 0 : result.sanitizedId);
            _classPrivateFieldLooseBase(this, _logger)[_logger].debug("CT Initialized with customId:: " + (result === null || result === void 0 ? void 0 : result.sanitizedId));
          } else {
            _classPrivateFieldLooseBase(this, _logger)[_logger].error("Invalid customId");
          }
        }
        init(accountId, region, targetDomain, token) {
          let config = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            antiFlicker: {},
            customId: null
          };
          if ((config === null || config === void 0 ? void 0 : config.antiFlicker) && Object.keys(config === null || config === void 0 ? void 0 : config.antiFlicker).length > 0) {
            addAntiFlicker(config.antiFlicker);
          }
          if (_classPrivateFieldLooseBase(this, _onloadcalled)[_onloadcalled] === 1) {
            return;
          }
          if (accountId) {
            encryption.key = accountId;
          }
          StorageManager.removeCookie("WZRK_P", window.location.hostname);
          if (!_classPrivateFieldLooseBase(this, _account)[_account].id) {
            if (!accountId) {
              _classPrivateFieldLooseBase(this, _logger)[_logger].error(EMBED_ERROR);
              return;
            }
            _classPrivateFieldLooseBase(this, _account)[_account].id = accountId;
            StorageManager.saveToLSorCookie(ACCOUNT_ID, accountId);
            _classPrivateFieldLooseBase(this, _logger)[_logger].debug("CT Initialized with Account ID: " + _classPrivateFieldLooseBase(this, _account)[_account].id);
          }
          handleActionMode(_classPrivateFieldLooseBase(this, _logger)[_logger], _classPrivateFieldLooseBase(this, _account)[_account].id);
          checkCustomHtmlNativeDisplayPreview(_classPrivateFieldLooseBase(this, _logger)[_logger]);
          _classPrivateFieldLooseBase(this, _session)[_session].cookieName = SCOOKIE_PREFIX + "_" + _classPrivateFieldLooseBase(this, _account)[_account].id;
          if (region) {
            _classPrivateFieldLooseBase(this, _account)[_account].region = region;
          }
          if (targetDomain) {
            _classPrivateFieldLooseBase(this, _account)[_account].targetDomain = targetDomain;
          }
          if (token) {
            _classPrivateFieldLooseBase(this, _account)[_account].token = token;
          }
          if (config === null || config === void 0 ? void 0 : config.customId) {
            this.createCustomIdIfValid(config.customId);
          }
          const currLocation = location.href;
          const urlParams = getURLParams(currLocation.toLowerCase());
          if (typeof urlParams.e !== "undefined" && urlParams.wzrk_ex == "0") {
            return;
          }
          $ct.isPrivacyArrPushed = true;
          if ($ct.privacyArray.length > 0) {
            this.privacy.push($ct.privacyArray);
          }
          _classPrivateFieldLooseBase(this, _processOldValues)[_processOldValues]();
          this.pageChanged();
          const backupInterval = setInterval(() => {
            if (_classPrivateFieldLooseBase(this, _device)[_device].gcookie) {
              clearInterval(backupInterval);
              _classPrivateFieldLooseBase(this, _request)[_request].processBackupEvents();
            }
          }, 3e3);
          if (_classPrivateFieldLooseBase(this, _isSpa)[_isSpa]) {
            document.addEventListener("click", _classPrivateFieldLooseBase(this, _boundCheckPageChanged)[_boundCheckPageChanged]);
            window.addEventListener("popstate", _classPrivateFieldLooseBase(this, _boundCheckPageChanged)[_boundCheckPageChanged]);
          } else {
            document.removeEventListener("click", _classPrivateFieldLooseBase(this, _boundCheckPageChanged)[_boundCheckPageChanged]);
          }
          _classPrivateFieldLooseBase(this, _onloadcalled)[_onloadcalled] = 1;
        }
        // process the option array provided to the clevertap object
        // after its been initialized
        pageChanged() {
          const currLocation = window.location.href;
          const urlParams = getURLParams(currLocation.toLowerCase());
          const obj = _classPrivateFieldLooseBase(this, _session)[_session].getSessionCookieObject();
          let pgCount = typeof obj.p === "undefined" ? 0 : obj.p;
          obj.p = ++pgCount;
          _classPrivateFieldLooseBase(this, _session)[_session].setSessionCookieObject(obj);
          let data = {};
          let referrerDomain = getDomain(document.referrer);
          if (window.location.hostname !== referrerDomain) {
            const maxLen = 120;
            if (referrerDomain !== "") {
              referrerDomain = referrerDomain.length > maxLen ? referrerDomain.substring(0, maxLen) : referrerDomain;
              data.referrer = referrerDomain;
            }
            let utmSource = urlParams.utm_source || urlParams.wzrk_source;
            if (typeof utmSource !== "undefined") {
              utmSource = utmSource.length > maxLen ? utmSource.substring(0, maxLen) : utmSource;
              data.us = utmSource;
            }
            let utmMedium = urlParams.utm_medium || urlParams.wzrk_medium;
            if (typeof utmMedium !== "undefined") {
              utmMedium = utmMedium.length > maxLen ? utmMedium.substring(0, maxLen) : utmMedium;
              data.um = utmMedium;
            }
            let utmCampaign = urlParams.utm_campaign || urlParams.wzrk_campaign;
            if (typeof utmCampaign !== "undefined") {
              utmCampaign = utmCampaign.length > maxLen ? utmCampaign.substring(0, maxLen) : utmCampaign;
              data.uc = utmCampaign;
            }
            if (typeof urlParams.wzrk_medium !== "undefined") {
              const wm = urlParams.wzrk_medium;
              if (wm.match(/^email$|^social$|^search$/)) {
                data.wm = wm;
              }
            }
          }
          data = _classPrivateFieldLooseBase(this, _request)[_request].addSystemDataToObject(data, void 0);
          data.cpg = currLocation;
          data[CAMP_COOKIE_NAME] = getCampaignObjForLc();
          let pageLoadUrl = _classPrivateFieldLooseBase(this, _account)[_account].dataPostURL;
          _classPrivateFieldLooseBase(this, _request)[_request].addFlags(data);
          if (parseInt(data.pg) === 1) {
            _classPrivateFieldLooseBase(this, _overrideDSyncFlag)[_overrideDSyncFlag](data);
          }
          pageLoadUrl = addToURL(pageLoadUrl, "type", "page");
          pageLoadUrl = addToURL(pageLoadUrl, "d", compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger)[_logger]));
          _classPrivateFieldLooseBase(this, _request)[_request].saveAndFireRequest(pageLoadUrl, $ct.blockRequest);
          if (parseInt(data.pg) === 1) {
            this.event.push(WZRK_FETCH, {
              t: 4
            });
          }
          _classPrivateFieldLooseBase(this, _previousUrl)[_previousUrl] = currLocation;
          setTimeout(() => {
            if (pgCount <= 3) {
              _classPrivateFieldLooseBase(this, _pingRequest)[_pingRequest]();
            }
            if (_classPrivateFieldLooseBase(this, _isPingContinuous)[_isPingContinuous]()) {
              setInterval(() => {
                _classPrivateFieldLooseBase(this, _pingRequest)[_pingRequest]();
              }, CONTINUOUS_PING_FREQ_IN_MILLIS);
            }
          }, FIRST_PING_FREQ_IN_MILLIS);
          _classPrivateFieldLooseBase(this, _updateUnviewedBadgePosition)[_updateUnviewedBadgePosition]();
        }
        _isPersonalisationActive() {
          return StorageManager._isLocalStorageSupported() && this.enablePersonalization;
        }
        // eslint-disable-next-line accessor-pairs
        set popupCallback(callback) {
          this.popupCallbacks[this.popupCurrentWzrkId] = callback;
        }
        /**
         *
         * @param {object} payload
         */
        // offline mode
        /**
         * events will be recorded and queued locally when passed with true
         * but will not be sent to the server until offline is disabled by passing false
         * @param {boolean} arg
         */
        setOffline(arg) {
          if (typeof arg !== "boolean") {
            console.error("setOffline should be called with a value of type boolean");
            return;
          }
          if ($ct.offline !== arg && !arg) {
            _classPrivateFieldLooseBase(this, _request)[_request].processBackupEvents();
          }
          $ct.offline = arg;
        }
        getSDKVersion() {
          return "web-sdk-v1.15.3";
        }
        defineVariable(name, defaultValue) {
          return Variable.define(name, defaultValue, _classPrivateFieldLooseBase(this, _variableStore)[_variableStore], _classPrivateFieldLooseBase(this, _logger)[_logger]);
        }
        defineFileVariable(name) {
          return Variable.defineFileVar(name, _classPrivateFieldLooseBase(this, _variableStore)[_variableStore], _classPrivateFieldLooseBase(this, _logger)[_logger]);
        }
        syncVariables(onSyncSuccess, onSyncFailure) {
          if (_classPrivateFieldLooseBase(this, _logger)[_logger].logLevel === 4) {
            return _classPrivateFieldLooseBase(this, _variableStore)[_variableStore].syncVariables(onSyncSuccess, onSyncFailure);
          } else {
            const m = "App log level is not set to 4";
            _classPrivateFieldLooseBase(this, _logger)[_logger].error(m);
            return Promise.reject(new Error(m));
          }
        }
        fetchVariables(onFetchCallback) {
          _classPrivateFieldLooseBase(this, _variableStore)[_variableStore].fetchVariables(onFetchCallback);
        }
        getVariables() {
          return reconstructNestedObject(StorageManager.readFromLSorCookie(VARIABLES));
        }
        getVariableValue(variableName) {
          const variables = StorageManager.readFromLSorCookie(VARIABLES);
          const reconstructedVariables = reconstructNestedObject(variables);
          if (variables.hasOwnProperty(variableName)) {
            return variables[variableName];
          } else if (reconstructedVariables.hasOwnProperty(variableName)) {
            return reconstructedVariables[variableName];
          }
        }
        addVariablesChangedCallback(callback) {
          _classPrivateFieldLooseBase(this, _variableStore)[_variableStore].addVariablesChangedCallback(callback);
        }
        addOneTimeVariablesChangedCallback(callback) {
          _classPrivateFieldLooseBase(this, _variableStore)[_variableStore].addOneTimeVariablesChangedCallback(callback);
        }
        /*
           This function is used for debugging and getting the details of all the campaigns
           that were qualified and rendered for the current user
        */
        getAllQualifiedCampaignDetails() {
          const existingCampaign = StorageManager.readFromLSorCookie(QUALIFIED_CAMPAIGNS) && JSON.parse(decodeURIComponent(StorageManager.readFromLSorCookie(QUALIFIED_CAMPAIGNS)));
          return existingCampaign;
        }
      }
      var _processOldValues2 = function _processOldValues22() {
        this.onUserLogin._processOldValues();
        this.privacy._processOldValues();
        this.event._processOldValues();
        this.profile._processOldValues();
        this.notifications._processOldValues();
      };
      var _debounce2 = function _debounce22(func) {
        let delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;
        let timeout;
        return function() {
          clearTimeout(timeout);
          timeout = setTimeout(func, delay);
        };
      };
      var _checkPageChanged2 = function _checkPageChanged22() {
        const debouncedPageChanged = _classPrivateFieldLooseBase(this, _debounce)[_debounce](() => {
          if (_classPrivateFieldLooseBase(this, _previousUrl)[_previousUrl] !== location.href) {
            this.pageChanged();
          }
        });
        debouncedPageChanged();
      };
      var _updateUnviewedBadgePosition2 = function _updateUnviewedBadgePosition22() {
        try {
          if (_classPrivateFieldLooseBase(this, _pageChangeTimeoutId)[_pageChangeTimeoutId]) {
            clearTimeout(_classPrivateFieldLooseBase(this, _pageChangeTimeoutId)[_pageChangeTimeoutId]);
          }
          const unViewedBadge = document.getElementById("unviewedBadge");
          if (!unViewedBadge) {
            _classPrivateFieldLooseBase(this, _logger)[_logger].debug("unViewedBadge not found");
            return;
          }
          unViewedBadge.style.display = "none";
          _classPrivateFieldLooseBase(this, _pageChangeTimeoutId)[_pageChangeTimeoutId] = setTimeout(() => {
            const config = StorageManager.readFromLSorCookie(WEBINBOX_CONFIG) || {};
            const inboxNode = document.getElementById(config === null || config === void 0 ? void 0 : config.inboxSelector);
            const unViewedBadge2 = document.getElementById("unviewedBadge");
            if (!unViewedBadge2) {
              _classPrivateFieldLooseBase(this, _logger)[_logger].debug("unViewedBadge not found");
              return;
            }
            if (inboxNode) {
              const {
                top,
                right
              } = inboxNode.getBoundingClientRect();
              if (Number(unViewedBadge2.innerText) > 0 || unViewedBadge2.innerText === "9+") {
                unViewedBadge2.style.display = "flex";
              }
              unViewedBadge2.style.top = "".concat(top - 8, "px");
              unViewedBadge2.style.left = "".concat(right - 8, "px");
            }
          }, TIMER_FOR_NOTIF_BADGE_UPDATE);
        } catch (error) {
          _classPrivateFieldLooseBase(this, _logger)[_logger].debug("Error updating unviewed badge position:", error);
        }
      };
      var _pingRequest2 = function _pingRequest22() {
        let pageLoadUrl = _classPrivateFieldLooseBase(this, _account)[_account].dataPostURL;
        let data = {};
        data = _classPrivateFieldLooseBase(this, _request)[_request].addSystemDataToObject(data, void 0);
        pageLoadUrl = addToURL(pageLoadUrl, "type", EVT_PING);
        pageLoadUrl = addToURL(pageLoadUrl, "d", compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger)[_logger]));
        _classPrivateFieldLooseBase(this, _request)[_request].saveAndFireRequest(pageLoadUrl, $ct.blockRequest);
      };
      var _isPingContinuous2 = function _isPingContinuous22() {
        return typeof window.wzrk_d !== "undefined" && window.wzrk_d.ping === "continuous";
      };
      var _overrideDSyncFlag2 = function _overrideDSyncFlag22(data) {
        if (this._isPersonalisationActive()) {
          data.dsync = true;
        }
      };
      var _sendLocationData2 = function _sendLocationData22(payload) {
        let data = {};
        data.af = {};
        const profileObj = {};
        data.type = "profile";
        if (profileObj.tz == null) {
          profileObj.tz = (/* @__PURE__ */ new Date()).toString().match(/([A-Z]+[\+-][0-9]+)/)[1];
        }
        data.profile = profileObj;
        if (payload) {
          const keys = Object.keys(payload);
          keys.forEach((key) => {
            data.af[key] = payload[key];
          });
        }
        if ($ct.location) {
          data.af = {
            ...data.af,
            ...$ct.location
          };
        }
        data = _classPrivateFieldLooseBase(this, _request)[_request].addSystemDataToObject(data, true);
        _classPrivateFieldLooseBase(this, _request)[_request].addFlags(data);
        const compressedData = compressData(JSON.stringify(data), _classPrivateFieldLooseBase(this, _logger)[_logger]);
        let pageLoadUrl = _classPrivateFieldLooseBase(this, _account)[_account].dataPostURL;
        pageLoadUrl = addToURL(pageLoadUrl, "type", EVT_PUSH);
        pageLoadUrl = addToURL(pageLoadUrl, "d", compressedData);
        _classPrivateFieldLooseBase(this, _request)[_request].saveAndFireRequest(pageLoadUrl, $ct.blockRequest);
      };
      const clevertap = new CleverTap(window.clevertap);
      window.clevertap = window.wizrocket = clevertap;
      return clevertap;
    });
  }
});
export default require_clevertap();
/*! Bundled license information:

clevertap-web-sdk/clevertap.js:
  (** @preserve
  (c) 2012 by Cdric Mesnil. All rights reserved.
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)
*/
//# sourceMappingURL=clevertap-web-sdk.js.map
